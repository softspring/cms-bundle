(() => {
    var e = {
        199: e => {
            !function () {
                "use strict";
                var t = function (e) {
                    if (null === e) return "null";
                    if (void 0 === e) return "undefined";
                    var t = typeof e;
                    return "object" === t && (Array.prototype.isPrototypeOf(e) || e.constructor && "Array" === e.constructor.name) ? "array" : "object" === t && (String.prototype.isPrototypeOf(e) || e.constructor && "String" === e.constructor.name) ? "string" : t
                }, n = function (e) {
                    return {eq: e}
                }, o = n((function (e, t) {
                    return e === t
                })), r = function (e) {
                    return n((function (t, n) {
                        if (t.length !== n.length) return !1;
                        for (var o = t.length, r = 0; r < o; r++) if (!e.eq(t[r], n[r])) return !1;
                        return !0
                    }))
                }, a = function (e, t) {
                    return function (e, t) {
                        return n((function (n, o) {
                            return e.eq(t(n), t(o))
                        }))
                    }(r(e), (function (e) {
                        return function (e, t) {
                            return Array.prototype.slice.call(e).sort(t)
                        }(e, t)
                    }))
                }, s = function (e) {
                    return n((function (t, n) {
                        var r = Object.keys(t), s = Object.keys(n);
                        if (!a(o).eq(r, s)) return !1;
                        for (var i = r.length, l = 0; l < i; l++) {
                            var d = r[l];
                            if (!e.eq(t[d], n[d])) return !1
                        }
                        return !0
                    }))
                }, i = n((function (e, n) {
                    if (e === n) return !0;
                    var o = t(e);
                    return o === t(n) && (function (e) {
                        return -1 !== ["undefined", "boolean", "number", "string", "function", "xml", "null"].indexOf(e)
                    }(o) ? e === n : "array" === o ? r(i).eq(e, n) : "object" === o && s(i).eq(e, n))
                }));
                const l = Object.getPrototypeOf, d = (e, t, n) => {
                        var o;
                        return !!n(e, t.prototype) || (null === (o = e.constructor) || void 0 === o ? void 0 : o.name) === t.name
                    }, c = e => t => (e => {
                        const t = typeof e;
                        return null === e ? "null" : "object" === t && Array.isArray(e) ? "array" : "object" === t && d(e, String, ((e, t) => t.isPrototypeOf(e))) ? "string" : t
                    })(t) === e, u = e => t => typeof t === e, m = e => t => e === t,
                    f = (e, t) => p(e) && d(e, t, ((e, t) => l(e) === t)), g = c("string"), p = c("object"),
                    h = e => f(e, Object), v = c("array"), b = m(null), y = u("boolean"), C = m(void 0),
                    E = e => null == e, w = e => !E(e), _ = u("function"), S = u("number"), k = (e, t) => {
                        if (v(e)) {
                            for (let n = 0, o = e.length; n < o; ++n) if (!t(e[n])) return !1;
                            return !0
                        }
                        return !1
                    }, x = () => {
                    }, A = (e, t) => (...n) => e(t.apply(null, n)), N = (e, t) => n => e(t(n)), T = e => () => e,
                    R = e => e, D = (e, t) => e === t;

                function L(e, ...t) {
                    return (...n) => {
                        const o = t.concat(n);
                        return e.apply(null, o)
                    }
                }

                const O = e => t => !e(t), B = e => () => {
                    throw new Error(e)
                }, P = e => e(), I = e => {
                    e()
                }, M = T(!1), F = T(!0);

                class U {
                    constructor(e, t) {
                        this.tag = e, this.value = t
                    }

                    static some(e) {
                        return new U(!0, e)
                    }

                    static none() {
                        return U.singletonNone
                    }

                    fold(e, t) {
                        return this.tag ? t(this.value) : e()
                    }

                    isSome() {
                        return this.tag
                    }

                    isNone() {
                        return !this.tag
                    }

                    map(e) {
                        return this.tag ? U.some(e(this.value)) : U.none()
                    }

                    bind(e) {
                        return this.tag ? e(this.value) : U.none()
                    }

                    exists(e) {
                        return this.tag && e(this.value)
                    }

                    forall(e) {
                        return !this.tag || e(this.value)
                    }

                    filter(e) {
                        return !this.tag || e(this.value) ? this : U.none()
                    }

                    getOr(e) {
                        return this.tag ? this.value : e
                    }

                    or(e) {
                        return this.tag ? this : e
                    }

                    getOrThunk(e) {
                        return this.tag ? this.value : e()
                    }

                    orThunk(e) {
                        return this.tag ? this : e()
                    }

                    getOrDie(e) {
                        if (this.tag) return this.value;
                        throw new Error(null != e ? e : "Called getOrDie on None")
                    }

                    static from(e) {
                        return w(e) ? U.some(e) : U.none()
                    }

                    getOrNull() {
                        return this.tag ? this.value : null
                    }

                    getOrUndefined() {
                        return this.value
                    }

                    each(e) {
                        this.tag && e(this.value)
                    }

                    toArray() {
                        return this.tag ? [this.value] : []
                    }

                    toString() {
                        return this.tag ? `some(${this.value})` : "none()"
                    }
                }

                U.singletonNone = new U(!1);
                const q = Array.prototype.slice, j = Array.prototype.indexOf, H = Array.prototype.push,
                    z = (e, t) => j.call(e, t), $ = (e, t) => z(e, t) > -1, V = (e, t) => {
                        for (let n = 0, o = e.length; n < o; n++) {
                            if (t(e[n], n)) return !0
                        }
                        return !1
                    }, W = (e, t) => {
                        const n = e.length, o = new Array(n);
                        for (let r = 0; r < n; r++) {
                            const n = e[r];
                            o[r] = t(n, r)
                        }
                        return o
                    }, K = (e, t) => {
                        for (let n = 0, o = e.length; n < o; n++) {
                            t(e[n], n)
                        }
                    }, Y = (e, t) => {
                        for (let n = e.length - 1; n >= 0; n--) {
                            t(e[n], n)
                        }
                    }, G = (e, t) => {
                        const n = [], o = [];
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r];
                            (t(a, r) ? n : o).push(a)
                        }
                        return {pass: n, fail: o}
                    }, X = (e, t) => {
                        const n = [];
                        for (let o = 0, r = e.length; o < r; o++) {
                            const r = e[o];
                            t(r, o) && n.push(r)
                        }
                        return n
                    }, J = (e, t, n) => (Y(e, ((e, o) => {
                        n = t(n, e, o)
                    })), n), Q = (e, t, n) => (K(e, ((e, o) => {
                        n = t(n, e, o)
                    })), n), Z = (e, t, n) => {
                        for (let o = 0, r = e.length; o < r; o++) {
                            const r = e[o];
                            if (t(r, o)) return U.some(r);
                            if (n(r, o)) break
                        }
                        return U.none()
                    }, ee = (e, t) => Z(e, t, M), te = (e, t) => {
                        for (let n = 0, o = e.length; n < o; n++) {
                            if (t(e[n], n)) return U.some(n)
                        }
                        return U.none()
                    }, ne = e => {
                        const t = [];
                        for (let n = 0, o = e.length; n < o; ++n) {
                            if (!v(e[n])) throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
                            H.apply(t, e[n])
                        }
                        return t
                    }, oe = (e, t) => ne(W(e, t)), re = (e, t) => {
                        for (let n = 0, o = e.length; n < o; ++n) {
                            if (!0 !== t(e[n], n)) return !1
                        }
                        return !0
                    }, ae = e => {
                        const t = q.call(e, 0);
                        return t.reverse(), t
                    }, se = (e, t) => X(e, (e => !$(t, e))), ie = (e, t) => {
                        const n = {};
                        for (let o = 0, r = e.length; o < r; o++) {
                            const r = e[o];
                            n[String(r)] = t(r, o)
                        }
                        return n
                    }, le = (e, t) => {
                        const n = q.call(e, 0);
                        return n.sort(t), n
                    }, de = (e, t) => t >= 0 && t < e.length ? U.some(e[t]) : U.none(), ce = e => de(e, 0),
                    ue = e => de(e, e.length - 1), me = _(Array.from) ? Array.from : e => q.call(e), fe = (e, t) => {
                        for (let n = 0; n < e.length; n++) {
                            const o = t(e[n], n);
                            if (o.isSome()) return o
                        }
                        return U.none()
                    }, ge = Object.keys, pe = Object.hasOwnProperty, he = (e, t) => {
                        const n = ge(e);
                        for (let o = 0, r = n.length; o < r; o++) {
                            const r = n[o];
                            t(e[r], r)
                        }
                    }, ve = (e, t) => be(e, ((e, n) => ({k: n, v: t(e, n)}))), be = (e, t) => {
                        const n = {};
                        return he(e, ((e, o) => {
                            const r = t(e, o);
                            n[r.k] = r.v
                        })), n
                    }, ye = e => (t, n) => {
                        e[n] = t
                    }, Ce = (e, t, n, o) => {
                        he(e, ((e, r) => {
                            (t(e, r) ? n : o)(e, r)
                        }))
                    }, Ee = (e, t) => {
                        const n = {};
                        return Ce(e, t, ye(n), x), n
                    }, we = (e, t) => {
                        const n = [];
                        return he(e, ((e, o) => {
                            n.push(t(e, o))
                        })), n
                    }, _e = e => we(e, R), Se = (e, t) => ke(e, t) ? U.from(e[t]) : U.none(), ke = (e, t) => pe.call(e, t),
                    xe = (e, t) => ke(e, t) && void 0 !== e[t] && null !== e[t], Ae = e => {
                        const t = {};
                        return K(e, (e => {
                            t[e] = {}
                        })), ge(t)
                    }, Ne = e => void 0 !== e.length, Te = Array.isArray, Re = (e, t, n) => {
                        if (!e) return !1;
                        if (n = n || e, Ne(e)) {
                            for (let o = 0, r = e.length; o < r; o++) if (!1 === t.call(n, e[o], o, e)) return !1
                        } else for (const o in e) if (ke(e, o) && !1 === t.call(n, e[o], o, e)) return !1;
                        return !0
                    }, De = (e, t) => {
                        const n = [];
                        return Re(e, ((o, r) => {
                            n.push(t(o, r, e))
                        })), n
                    }, Le = (e, t) => {
                        const n = [];
                        return Re(e, ((o, r) => {
                            t && !t(o, r, e) || n.push(o)
                        })), n
                    }, Oe = (e, t, n, o) => {
                        let r = C(n) ? e[0] : n;
                        for (let n = 0; n < e.length; n++) r = t.call(o, r, e[n], n);
                        return r
                    }, Be = (e, t, n) => {
                        for (let o = 0, r = e.length; o < r; o++) if (t.call(n, e[o], o, e)) return o;
                        return -1
                    }, Pe = e => e[e.length - 1], Ie = e => {
                        let t, n = !1;
                        return (...o) => (n || (n = !0, t = e.apply(null, o)), t)
                    }, Me = () => Fe(0, 0), Fe = (e, t) => ({major: e, minor: t}), Ue = {
                        nu: Fe, detect: (e, t) => {
                            const n = String(t).toLowerCase();
                            return 0 === e.length ? Me() : ((e, t) => {
                                const n = ((e, t) => {
                                    for (let n = 0; n < e.length; n++) {
                                        const o = e[n];
                                        if (o.test(t)) return o
                                    }
                                })(e, t);
                                if (!n) return {major: 0, minor: 0};
                                const o = e => Number(t.replace(n, "$" + e));
                                return Fe(o(1), o(2))
                            })(e, n)
                        }, unknown: Me
                    }, qe = (e, t) => {
                        const n = String(t).toLowerCase();
                        return ee(e, (e => e.search(n)))
                    }, je = (e, t, n) => "" === t || e.length >= t.length && e.substr(n, n + t.length) === t,
                    He = (e, t) => $e(e, t) ? ((e, t) => e.substring(t))(e, t.length) : e, ze = (e, t, n = 0, o) => {
                        const r = e.indexOf(t, n);
                        return -1 !== r && (!!C(o) || r + t.length <= o)
                    }, $e = (e, t) => je(e, t, 0), Ve = (e, t) => je(e, t, e.length - t.length),
                    We = e => t => t.replace(e, ""), Ke = We(/^\s+|\s+$/g), Ye = We(/^\s+/g), Ge = We(/\s+$/g),
                    Xe = e => e.length > 0, Je = e => !Xe(e), Qe = (e, t = 10) => {
                        const n = parseInt(e, t);
                        return isNaN(n) ? U.none() : U.some(n)
                    }, Ze = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, et = e => t => ze(t, e), tt = [{
                        name: "Edge",
                        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
                        search: e => ze(e, "edge/") && ze(e, "chrome") && ze(e, "safari") && ze(e, "applewebkit")
                    }, {
                        name: "Chromium",
                        brand: "Chromium",
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Ze],
                        search: e => ze(e, "chrome") && !ze(e, "chromeframe")
                    }, {
                        name: "IE",
                        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
                        search: e => ze(e, "msie") || ze(e, "trident")
                    }, {
                        name: "Opera",
                        versionRegexes: [Ze, /.*?opera\/([0-9]+)\.([0-9]+).*/],
                        search: et("opera")
                    }, {
                        name: "Firefox",
                        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
                        search: et("firefox")
                    }, {
                        name: "Safari",
                        versionRegexes: [Ze, /.*?cpu os ([0-9]+)_([0-9]+).*/],
                        search: e => (ze(e, "safari") || ze(e, "mobile/")) && ze(e, "applewebkit")
                    }], nt = [{
                        name: "Windows",
                        search: et("win"),
                        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "iOS",
                        search: e => ze(e, "iphone") || ze(e, "ipad"),
                        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
                    }, {
                        name: "Android",
                        search: et("android"),
                        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
                    }, {
                        name: "macOS",
                        search: et("mac os x"),
                        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
                    }, {name: "Linux", search: et("linux"), versionRegexes: []}, {
                        name: "Solaris",
                        search: et("sunos"),
                        versionRegexes: []
                    }, {name: "FreeBSD", search: et("freebsd"), versionRegexes: []}, {
                        name: "ChromeOS",
                        search: et("cros"),
                        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
                    }], ot = {browsers: T(tt), oses: T(nt)}, rt = "Edge", at = "Chromium", st = "Opera", it = "Firefox",
                    lt = "Safari", dt = e => {
                        const t = e.current, n = e.version, o = e => () => t === e;
                        return {
                            current: t,
                            version: n,
                            isEdge: o(rt),
                            isChromium: o(at),
                            isIE: o("IE"),
                            isOpera: o(st),
                            isFirefox: o(it),
                            isSafari: o(lt)
                        }
                    }, ct = {
                        unknown: () => dt({current: void 0, version: Ue.unknown()}),
                        nu: dt,
                        edge: T(rt),
                        chromium: T(at),
                        ie: T("IE"),
                        opera: T(st),
                        firefox: T(it),
                        safari: T(lt)
                    }, ut = "Windows", mt = "Android", ft = "Linux", gt = "macOS", pt = "Solaris", ht = "FreeBSD",
                    vt = "ChromeOS", bt = e => {
                        const t = e.current, n = e.version, o = e => () => t === e;
                        return {
                            current: t,
                            version: n,
                            isWindows: o(ut),
                            isiOS: o("iOS"),
                            isAndroid: o(mt),
                            isMacOS: o(gt),
                            isLinux: o(ft),
                            isSolaris: o(pt),
                            isFreeBSD: o(ht),
                            isChromeOS: o(vt)
                        }
                    }, yt = {
                        unknown: () => bt({current: void 0, version: Ue.unknown()}),
                        nu: bt,
                        windows: T(ut),
                        ios: T("iOS"),
                        android: T(mt),
                        linux: T(ft),
                        macos: T(gt),
                        solaris: T(pt),
                        freebsd: T(ht),
                        chromeos: T(vt)
                    }, Ct = (e, t, n) => {
                        const o = ot.browsers(), r = ot.oses(), a = t.bind((e => ((e, t) => fe(t.brands, (t => {
                            const n = t.brand.toLowerCase();
                            return ee(e, (e => {
                                var t;
                                return n === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
                            })).map((e => ({current: e.name, version: Ue.nu(parseInt(t.version, 10), 0)})))
                        })))(o, e))).orThunk((() => ((e, t) => qe(e, t).map((e => {
                            const n = Ue.detect(e.versionRegexes, t);
                            return {current: e.name, version: n}
                        })))(o, e))).fold(ct.unknown, ct.nu), s = ((e, t) => qe(e, t).map((e => {
                            const n = Ue.detect(e.versionRegexes, t);
                            return {current: e.name, version: n}
                        })))(r, e).fold(yt.unknown, yt.nu), i = ((e, t, n, o) => {
                            const r = e.isiOS() && !0 === /ipad/i.test(n), a = e.isiOS() && !r,
                                s = e.isiOS() || e.isAndroid(), i = s || o("(pointer:coarse)"),
                                l = r || !a && s && o("(min-device-width:768px)"), d = a || s && !l,
                                c = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n), u = !d && !l && !c;
                            return {
                                isiPad: T(r),
                                isiPhone: T(a),
                                isTablet: T(l),
                                isPhone: T(d),
                                isTouch: T(i),
                                isAndroid: e.isAndroid,
                                isiOS: e.isiOS,
                                isWebView: T(c),
                                isDesktop: T(u)
                            }
                        })(s, a, e, n);
                        return {browser: a, os: s, deviceType: i}
                    }, Et = e => window.matchMedia(e).matches;
                let wt = Ie((() => Ct(navigator.userAgent, U.from(navigator.userAgentData), Et)));
                const _t = () => wt(), St = navigator.userAgent, kt = _t(), xt = kt.browser, At = kt.os,
                    Nt = kt.deviceType, Tt = -1 !== St.indexOf("Windows Phone"), Rt = {
                        transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
                        documentMode: xt.isIE() ? document.documentMode || 7 : 10,
                        cacheSuffix: null,
                        container: null,
                        canHaveCSP: !xt.isIE(),
                        windowsPhone: Tt,
                        browser: {
                            current: xt.current,
                            version: xt.version,
                            isChromium: xt.isChromium,
                            isEdge: xt.isEdge,
                            isFirefox: xt.isFirefox,
                            isIE: xt.isIE,
                            isOpera: xt.isOpera,
                            isSafari: xt.isSafari
                        },
                        os: {
                            current: At.current,
                            version: At.version,
                            isAndroid: At.isAndroid,
                            isChromeOS: At.isChromeOS,
                            isFreeBSD: At.isFreeBSD,
                            isiOS: At.isiOS,
                            isLinux: At.isLinux,
                            isMacOS: At.isMacOS,
                            isSolaris: At.isSolaris,
                            isWindows: At.isWindows
                        },
                        deviceType: {
                            isDesktop: Nt.isDesktop,
                            isiPad: Nt.isiPad,
                            isiPhone: Nt.isiPhone,
                            isPhone: Nt.isPhone,
                            isTablet: Nt.isTablet,
                            isTouch: Nt.isTouch,
                            isWebView: Nt.isWebView
                        }
                    }, Dt = /^\s*|\s*$/g, Lt = e => E(e) ? "" : ("" + e).replace(Dt, ""), Ot = function (e, t, n, o) {
                        o = o || this, e && (n && (e = e[n]), Re(e, ((e, r) => !1 !== t.call(o, e, r, n) && (Ot(e, t, n, o), !0))))
                    }, Bt = {
                        trim: Lt,
                        isArray: Te,
                        is: (e, t) => t ? !("array" !== t || !Te(e)) || typeof e === t : void 0 !== e,
                        toArray: e => {
                            if (Te(e)) return e;
                            {
                                const t = [];
                                for (let n = 0, o = e.length; n < o; n++) t[n] = e[n];
                                return t
                            }
                        },
                        makeMap: (e, t, n = {}) => {
                            const o = g(e) ? e.split(t || ",") : e || [];
                            let r = o.length;
                            for (; r--;) n[o[r]] = {};
                            return n
                        },
                        each: Re,
                        map: De,
                        grep: Le,
                        inArray: (e, t) => {
                            if (e) for (let n = 0, o = e.length; n < o; n++) if (e[n] === t) return n;
                            return -1
                        },
                        hasOwn: ke,
                        extend: (e, ...t) => {
                            for (let n = 0; n < t.length; n++) {
                                const o = t[n];
                                for (const t in o) if (ke(o, t)) {
                                    const n = o[t];
                                    void 0 !== n && (e[t] = n)
                                }
                            }
                            return e
                        },
                        walk: Ot,
                        resolve: (e, t = window) => {
                            const n = e.split(".");
                            for (let e = 0, o = n.length; e < o && (t = t[n[e]]); e++) ;
                            return t
                        },
                        explode: (e, t) => v(e) ? e : "" === e ? [] : De(e.split(t || ","), Lt),
                        _addCacheSuffix: e => {
                            const t = Rt.cacheSuffix;
                            return t && (e += (-1 === e.indexOf("?") ? "?" : "&") + t), e
                        }
                    }, Pt = (e, t, n = D) => e.exists((e => n(e, t))),
                    It = (e, t, n = D) => Mt(e, t, n).getOr(e.isNone() && t.isNone()),
                    Mt = (e, t, n) => e.isSome() && t.isSome() ? U.some(n(e.getOrDie(), t.getOrDie())) : U.none(),
                    Ft = (e, t) => e ? U.some(t) : U.none(),
                    Ut = "undefined" != typeof window ? window : Function("return this;")(), qt = (e, t) => ((e, t) => {
                        let n = null != t ? t : Ut;
                        for (let t = 0; t < e.length && null != n; ++t) n = n[e[t]];
                        return n
                    })(e.split("."), t), jt = (e, t) => {
                        const n = ((e, t) => qt(e, t))(e, t);
                        if (null == n) throw new Error(e + " not available on this browser");
                        return n
                    }, Ht = Object.getPrototypeOf, zt = e => {
                        const t = qt("ownerDocument.defaultView", e);
                        return p(e) && ((e => jt("HTMLElement", e))(t).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(Ht(e).constructor.name))
                    }, $t = e => e.dom.nodeName.toLowerCase(), Vt = e => e.dom.nodeType, Wt = e => t => Vt(t) === e,
                    Kt = e => Yt(e) && zt(e.dom), Yt = Wt(1), Gt = Wt(3), Xt = Wt(9), Jt = Wt(11),
                    Qt = e => t => Yt(t) && $t(t) === e, Zt = (e, t, n) => {
                        if (!(g(n) || y(n) || S(n))) throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e), new Error("Attribute value was not simple");
                        e.setAttribute(t, n + "")
                    }, en = (e, t, n) => {
                        Zt(e.dom, t, n)
                    }, tn = (e, t) => {
                        const n = e.dom;
                        he(t, ((e, t) => {
                            Zt(n, t, e)
                        }))
                    }, nn = (e, t) => {
                        const n = e.dom.getAttribute(t);
                        return null === n ? void 0 : n
                    }, on = (e, t) => U.from(nn(e, t)), rn = (e, t) => {
                        const n = e.dom;
                        return !(!n || !n.hasAttribute) && n.hasAttribute(t)
                    }, an = (e, t) => {
                        e.dom.removeAttribute(t)
                    }, sn = e => Q(e.dom.attributes, ((e, t) => (e[t.name] = t.value, e)), {}), ln = (e, t) => {
                        const n = nn(e, t);
                        return void 0 === n || "" === n ? [] : n.split(" ")
                    }, dn = e => void 0 !== e.dom.classList, cn = e => ln(e, "class"), un = (e, t) => ((e, t, n) => {
                        const o = ln(e, t).concat([n]);
                        return en(e, t, o.join(" ")), !0
                    })(e, "class", t), mn = (e, t) => ((e, t, n) => {
                        const o = X(ln(e, t), (e => e !== n));
                        return o.length > 0 ? en(e, t, o.join(" ")) : an(e, t), !1
                    })(e, "class", t), fn = (e, t) => {
                        dn(e) ? e.dom.classList.add(t) : un(e, t)
                    }, gn = e => {
                        0 === (dn(e) ? e.dom.classList : cn(e)).length && an(e, "class")
                    }, pn = (e, t) => {
                        if (dn(e)) {
                            e.dom.classList.remove(t)
                        } else mn(e, t);
                        gn(e)
                    }, hn = (e, t) => {
                        const n = dn(e) ? e.dom.classList.toggle(t) : ((e, t) => $(cn(e), t) ? mn(e, t) : un(e, t))(e, t);
                        return gn(e), n
                    }, vn = (e, t) => dn(e) && e.dom.classList.contains(t), bn = e => {
                        if (null == e) throw new Error("Node cannot be null or undefined");
                        return {dom: e}
                    }, yn = {
                        fromHtml: (e, t) => {
                            const n = (t || document).createElement("div");
                            if (n.innerHTML = e, !n.hasChildNodes() || n.childNodes.length > 1) {
                                const t = "HTML does not have a single root node";
                                throw console.error(t, e), new Error(t)
                            }
                            return bn(n.childNodes[0])
                        }, fromTag: (e, t) => {
                            const n = (t || document).createElement(e);
                            return bn(n)
                        }, fromText: (e, t) => {
                            const n = (t || document).createTextNode(e);
                            return bn(n)
                        }, fromDom: bn, fromPoint: (e, t, n) => U.from(e.dom.elementFromPoint(t, n)).map(bn)
                    }, Cn = (e, t) => {
                        const n = [], o = e => (n.push(e), t(e));
                        let r = t(e);
                        do {
                            r = r.bind(o)
                        } while (r.isSome());
                        return n
                    }, En = (e, t) => {
                        const n = e.dom;
                        if (1 !== n.nodeType) return !1;
                        {
                            const e = n;
                            if (void 0 !== e.matches) return e.matches(t);
                            if (void 0 !== e.msMatchesSelector) return e.msMatchesSelector(t);
                            if (void 0 !== e.webkitMatchesSelector) return e.webkitMatchesSelector(t);
                            if (void 0 !== e.mozMatchesSelector) return e.mozMatchesSelector(t);
                            throw new Error("Browser lacks native selectors")
                        }
                    }, wn = e => 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount,
                    _n = (e, t) => e.dom === t.dom, Sn = (e, t) => {
                        const n = e.dom, o = t.dom;
                        return n !== o && n.contains(o)
                    }, kn = e => yn.fromDom(e.dom.ownerDocument), xn = e => Xt(e) ? e : kn(e),
                    An = e => yn.fromDom(xn(e).dom.defaultView), Nn = e => U.from(e.dom.parentNode).map(yn.fromDom),
                    Tn = e => U.from(e.dom.parentElement).map(yn.fromDom), Rn = (e, t) => {
                        const n = _(t) ? t : M;
                        let o = e.dom;
                        const r = [];
                        for (; null !== o.parentNode && void 0 !== o.parentNode;) {
                            const e = o.parentNode, t = yn.fromDom(e);
                            if (r.push(t), !0 === n(t)) break;
                            o = e
                        }
                        return r
                    }, Dn = e => U.from(e.dom.previousSibling).map(yn.fromDom),
                    Ln = e => U.from(e.dom.nextSibling).map(yn.fromDom), On = e => ae(Cn(e, Dn)), Bn = e => Cn(e, Ln),
                    Pn = e => W(e.dom.childNodes, yn.fromDom), In = (e, t) => {
                        const n = e.dom.childNodes;
                        return U.from(n[t]).map(yn.fromDom)
                    }, Mn = e => In(e, 0), Fn = e => In(e, e.dom.childNodes.length - 1), Un = e => e.dom.childNodes.length,
                    qn = e => Jt(e) && w(e.dom.host),
                    jn = _(Element.prototype.attachShadow) && _(Node.prototype.getRootNode), Hn = T(jn),
                    zn = jn ? e => yn.fromDom(e.dom.getRootNode()) : xn, $n = e => qn(e) ? e : (e => {
                        const t = e.dom.head;
                        if (null == t) throw new Error("Head is not available yet");
                        return yn.fromDom(t)
                    })(xn(e)), Vn = e => yn.fromDom(e.dom.host), Wn = e => {
                        if (Hn() && w(e.target)) {
                            const t = yn.fromDom(e.target);
                            if (Yt(t) && Kn(t) && e.composed && e.composedPath) {
                                const t = e.composedPath();
                                if (t) return ce(t)
                            }
                        }
                        return U.from(e.target)
                    }, Kn = e => w(e.dom.shadowRoot), Yn = e => {
                        const t = Gt(e) ? e.dom.parentNode : e.dom;
                        if (null == t || null === t.ownerDocument) return !1;
                        const n = t.ownerDocument;
                        return (e => {
                            const t = zn(e);
                            return qn(t) ? U.some(t) : U.none()
                        })(yn.fromDom(t)).fold((() => n.body.contains(t)), N(Yn, Vn))
                    };
                var Gn = (e, t, n, o, r) => e(n, o) ? U.some(n) : _(r) && r(n) ? U.none() : t(n, o, r);
                const Xn = (e, t, n) => {
                        let o = e.dom;
                        const r = _(n) ? n : M;
                        for (; o.parentNode;) {
                            o = o.parentNode;
                            const e = yn.fromDom(o);
                            if (t(e)) return U.some(e);
                            if (r(e)) break
                        }
                        return U.none()
                    }, Jn = (e, t, n) => Gn(((e, t) => t(e)), Xn, e, t, n),
                    Qn = (e, t) => ee(e.dom.childNodes, (e => t(yn.fromDom(e)))).map(yn.fromDom), Zn = (e, t) => {
                        const n = e => {
                            for (let o = 0; o < e.childNodes.length; o++) {
                                const r = yn.fromDom(e.childNodes[o]);
                                if (t(r)) return U.some(r);
                                const a = n(e.childNodes[o]);
                                if (a.isSome()) return a
                            }
                            return U.none()
                        };
                        return n(e.dom)
                    }, eo = (e, t, n) => Xn(e, (e => En(e, t)), n), to = (e, t) => ((e, t) => {
                        const n = void 0 === t ? document : t.dom;
                        return wn(n) ? U.none() : U.from(n.querySelector(e)).map(yn.fromDom)
                    })(t, e), no = (e, t, n) => Gn(((e, t) => En(e, t)), eo, e, t, n), oo = (e, t = !1) => {
                        return Yn(e) ? e.dom.isContentEditable : (n = e, no(n, "[contenteditable]")).fold(T(t), (e => "true" === ro(e)));
                        var n
                    }, ro = e => e.dom.contentEditable, ao = e => void 0 !== e.style && _(e.style.getPropertyValue),
                    so = (e, t, n) => {
                        if (!g(n)) throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e), new Error("CSS value must be a string: " + n);
                        ao(e) && e.style.setProperty(t, n)
                    }, io = (e, t, n) => {
                        const o = e.dom;
                        so(o, t, n)
                    }, lo = (e, t) => {
                        const n = e.dom;
                        he(t, ((e, t) => {
                            so(n, t, e)
                        }))
                    }, co = (e, t) => {
                        const n = e.dom, o = window.getComputedStyle(n).getPropertyValue(t);
                        return "" !== o || Yn(e) ? o : uo(n, t)
                    }, uo = (e, t) => ao(e) ? e.style.getPropertyValue(t) : "", mo = (e, t) => {
                        const n = e.dom, o = uo(n, t);
                        return U.from(o).filter((e => e.length > 0))
                    }, fo = e => {
                        const t = {}, n = e.dom;
                        if (ao(n)) for (let e = 0; e < n.style.length; e++) {
                            const o = n.style.item(e);
                            t[o] = n.style[o]
                        }
                        return t
                    }, go = (e, t) => {
                        ((e, t) => {
                            ao(e) && e.style.removeProperty(t)
                        })(e.dom, t), Pt(on(e, "style").map(Ke), "") && an(e, "style")
                    }, po = (e, t) => {
                        Nn(e).each((n => {
                            n.dom.insertBefore(t.dom, e.dom)
                        }))
                    }, ho = (e, t) => {
                        Ln(e).fold((() => {
                            Nn(e).each((e => {
                                bo(e, t)
                            }))
                        }), (e => {
                            po(e, t)
                        }))
                    }, vo = (e, t) => {
                        Mn(e).fold((() => {
                            bo(e, t)
                        }), (n => {
                            e.dom.insertBefore(t.dom, n.dom)
                        }))
                    }, bo = (e, t) => {
                        e.dom.appendChild(t.dom)
                    }, yo = (e, t) => {
                        po(e, t), bo(t, e)
                    }, Co = (e, t) => {
                        K(t, (t => {
                            bo(e, t)
                        }))
                    }, Eo = e => {
                        e.dom.textContent = "", K(Pn(e), (e => {
                            wo(e)
                        }))
                    }, wo = e => {
                        const t = e.dom;
                        null !== t.parentNode && t.parentNode.removeChild(t)
                    }, _o = e => {
                        const t = Pn(e);
                        var n, o;
                        t.length > 0 && (n = e, K(o = t, ((e, t) => {
                            const r = 0 === t ? n : o[t - 1];
                            ho(r, e)
                        }))), wo(e)
                    }, So = e => W(e, yn.fromDom), ko = e => e.dom.innerHTML, xo = (e, t) => {
                        const n = kn(e).dom, o = yn.fromDom(n.createDocumentFragment()), r = ((e, t) => {
                            const n = (t || document).createElement("div");
                            return n.innerHTML = e, Pn(yn.fromDom(n))
                        })(t, n);
                        Co(o, r), Eo(e), bo(e, o)
                    }, Ao = (e, t) => n => {
                        e(n) && t((e => {
                            const t = yn.fromDom(Wn(e).getOr(e.target)), n = () => e.stopPropagation(),
                                o = () => e.preventDefault(), r = A(o, n);
                            return ((e, t, n, o, r, a, s) => ({
                                target: e,
                                x: t,
                                y: n,
                                stop: o,
                                prevent: r,
                                kill: a,
                                raw: s
                            }))(t, e.clientX, e.clientY, n, o, r, e)
                        })(n))
                    }, No = (e, t, n, o) => ((e, t, n, o, r) => {
                        const a = Ao(n, o);
                        return e.dom.addEventListener(t, a, r), {unbind: L(To, e, t, a, r)}
                    })(e, t, n, o, !1), To = (e, t, n, o) => {
                        e.dom.removeEventListener(t, n, o)
                    }, Ro = (e, t) => ({left: e, top: t, translate: (n, o) => Ro(e + n, t + o)}), Do = Ro,
                    Lo = (e, t) => void 0 !== e ? e : void 0 !== t ? t : 0, Oo = e => {
                        const t = e.dom, n = t.ownerDocument.body;
                        return n === t ? Do(n.offsetLeft, n.offsetTop) : Yn(e) ? (e => {
                            const t = e.getBoundingClientRect();
                            return Do(t.left, t.top)
                        })(t) : Do(0, 0)
                    }, Bo = e => {
                        const t = void 0 !== e ? e.dom : document, n = t.body.scrollLeft || t.documentElement.scrollLeft,
                            o = t.body.scrollTop || t.documentElement.scrollTop;
                        return Do(n, o)
                    }, Po = (e, t, n) => {
                        const o = (void 0 !== n ? n.dom : document).defaultView;
                        o && o.scrollTo(e, t)
                    }, Io = (e, t) => {
                        _t().browser.isSafari() && _(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t)
                    }, Mo = (e, t, n, o) => ({x: e, y: t, width: n, height: o, right: e + n, bottom: t + o}), Fo = e => {
                        const t = void 0 === e ? window : e, n = t.document, o = Bo(yn.fromDom(n));
                        return (e => {
                            const t = void 0 === e ? window : e;
                            return _t().browser.isFirefox() ? U.none() : U.from(t.visualViewport)
                        })(t).fold((() => {
                            const e = t.document.documentElement, n = e.clientWidth, r = e.clientHeight;
                            return Mo(o.left, o.top, n, r)
                        }), (e => Mo(Math.max(e.pageLeft, o.left), Math.max(e.pageTop, o.top), e.width, e.height)))
                    }, Uo = (e, t) => {
                        let n = [];
                        return K(Pn(e), (e => {
                            t(e) && (n = n.concat([e])), n = n.concat(Uo(e, t))
                        })), n
                    }, qo = (e, t) => ((e, t) => {
                        const n = void 0 === t ? document : t.dom;
                        return wn(n) ? [] : W(n.querySelectorAll(e), yn.fromDom)
                    })(t, e), jo = (e, t, n) => eo(e, t, n).isSome();

                class Ho {
                    constructor(e, t) {
                        this.node = e, this.rootNode = t, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this)
                    }

                    current() {
                        return this.node
                    }

                    next(e) {
                        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", e), this.node
                    }

                    prev(e) {
                        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", e), this.node
                    }

                    prev2(e) {
                        return this.node = this.findPreviousNode(this.node, e), this.node
                    }

                    findSibling(e, t, n, o) {
                        if (e) {
                            if (!o && e[t]) return e[t];
                            if (e !== this.rootNode) {
                                let t = e[n];
                                if (t) return t;
                                for (let o = e.parentNode; o && o !== this.rootNode; o = o.parentNode) if (t = o[n], t) return t
                            }
                        }
                    }

                    findPreviousNode(e, t) {
                        if (e) {
                            const n = e.previousSibling;
                            if (this.rootNode && n === this.rootNode) return;
                            if (n) {
                                if (!t) for (let e = n.lastChild; e; e = e.lastChild) if (!e.lastChild) return e;
                                return n
                            }
                            const o = e.parentNode;
                            if (o && o !== this.rootNode) return o
                        }
                    }
                }

                const zo = e => t => !!t && t.nodeType === e, $o = e => !!e && !Object.getPrototypeOf(e), Vo = zo(1),
                    Wo = e => Vo(e) && Kt(yn.fromDom(e)), Ko = e => {
                        const t = e.toLowerCase();
                        return e => w(e) && e.nodeName.toLowerCase() === t
                    }, Yo = e => {
                        const t = e.map((e => e.toLowerCase()));
                        return e => {
                            if (e && e.nodeName) {
                                const n = e.nodeName.toLowerCase();
                                return $(t, n)
                            }
                            return !1
                        }
                    }, Go = (e, t) => {
                        const n = t.toLowerCase().split(" ");
                        return t => {
                            if (Vo(t)) {
                                const o = t.ownerDocument.defaultView;
                                if (o) for (let r = 0; r < n.length; r++) {
                                    const a = o.getComputedStyle(t, null);
                                    if ((a ? a.getPropertyValue(e) : null) === n[r]) return !0
                                }
                            }
                            return !1
                        }
                    }, Xo = e => t => Vo(t) && t.hasAttribute(e), Jo = e => Vo(e) && e.hasAttribute("data-mce-bogus"),
                    Qo = e => Vo(e) && "TABLE" === e.tagName, Zo = e => t => {
                        if (Wo(t)) {
                            if (t.contentEditable === e) return !0;
                            if (t.getAttribute("data-mce-contenteditable") === e) return !0
                        }
                        return !1
                    }, er = Yo(["textarea", "input"]), tr = zo(3), nr = zo(4), or = zo(7), rr = zo(8), ar = zo(9),
                    sr = zo(11), ir = Ko("br"), lr = Ko("img"), dr = Zo("true"), cr = Zo("false"),
                    ur = Yo(["td", "th"]), mr = Yo(["td", "th", "caption"]),
                    fr = Yo(["video", "audio", "object", "embed"]), gr = Ko("li"), pr = Ko("details"),
                    hr = Ko("summary"), vr = "\ufeff", br = " ", yr = e => e === vr, Cr = ((e, t) => {
                        const n = t => e(t) ? U.from(t.dom.nodeValue) : U.none();
                        return {
                            get: o => {
                                if (!e(o)) throw new Error("Can only get " + t + " value of a " + t + " node");
                                return n(o).getOr("")
                            }, getOption: n, set: (n, o) => {
                                if (!e(n)) throw new Error("Can only set raw " + t + " value of a " + t + " node");
                                n.dom.nodeValue = o
                            }
                        }
                    })(Gt, "text"), Er = e => Cr.get(e), wr = e => Cr.getOption(e), _r = e => {
                        let t;
                        return n => (t = t || ie(e, F), ke(t, $t(n)))
                    }, Sr = e => Yt(e) && "br" === $t(e),
                    kr = _r(["h1", "h2", "h3", "h4", "h5", "h6", "p", "div", "address", "pre", "form", "blockquote", "center", "dir", "fieldset", "header", "footer", "article", "section", "hgroup", "aside", "nav", "figure"]),
                    xr = _r(["ul", "ol", "dl"]), Ar = _r(["li", "dd", "dt"]), Nr = _r(["thead", "tbody", "tfoot"]),
                    Tr = _r(["td", "th"]), Rr = _r(["pre", "script", "textarea", "style"]), Dr = e => {
                        const t = qo(e, "br"), n = X((e => {
                            const t = [];
                            let n = e.dom;
                            for (; n;) t.push(yn.fromDom(n)), n = n.lastChild;
                            return t
                        })(e).slice(-1), Sr);
                        t.length === n.length && K(n, wo)
                    }, Lr = () => {
                        const e = yn.fromTag("br");
                        return en(e, "data-mce-bogus", "1"), e
                    }, Or = e => {
                        Eo(e), bo(e, Lr())
                    }, Br = vr, Pr = yr, Ir = e => e.replace(/\uFEFF/g, ""), Mr = Vo, Fr = tr,
                    Ur = e => (Fr(e) && (e = e.parentNode), Mr(e) && e.hasAttribute("data-mce-caret")),
                    qr = e => Fr(e) && Pr(e.data), jr = e => Ur(e) || qr(e),
                    Hr = e => e.firstChild !== e.lastChild || !ir(e.firstChild), zr = e => {
                        const t = e.container();
                        return !!tr(t) && (t.data.charAt(e.offset()) === Br || e.isAtStart() && qr(t.previousSibling))
                    }, $r = e => {
                        const t = e.container();
                        return !!tr(t) && (t.data.charAt(e.offset() - 1) === Br || e.isAtEnd() && qr(t.nextSibling))
                    }, Vr = e => Fr(e) && e.data[0] === Br, Wr = e => Fr(e) && e.data[e.data.length - 1] === Br,
                    Kr = e => e && e.hasAttribute("data-mce-caret") ? ((e => {
                        var t;
                        const n = e.getElementsByTagName("br"), o = n[n.length - 1];
                        Jo(o) && (null === (t = o.parentNode) || void 0 === t || t.removeChild(o))
                    })(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null,
                    Yr = e => Ur(e.startContainer), Gr = dr, Xr = cr, Jr = ir, Qr = tr,
                    Zr = Yo(["script", "style", "textarea"]),
                    ea = Yo(["img", "input", "textarea", "hr", "iframe", "video", "audio", "object", "embed"]),
                    ta = Yo(["table"]), na = jr,
                    oa = e => !na(e) && (Qr(e) ? !Zr(e.parentNode) : ea(e) || Jr(e) || ta(e) || ra(e)),
                    ra = e => !(e => Vo(e) && "true" === e.getAttribute("unselectable"))(e) && Xr(e),
                    aa = (e, t) => oa(e) && ((e, t) => {
                        for (let n = e.parentNode; n && n !== t; n = n.parentNode) {
                            if (ra(n)) return !1;
                            if (Gr(n)) return !0
                        }
                        return !0
                    })(e, t), sa = /^[ \t\r\n]*$/, ia = e => sa.test(e), la = e => {
                        for (const t of e) if (!yr(t)) return !1;
                        return !0
                    }, da = e => "\n" === e || "\r" === e, ca = (e, t = 4, n = !0, o = !0) => {
                        const r = ((e, t) => t <= 0 ? "" : new Array(t + 1).join(e))(" ", t), a = e.replace(/\t/g, r),
                            s = Q(a, ((e, t) => (e => -1 !== " \f\t\v".indexOf(e))(t) || t === br ? e.pcIsSpace || "" === e.str && n || e.str.length === a.length - 1 && o || ((e, t) => t < e.length && t >= 0 && da(e[t]))(a, e.str.length + 1) ? {
                                pcIsSpace: !1,
                                str: e.str + br
                            } : {pcIsSpace: !0, str: e.str + " "} : {pcIsSpace: da(t), str: e.str + t}), {
                                pcIsSpace: !1,
                                str: ""
                            });
                        return s.str
                    }, ua = (e, t) => tr(e) && ia(e.data) && !((e, t) => {
                        const n = yn.fromDom(t), o = yn.fromDom(e);
                        return jo(o, "pre,code", L(_n, n))
                    })(e, t),
                    ma = (e, t) => oa(e) && !ua(e, t) || (e => Vo(e) && "A" === e.nodeName && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")))(e) || fa(e),
                    fa = Xo("data-mce-bookmark"), ga = Xo("data-mce-bogus"),
                    pa = (ha = "data-mce-bogus", va = "all", e => Vo(e) && e.getAttribute(ha) === va);
                var ha, va;
                const ba = e => Tn(yn.fromDom(e)).exists((e => !oo(e))), ya = (e, t = !0) => ((e, t) => {
                        let n = 0;
                        if (ma(e, e)) return !1;
                        {
                            let o = e.firstChild;
                            if (!o) return !0;
                            const r = new Ho(o, e);
                            do {
                                if (t) {
                                    if (pa(o)) {
                                        o = r.next(!0);
                                        continue
                                    }
                                    if (ga(o)) {
                                        o = r.next();
                                        continue
                                    }
                                }
                                if (dr(o) && ba(o)) return !1;
                                if (ir(o)) n++, o = r.next(); else {
                                    if (ma(o, e)) return !1;
                                    o = r.next()
                                }
                            } while (o);
                            return n <= 1
                        }
                    })(e.dom, t), Ca = e => "svg" === e.toLowerCase(), Ea = e => Ca(e.nodeName),
                    wa = e => "svg" === (null == e ? void 0 : e.nodeName) ? "svg" : "html", _a = ["svg"],
                    Sa = "data-mce-block",
                    ka = e => W((e => X(ge(e), (e => !/[A-Z]/.test(e))))(e), (e => `${e}:` + W(_a, (t => `not(${t} ${e})`)).join(":"))).join(","),
                    xa = (e, t) => w(t.querySelector(e)) ? (t.setAttribute(Sa, "true"), "inline-boundary" === t.getAttribute("data-mce-selected") && t.removeAttribute("data-mce-selected"), !0) : (t.removeAttribute(Sa), !1),
                    Aa = (e, t) => {
                        const n = ka(e.getTransparentElements()), o = ka(e.getBlockElements());
                        return X(t.querySelectorAll(n), (e => xa(o, e)))
                    }, Na = (e, t) => {
                        var n;
                        const o = t ? "lastChild" : "firstChild";
                        for (let t = e[o]; t; t = t[o]) if (ya(yn.fromDom(t))) return void (null === (n = t.parentNode) || void 0 === n || n.removeChild(t))
                    }, Ta = (e, t, n) => {
                        const o = e.getBlockElements(), r = yn.fromDom(t), a = e => $t(e) in o, s = e => _n(e, r);
                        K(So(n), (t => {
                            Xn(t, a, s).each((n => {
                                const o = ((e, t) => X(Pn(e), t))(t, (t => a(t) && !e.isValidChild($t(n), $t(t))));
                                if (o.length > 0) {
                                    const t = Tn(n);
                                    K(o, (e => {
                                        Xn(e, a, s).each((t => {
                                            ((e, t) => {
                                                const n = document.createRange(), o = e.parentNode;
                                                if (o) {
                                                    n.setStartBefore(e), n.setEndBefore(t);
                                                    const r = n.extractContents();
                                                    Na(r, !0), n.setStartAfter(t), n.setEndAfter(e);
                                                    const a = n.extractContents();
                                                    Na(a, !1), ya(yn.fromDom(r)) || o.insertBefore(r, e), ya(yn.fromDom(t)) || o.insertBefore(t, e), ya(yn.fromDom(a)) || o.insertBefore(a, e), o.removeChild(e)
                                                }
                                            })(t.dom, e.dom)
                                        }))
                                    })), t.each((t => Aa(e, t.dom)))
                                }
                            }))
                        }))
                    }, Ra = (e, t) => {
                        const n = Aa(e, t);
                        Ta(e, t, n), ((e, t, n) => {
                            K([...n, ...Pa(e, t) ? [t] : []], (t => K(qo(yn.fromDom(t), t.nodeName.toLowerCase()), (t => {
                                Ia(e, t.dom) && _o(t)
                            }))))
                        })(e, t, n)
                    }, Da = (e, t) => {
                        if (Ba(e, t)) {
                            const n = ka(e.getBlockElements());
                            xa(n, t)
                        }
                    }, La = e => e.hasAttribute(Sa), Oa = (e, t) => ke(e.getTransparentElements(), t),
                    Ba = (e, t) => Vo(t) && Oa(e, t.nodeName), Pa = (e, t) => Ba(e, t) && La(t),
                    Ia = (e, t) => Ba(e, t) && !La(t), Ma = (e, t) => 1 === t.type && Oa(e, t.name) && g(t.attr(Sa)),
                    Fa = _t().browser, Ua = e => ee(e, Yt), qa = (e, t) => e.children && $(e.children, t),
                    ja = (e, t, n) => {
                        let o = 0, r = 0;
                        const a = e.ownerDocument;
                        if (n = n || e, t) {
                            if (n === e && t.getBoundingClientRect && "static" === co(yn.fromDom(e), "position")) {
                                const n = t.getBoundingClientRect();
                                return o = n.left + (a.documentElement.scrollLeft || e.scrollLeft) - a.documentElement.clientLeft, r = n.top + (a.documentElement.scrollTop || e.scrollTop) - a.documentElement.clientTop, {
                                    x: o,
                                    y: r
                                }
                            }
                            let s = t;
                            for (; s && s !== n && s.nodeType && !qa(s, n);) {
                                const e = s;
                                o += e.offsetLeft || 0, r += e.offsetTop || 0, s = e.offsetParent
                            }
                            for (s = t.parentNode; s && s !== n && s.nodeType && !qa(s, n);) o -= s.scrollLeft || 0, r -= s.scrollTop || 0, s = s.parentNode;
                            r += (e => Fa.isFirefox() && "table" === $t(e) ? Ua(Pn(e)).filter((e => "caption" === $t(e))).bind((e => Ua(Bn(e)).map((t => {
                                const n = t.dom.offsetTop, o = e.dom.offsetTop, r = e.dom.offsetHeight;
                                return n <= o ? -r : 0
                            })))).getOr(0) : 0)(yn.fromDom(t))
                        }
                        return {x: o, y: r}
                    }, Ha = (e, t = {}) => {
                        let n = 0;
                        const o = {}, r = yn.fromDom(e), a = xn(r), s = e => {
                                bo($n(r), e)
                            }, i = e => {
                                const t = $n(r);
                                to(t, "#" + e).each(wo)
                            }, l = e => Se(o, e).getOrThunk((() => ({id: "mce-u" + n++, passed: [], failed: [], count: 0}))),
                            d = e => new Promise(((n, r) => {
                                let i;
                                const d = Bt._addCacheSuffix(e), c = l(d);
                                o[d] = c, c.count++;
                                const u = (e, t) => {
                                    K(e, I), c.status = t, c.passed = [], c.failed = [], i && (i.onload = null, i.onerror = null, i = null)
                                }, m = () => u(c.passed, 2), f = () => u(c.failed, 3);
                                if (n && c.passed.push(n), r && c.failed.push(r), 1 === c.status) return;
                                if (2 === c.status) return void m();
                                if (3 === c.status) return void f();
                                c.status = 1;
                                const g = yn.fromTag("link", a.dom);
                                tn(g, {
                                    rel: "stylesheet",
                                    type: "text/css",
                                    id: c.id
                                }), t.contentCssCors && en(g, "crossOrigin", "anonymous"), t.referrerPolicy && en(g, "referrerpolicy", t.referrerPolicy), i = g.dom, i.onload = m, i.onerror = f, s(g), en(g, "href", d)
                            })), c = e => {
                                const t = Bt._addCacheSuffix(e);
                                Se(o, t).each((e => {
                                    0 === --e.count && (delete o[t], i(e.id))
                                }))
                            };
                        return {
                            load: d, loadRawCss: (e, t) => {
                                const n = l(e);
                                o[e] = n, n.count++;
                                const r = yn.fromTag("style", a.dom);
                                tn(r, {rel: "stylesheet", type: "text/css", id: n.id}), r.dom.innerHTML = t, s(r)
                            }, loadAll: e => Promise.allSettled(W(e, (e => d(e).then(T(e))))).then((e => {
                                const t = G(e, (e => "fulfilled" === e.status));
                                return t.fail.length > 0 ? Promise.reject(W(t.fail, (e => e.reason))) : W(t.pass, (e => e.value))
                            })), unload: c, unloadRawCss: e => {
                                Se(o, e).each((t => {
                                    0 === --t.count && (delete o[e], i(t.id))
                                }))
                            }, unloadAll: e => {
                                K(e, (e => {
                                    c(e)
                                }))
                            }, _setReferrerPolicy: e => {
                                t.referrerPolicy = e
                            }, _setContentCssCors: e => {
                                t.contentCssCors = e
                            }
                        }
                    }, za = (() => {
                        const e = new WeakMap;
                        return {
                            forElement: (t, n) => {
                                const o = zn(t).dom;
                                return U.from(e.get(o)).getOrThunk((() => {
                                    const t = Ha(o, n);
                                    return e.set(o, t), t
                                }))
                            }
                        }
                    })(), $a = (e, t, n) => w(e) && (ma(e, t) || n.isInline(e.nodeName.toLowerCase())),
                    Va = e => (e => "span" === e.nodeName.toLowerCase())(e) && "bookmark" === e.getAttribute("data-mce-type"),
                    Wa = (e, t, n) => tr(e) && e.data.length > 0 && ((e, t, n) => {
                        const o = new Ho(e, t).prev(!1), r = new Ho(e, t).next(!1), a = C(o) || $a(o, t, n),
                            s = C(r) || $a(r, t, n);
                        return a && s
                    })(e, t, n), Ka = (e, t, n, o) => {
                        var r;
                        const a = o || t;
                        if (Vo(t) && Va(t)) return t;
                        const s = t.childNodes;
                        for (let t = s.length - 1; t >= 0; t--) Ka(e, s[t], n, a);
                        if (Vo(t)) {
                            const e = t.childNodes;
                            1 === e.length && Va(e[0]) && (null === (r = t.parentNode) || void 0 === r || r.insertBefore(e[0], t))
                        }
                        return (e => sr(e) || ar(e))(t) || ma(t, a) || (e => !!Vo(e) && e.childNodes.length > 0)(t) || Wa(t, a, n) || e.remove(t), t
                    }, Ya = Bt.makeMap, Ga = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    Xa = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Ja = /[<>&\"\']/g,
                    Qa = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, Za = {
                        128: "€",
                        130: "‚",
                        131: "ƒ",
                        132: "„",
                        133: "…",
                        134: "†",
                        135: "‡",
                        136: "ˆ",
                        137: "‰",
                        138: "Š",
                        139: "‹",
                        140: "Œ",
                        142: "Ž",
                        145: "‘",
                        146: "’",
                        147: "“",
                        148: "”",
                        149: "•",
                        150: "–",
                        151: "—",
                        152: "˜",
                        153: "™",
                        154: "š",
                        155: "›",
                        156: "œ",
                        158: "ž",
                        159: "Ÿ"
                    }, es = {'"': "&quot;", "'": "&#39;", "<": "&lt;", ">": "&gt;", "&": "&amp;", "`": "&#96;"},
                    ts = {"&lt;": "<", "&gt;": ">", "&amp;": "&", "&quot;": '"', "&apos;": "'"}, ns = (e, t) => {
                        const n = {};
                        if (e) {
                            const o = e.split(",");
                            t = t || 10;
                            for (let e = 0; e < o.length; e += 2) {
                                const r = String.fromCharCode(parseInt(o[e], t));
                                if (!es[r]) {
                                    const t = "&" + o[e + 1] + ";";
                                    n[r] = t, n[t] = r
                                }
                            }
                            return n
                        }
                    },
                    os = ns("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32),
                    rs = (e, t) => e.replace(t ? Ga : Xa, (e => es[e] || e)),
                    as = (e, t) => e.replace(t ? Ga : Xa, (e => e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : es[e] || "&#" + e.charCodeAt(0) + ";")),
                    ss = (e, t, n) => {
                        const o = n || os;
                        return e.replace(t ? Ga : Xa, (e => es[e] || o[e] || e))
                    }, is = {
                        encodeRaw: rs,
                        encodeAllRaw: e => ("" + e).replace(Ja, (e => es[e] || e)),
                        encodeNumeric: as,
                        encodeNamed: ss,
                        getEncodeFunc: (e, t) => {
                            const n = ns(t) || os,
                                o = (e, t) => e.replace(t ? Ga : Xa, (e => void 0 !== es[e] ? es[e] : void 0 !== n[e] ? n[e] : e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + e.charCodeAt(0) + ";")),
                                r = (e, t) => ss(e, t, n), a = Ya(e.replace(/\+/g, ","));
                            return a.named && a.numeric ? o : a.named ? t ? r : ss : a.numeric ? as : rs
                        },
                        decode: e => e.replace(Qa, ((e, t) => t ? (t = "x" === t.charAt(0).toLowerCase() ? parseInt(t.substr(1), 16) : parseInt(t, 10)) > 65535 ? (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))) : Za[t] || String.fromCharCode(t) : ts[e] || os[e] || (e => {
                            const t = yn.fromTag("div").dom;
                            return t.innerHTML = e, t.textContent || t.innerText || e
                        })(e)))
                    }, ls = (e, t) => (e = Bt.trim(e)) ? e.split(t || " ") : [],
                    ds = e => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), cs = (e, t) => {
                        const n = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
                        return oe(ls(t, ","), (t => {
                            const o = n.exec(t);
                            if (o) {
                                const t = o[1], n = o[2], r = o[3], a = o[4], s = o[5],
                                    i = {attributes: {}, attributesOrder: []};
                                if (e.each((e => ((e, t) => {
                                    he(e.attributes, ((e, n) => {
                                        t.attributes[n] = e
                                    })), t.attributesOrder.push(...e.attributesOrder)
                                })(e, i))), "#" === t ? i.paddEmpty = !0 : "-" === t && (i.removeEmpty = !0), "!" === a && (i.removeEmptyAttrs = !0), s && ((e, t) => {
                                    const n = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/,
                                        o = /[*?+]/, {attributes: r, attributesOrder: a} = t;
                                    K(ls(e, "|"), (e => {
                                        const s = n.exec(e);
                                        if (s) {
                                            const e = {}, n = s[1], i = s[2].replace(/[\\:]:/g, ":"), l = s[3], d = s[4];
                                            if ("!" === n && (t.attributesRequired = t.attributesRequired || [], t.attributesRequired.push(i), e.required = !0), "-" === n) return delete r[i], void a.splice(Bt.inArray(a, i), 1);
                                            if (l && ("=" === l ? (t.attributesDefault = t.attributesDefault || [], t.attributesDefault.push({
                                                name: i,
                                                value: d
                                            }), e.defaultValue = d) : "~" === l ? (t.attributesForced = t.attributesForced || [], t.attributesForced.push({
                                                name: i,
                                                value: d
                                            }), e.forcedValue = d) : "<" === l && (e.validValues = Bt.makeMap(d, "?"))), o.test(i)) {
                                                const n = e;
                                                t.attributePatterns = t.attributePatterns || [], n.pattern = ds(i), t.attributePatterns.push(n)
                                            } else r[i] || a.push(i), r[i] = e
                                        }
                                    }))
                                })(s, i), r && (i.outputName = n), "@" === n) {
                                    if (!e.isNone()) return [];
                                    e = U.some(i)
                                }
                                return [r ? {name: n, element: i, aliasName: r} : {name: n, element: i}]
                            }
                            return []
                        }))
                    }, us = {}, ms = Bt.makeMap, fs = Bt.each, gs = Bt.extend, ps = Bt.explode, hs = (e, t = {}) => {
                        const n = ms(e, " ", ms(e.toUpperCase(), " "));
                        return gs(n, t)
                    }, vs = e => hs("td th li dt dd figcaption caption details summary", e.getTextBlockElements()),
                    bs = (e, t) => {
                        if (e) {
                            const n = {};
                            return g(e) && (e = {"*": e}), fs(e, ((e, o) => {
                                n[o] = n[o.toUpperCase()] = "map" === t ? ms(e, /[, ]/) : ps(e, /[, ]/)
                            })), n
                        }
                    }, ys = (e = {}) => {
                        var t;
                        const n = {}, o = {};
                        let r = [];
                        const a = {}, s = {}, i = (t, n, o) => {
                            const r = e[t];
                            if (r) return ms(r, /[, ]/, ms(r.toUpperCase(), /[, ]/));
                            {
                                let e = us[t];
                                return e || (e = hs(n, o), us[t] = e), e
                            }
                        }, l = null !== (t = e.schema) && void 0 !== t ? t : "html5", d = (e => {
                            const {globalAttributes: t, phrasingContent: n, flowContent: o} = (e => {
                                let t, n, o;
                                t = "id accesskey class dir lang style tabindex title role", n = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", o = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", "html4" !== e && (t += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", n += " article aside details dialog figure main header footer hgroup section nav a ins del canvas map", o += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen svg"), "html5-strict" !== e && (t += " xml:lang", o = [o, "acronym applet basefont big font strike tt"].join(" "), n = [n, "center dir isindex noframes"].join(" "));
                                const r = [n, o].join(" ");
                                return {globalAttributes: t, blockContent: n, phrasingContent: o, flowContent: r}
                            })(e), r = {}, a = (e, t, n) => {
                                r[e] = {attributes: ie(t, T({})), attributesOrder: t, children: ie(n, T({}))}
                            }, s = (e, n = "", o = "") => {
                                const r = ls(o), s = ls(e);
                                let i = s.length;
                                const l = ls([t, n].join(" "));
                                for (; i--;) a(s[i], l.slice(), r)
                            }, i = (e, t) => {
                                const n = ls(e), o = ls(t);
                                let a = n.length;
                                for (; a--;) {
                                    const e = r[n[a]];
                                    for (let t = 0, n = o.length; t < n; t++) e.attributes[o[t]] = {}, e.attributesOrder.push(o[t])
                                }
                            };
                            "html5-strict" !== e && (K(ls("acronym applet basefont big font strike tt"), (e => {
                                s(e, "", n)
                            })), K(ls("center dir isindex noframes"), (e => {
                                s(e, "", o)
                            })));
                            return s("html", "manifest", "head body"), s("head", "", "base command link meta noscript script style title"), s("title hr noscript br"), s("base", "href target"), s("link", "href rel media hreflang type sizes hreflang"), s("meta", "name http-equiv content charset"), s("style", "media type scoped"), s("script", "src async defer type charset"), s("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", o), s("dd div", "", o), s("address dt caption", "", "html4" === e ? n : o), s("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", n), s("blockquote", "cite", o), s("ol", "reversed start type", "li"), s("ul", "", "li"), s("li", "value", o), s("dl", "", "dt dd"), s("a", "href target rel media hreflang type", "html4" === e ? n : o), s("q", "cite", n), s("ins del", "cite datetime", o), s("img", "src sizes srcset alt usemap ismap width height"), s("iframe", "src name width height", o), s("embed", "src type width height"), s("object", "data type typemustmatch name usemap form width height", [o, "param"].join(" ")), s("param", "name value"), s("map", "name", [o, "area"].join(" ")), s("area", "alt coords shape href target rel media hreflang type"), s("table", "border", "caption colgroup thead tfoot tbody tr" + ("html4" === e ? " col" : "")), s("colgroup", "span", "col"), s("col", "span"), s("tbody thead tfoot", "", "tr"), s("tr", "", "td th"), s("td", "colspan rowspan headers", o), s("th", "colspan rowspan headers scope abbr", o), s("form", "accept-charset action autocomplete enctype method name novalidate target", o), s("fieldset", "disabled form name", [o, "legend"].join(" ")), s("label", "form for", n), s("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), s("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", "html4" === e ? o : n), s("select", "disabled form multiple name required size", "option optgroup"), s("optgroup", "disabled label", "option"), s("option", "disabled label selected value"), s("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), s("menu", "type label", [o, "li"].join(" ")), s("noscript", "", o), "html4" !== e && (s("wbr"), s("ruby", "", [n, "rt rp"].join(" ")), s("figcaption", "", o), s("mark rt rp bdi", "", n), s("summary", "", [n, "h1 h2 h3 h4 h5 h6"].join(" ")), s("canvas", "width height", o), s("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [o, "track source"].join(" ")), s("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [o, "track source"].join(" ")), s("picture", "", "img source"), s("source", "src srcset type media sizes"), s("track", "kind src srclang label default"), s("datalist", "", [n, "option"].join(" ")), s("article section nav aside main header footer", "", o), s("hgroup", "", "h1 h2 h3 h4 h5 h6"), s("figure", "", [o, "figcaption"].join(" ")), s("time", "datetime", n), s("dialog", "open", o), s("command", "type label icon disabled checked radiogroup command"), s("output", "for form name", n), s("progress", "value max", n), s("meter", "value min max low high optimum", n), s("details", "open", [o, "summary"].join(" ")), s("keygen", "autofocus challenge disabled form keytype name"), a("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), "html5-strict" !== e && (i("script", "language xml:space"), i("style", "xml:space"), i("object", "declare classid code codebase codetype archive standby align border hspace vspace"), i("embed", "align name hspace vspace"), i("param", "valuetype type"), i("a", "charset name rev shape coords"), i("br", "clear"), i("applet", "codebase archive code object alt name width height align hspace vspace"), i("img", "name longdesc align border hspace vspace"), i("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), i("font basefont", "size color face"), i("input", "usemap align"), i("select"), i("textarea"), i("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), i("ul", "type compact"), i("li", "type"), i("ol dl menu dir", "compact"), i("pre", "width xml:space"), i("hr", "align noshade size width"), i("isindex", "prompt"), i("table", "summary width frame rules cellspacing cellpadding align bgcolor"), i("col", "width align char charoff valign"), i("colgroup", "width align char charoff valign"), i("thead", "align char charoff valign"), i("tr", "align char charoff valign bgcolor"), i("th", "axis align char charoff valign nowrap bgcolor width height"), i("form", "accept"), i("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), i("tfoot", "align char charoff valign"), i("tbody", "align char charoff valign"), i("area", "nohref"), i("body", "background bgcolor text link vlink alink")), "html4" !== e && (i("input button select textarea", "autofocus"), i("input textarea", "placeholder"), i("a", "download"), i("link script img", "crossorigin"), i("img", "loading"), i("iframe", "sandbox seamless allow allowfullscreen loading")), "html4" !== e && K([r.video, r.audio], (e => {
                                delete e.children.audio, delete e.children.video
                            })), K(ls("a form meter progress dfn"), (e => {
                                r[e] && delete r[e].children[e]
                            })), delete r.caption.children.table, delete r.script, r
                        })(l);
                        !1 === e.verify_html && (e.valid_elements = "*[*]");
                        const c = bs(e.valid_styles), u = bs(e.invalid_styles, "map"), m = bs(e.valid_classes, "map"),
                            f = i("whitespace_elements", "pre script noscript style textarea video audio iframe object code"),
                            g = i("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"),
                            p = i("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"),
                            h = i("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"),
                            v = "td th iframe video audio object script code",
                            b = i("non_empty_elements", v + " pre svg", p),
                            y = i("move_caret_before_on_enter_elements", v + " table", p), C = "h1 h2 h3 h4 h5 h6",
                            E = i("text_block_elements", C + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"),
                            w = i("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing", E),
                            _ = i("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"),
                            S = i("transparent_elements", "a ins del canvas map"), k = i("wrap_block_elements", "pre " + C);
                        fs("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (e => {
                            s[e] = new RegExp("</" + e + "[^>]*>", "gi")
                        }));
                        const x = e => {
                            const t = U.from(n["@"]), o = /[*?+]/;
                            K(cs(t, null != e ? e : ""), (({name: e, element: t, aliasName: a}) => {
                                if (a && (n[a] = t), o.test(e)) {
                                    const n = t;
                                    n.pattern = ds(e), r.push(n)
                                } else n[e] = t
                            }))
                        }, A = e => {
                            r = [], K(ge(n), (e => {
                                delete n[e]
                            })), x(e)
                        }, N = e => {
                            delete us.text_block_elements, delete us.block_elements, K((e => {
                                const t = /^(~)?(.+)$/;
                                return oe(ls(e, ","), (e => {
                                    const n = t.exec(e);
                                    if (n) {
                                        const e = "~" === n[1];
                                        return [{inline: e, cloneName: e ? "span" : "div", name: n[2]}]
                                    }
                                    return []
                                }))
                            })(null != e ? e : ""), (({inline: e, name: t, cloneName: r}) => {
                                if (o[t] = o[r], a[t] = r, b[t.toUpperCase()] = {}, b[t] = {}, e || (w[t.toUpperCase()] = {}, w[t] = {}), !n[t]) {
                                    let e = n[r];
                                    e = gs({}, e), delete e.removeEmptyAttrs, delete e.removeEmpty, n[t] = e
                                }
                                he(o, ((e, n) => {
                                    e[r] && (o[n] = e = gs({}, o[n]), e[t] = e[r])
                                }))
                            }))
                        }, R = e => {
                            K((e => {
                                const t = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
                                return oe(ls(e, ","), (e => {
                                    const n = t.exec(e);
                                    if (n) {
                                        const e = n[1], t = e ? (e => "-" === e ? "remove" : "add")(e) : "replace";
                                        return [{operation: t, name: n[2], validChildren: ls(n[3], "|")}]
                                    }
                                    return []
                                }))
                            })(null != e ? e : ""), (({operation: e, name: t, validChildren: n}) => {
                                const r = "replace" === e ? {"#comment": {}} : o[t];
                                K(n, (t => {
                                    "remove" === e ? delete r[t] : r[t] = {}
                                })), o[t] = r
                            }))
                        }, D = e => {
                            const t = n[e];
                            if (t) return t;
                            let o = r.length;
                            for (; o--;) {
                                const t = r[o];
                                if (t.pattern.test(e)) return t
                            }
                        };
                        e.valid_elements ? (A(e.valid_elements), fs(d, ((e, t) => {
                            o[t] = e.children
                        }))) : (fs(d, ((e, t) => {
                            n[t] = {attributes: e.attributes, attributesOrder: e.attributesOrder}, o[t] = e.children
                        })), fs(ls("strong/b em/i"), (e => {
                            const t = ls(e, "/");
                            n[t[1]].outputName = t[0]
                        })), fs(_, ((t, o) => {
                            n[o] && (e.padd_empty_block_inline_children && (n[o].paddInEmptyBlock = !0), n[o].removeEmpty = !0)
                        })), fs(ls("ol ul blockquote a table tbody"), (e => {
                            n[e] && (n[e].removeEmpty = !0)
                        })), fs(ls("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (e => {
                            n[e] && (n[e].paddEmpty = !0)
                        })), fs(ls("span"), (e => {
                            n[e].removeEmptyAttrs = !0
                        }))), delete n.svg, N(e.custom_elements), R(e.valid_children), x(e.extended_valid_elements), R("+ol[ul|ol],+ul[ul|ol]"), fs({
                            dd: "dl",
                            dt: "dl",
                            li: "ul ol",
                            td: "tr",
                            th: "tr",
                            tr: "tbody thead tfoot",
                            tbody: "table",
                            thead: "table",
                            tfoot: "table",
                            legend: "fieldset",
                            area: "map",
                            param: "video audio object"
                        }, ((e, t) => {
                            n[t] && (n[t].parentsRequired = ls(e))
                        })), e.invalid_elements && fs(ps(e.invalid_elements), (e => {
                            n[e] && delete n[e]
                        })), D("span") || x("span[!data-mce-type|*]");
                        const L = T(c), O = T(u), B = T(m), P = T(h), I = T(w), M = T(E), F = T(_), q = T(Object.seal(p)),
                            j = T(g), H = T(b), z = T(y), $ = T(f), V = T(S), W = T(k), Y = T(Object.seal(s)),
                            G = (e, t) => {
                                const n = D(e);
                                if (n) {
                                    if (!t) return !0;
                                    {
                                        if (n.attributes[t]) return !0;
                                        const e = n.attributePatterns;
                                        if (e) {
                                            let n = e.length;
                                            for (; n--;) if (e[n].pattern.test(t)) return !0
                                        }
                                    }
                                }
                                return !1
                            }, X = e => ke(I(), e), J = e => !$e(e, "#") && G(e) && !X(e), Q = T(a);
                        return {
                            type: l,
                            children: o,
                            elements: n,
                            getValidStyles: L,
                            getValidClasses: B,
                            getBlockElements: I,
                            getInvalidStyles: O,
                            getVoidElements: q,
                            getTextBlockElements: M,
                            getTextInlineElements: F,
                            getBoolAttrs: P,
                            getElementRule: D,
                            getSelfClosingElements: j,
                            getNonEmptyElements: H,
                            getMoveCaretBeforeOnEnterElements: z,
                            getWhitespaceElements: $,
                            getTransparentElements: V,
                            getSpecialElements: Y,
                            isValidChild: (e, t) => {
                                const n = o[e.toLowerCase()];
                                return !(!n || !n[t.toLowerCase()])
                            },
                            isValid: G,
                            isBlock: X,
                            isInline: J,
                            isWrapper: e => ke(W(), e) || J(e),
                            getCustomElements: Q,
                            addValidElements: x,
                            setValidElements: A,
                            addCustomElements: N,
                            addValidChildren: R
                        }
                    }, Cs = e => He(e, "#").toUpperCase(), Es = e => {
                        const t = e.toString(16);
                        return (1 === t.length ? "0" + t : t).toUpperCase()
                    }, ws = e => (e => ({value: Cs(e)}))(Es(e.red) + Es(e.green) + Es(e.blue)),
                    _s = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i,
                    Ss = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i,
                    ks = (e, t, n, o) => ({red: e, green: t, blue: n, alpha: o}), xs = (e, t, n, o) => {
                        const r = parseInt(e, 10), a = parseInt(t, 10), s = parseInt(n, 10), i = parseFloat(o);
                        return ks(r, a, s, i)
                    }, As = e => {
                        if ("transparent" === e) return U.some(ks(0, 0, 0, 0));
                        const t = _s.exec(e);
                        if (null !== t) return U.some(xs(t[1], t[2], t[3], "1"));
                        const n = Ss.exec(e);
                        return null !== n ? U.some(xs(n[1], n[2], n[3], n[4])) : U.none()
                    }, Ns = e => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`,
                    Ts = e => As(e).map(ws).map((e => "#" + e.value)).getOr(e), Rs = (e = {}, t) => {
                        const n = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
                            o = /\s*([^:]+):\s*([^;]+);?/g, r = /\s+$/, a = {};
                        let s, i;
                        const l = vr;
                        t && (s = t.getValidStyles(), i = t.getInvalidStyles());
                        const d = "\\\" \\' \\; \\: ; : \ufeff".split(" ");
                        for (let e = 0; e < d.length; e++) a[d[e]] = l + e, a[l + e] = d[e];
                        const c = {
                            parse: t => {
                                const s = {};
                                let i = !1;
                                const d = e.url_converter, u = e.url_converter_scope || c, m = (e, t, n) => {
                                        const o = s[e + "-top" + t];
                                        if (!o) return;
                                        const r = s[e + "-right" + t];
                                        if (!r) return;
                                        const a = s[e + "-bottom" + t];
                                        if (!a) return;
                                        const i = s[e + "-left" + t];
                                        if (!i) return;
                                        const l = [o, r, a, i];
                                        let d = l.length - 1;
                                        for (; d-- && l[d] === l[d + 1];) ;
                                        d > -1 && n || (s[e + t] = -1 === d ? l[0] : l.join(" "), delete s[e + "-top" + t], delete s[e + "-right" + t], delete s[e + "-bottom" + t], delete s[e + "-left" + t])
                                    }, f = e => {
                                        const t = s[e];
                                        if (!t) return;
                                        const n = t.indexOf(",") > -1 ? [t] : t.split(" ");
                                        let o = n.length;
                                        for (; o--;) if (n[o] !== n[0]) return !1;
                                        return s[e] = n[0], !0
                                    }, p = e => (i = !0, a[e]),
                                    h = (e, t) => (i && (e = e.replace(/\uFEFF[0-9]/g, (e => a[e]))), t || (e = e.replace(/\\([\'\";:])/g, "$1")), e),
                                    v = e => String.fromCharCode(parseInt(e.slice(1), 16)),
                                    b = e => e.replace(/\\[0-9a-f]+/gi, v), y = (t, n, o, r, a, s) => {
                                        if (a = a || s) return "'" + (a = h(a)).replace(/\'/g, "\\'") + "'";
                                        if (n = h(n || o || r || ""), !e.allow_script_urls) {
                                            const t = n.replace(/[\s\r\n]+/g, "");
                                            if (/(java|vb)script:/i.test(t)) return "";
                                            if (!e.allow_svg_data_urls && /^data:image\/svg/i.test(t)) return ""
                                        }
                                        return d && (n = d.call(u, n, "style")), "url('" + n.replace(/\'/g, "\\'") + "')"
                                    };
                                if (t) {
                                    let a;
                                    for (t = (t = t.replace(/[\u0000-\u001F]/g, "")).replace(/\\[\"\';:\uFEFF]/g, p).replace(/\"[^\"]+\"|\'[^\']+\'/g, (e => e.replace(/[;:]/g, p))); a = o.exec(t);) {
                                        o.lastIndex = a.index + a[0].length;
                                        let t = a[1].replace(r, "").toLowerCase(), d = a[2].replace(r, "");
                                        if (t && d) {
                                            if (t = b(t), d = b(d), -1 !== t.indexOf(l) || -1 !== t.indexOf('"')) continue;
                                            if (!e.allow_script_urls && ("behavior" === t || /expression\s*\(|\/\*|\*\//.test(d))) continue;
                                            "font-weight" === t && "700" === d ? d = "bold" : "color" !== t && "background-color" !== t || (d = d.toLowerCase()), g(e.force_hex_color) && "off" !== e.force_hex_color && As(d).each((t => {
                                                "always" !== e.force_hex_color && 1 !== t.alpha || (d = Ts(Ns(t)))
                                            })), d = d.replace(n, y), s[t] = i ? h(d, !0) : d
                                        }
                                    }
                                    m("border", "", !0), m("border", "-width"), m("border", "-color"), m("border", "-style"), m("padding", ""), m("margin", ""), C = "border", w = "border-style", _ = "border-color", f(E = "border-width") && f(w) && f(_) && (s[C] = s[E] + " " + s[w] + " " + s[_], delete s[E], delete s[w], delete s[_]), "medium none" === s.border && delete s.border, "none" === s["border-image"] && delete s["border-image"]
                                }
                                var C, E, w, _;
                                return s
                            }, serialize: (e, t) => {
                                let n = "";
                                const o = (t, o) => {
                                    const r = o[t];
                                    if (r) for (let t = 0, o = r.length; t < o; t++) {
                                        const o = r[t], a = e[o];
                                        a && (n += (n.length > 0 ? " " : "") + o + ": " + a + ";")
                                    }
                                };
                                return t && s ? (o("*", s), o(t, s)) : he(e, ((e, o) => {
                                    e && ((e, t) => {
                                        if (!i || !t) return !0;
                                        let n = i["*"];
                                        return !(n && n[e] || (n = i[t], n && n[e]))
                                    })(o, t) && (n += (n.length > 0 ? " " : "") + o + ": " + e + ";")
                                })), n
                            }
                        };
                        return c
                    }, Ds = {
                        keyLocation: !0,
                        layerX: !0,
                        layerY: !0,
                        returnValue: !0,
                        webkitMovementX: !0,
                        webkitMovementY: !0,
                        keyIdentifier: !0,
                        mozPressure: !0
                    }, Ls = e => E(e.preventDefault) || (e => e instanceof Event || _(e.initEvent))(e), Os = (e, t) => {
                        const n = null != t ? t : {};
                        for (const t in e) ke(Ds, t) || (n[t] = e[t]);
                        return w(e.composedPath) && (n.composedPath = () => e.composedPath()), w(e.getModifierState) && (n.getModifierState = t => e.getModifierState(t)), w(e.getTargetRanges) && (n.getTargetRanges = () => e.getTargetRanges()), n
                    }, Bs = (e, t, n, o) => {
                        var r;
                        const a = Os(t, o);
                        return a.type = e, E(a.target) && (a.target = null !== (r = a.srcElement) && void 0 !== r ? r : n), Ls(t) && (a.preventDefault = () => {
                            a.defaultPrevented = !0, a.isDefaultPrevented = F, _(t.preventDefault) && t.preventDefault()
                        }, a.stopPropagation = () => {
                            a.cancelBubble = !0, a.isPropagationStopped = F, _(t.stopPropagation) && t.stopPropagation()
                        }, a.stopImmediatePropagation = () => {
                            a.isImmediatePropagationStopped = F, a.stopPropagation()
                        }, (e => e.isDefaultPrevented === F || e.isDefaultPrevented === M)(a) || (a.isDefaultPrevented = !0 === a.defaultPrevented ? F : M, a.isPropagationStopped = !0 === a.cancelBubble ? F : M, a.isImmediatePropagationStopped = M)), a
                    }, Ps = /^(?:mouse|contextmenu)|click/, Is = (e, t, n, o) => {
                        e.addEventListener(t, n, o || !1)
                    }, Ms = (e, t, n, o) => {
                        e.removeEventListener(t, n, o || !1)
                    }, Fs = (e, t) => {
                        const n = Bs(e.type, e, document, t);
                        if ((e => w(e) && Ps.test(e.type))(e) && C(e.pageX) && !C(e.clientX)) {
                            const t = n.target.ownerDocument || document, o = t.documentElement, r = t.body, a = n;
                            a.pageX = e.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), a.pageY = e.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)
                        }
                        return n
                    }, Us = (e, t, n) => {
                        const o = e.document, r = {type: "ready"};
                        if (n.domLoaded) return void t(r);
                        const a = () => {
                            Ms(e, "DOMContentLoaded", a), Ms(e, "load", a), n.domLoaded || (n.domLoaded = !0, t(r)), e = null
                        };
                        "complete" === o.readyState || "interactive" === o.readyState && o.body ? a() : Is(e, "DOMContentLoaded", a), n.domLoaded || Is(e, "load", a)
                    };

                class qs {
                    constructor() {
                        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = "mce-data-" + (+new Date).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1
                    }

                    bind(e, t, n, o) {
                        const r = this;
                        let a;
                        const s = window, i = e => {
                            r.executeHandlers(Fs(e || s.event), l)
                        };
                        if (!e || tr(e) || rr(e)) return n;
                        let l;
                        e[r.expando] ? l = e[r.expando] : (l = r.count++, e[r.expando] = l, r.events[l] = {}), o = o || e;
                        const d = t.split(" ");
                        let c = d.length;
                        for (; c--;) {
                            let t = d[c], u = i, m = !1, f = !1;
                            "DOMContentLoaded" === t && (t = "ready"), r.domLoaded && "ready" === t && "complete" === e.readyState ? n.call(o, Fs({type: t})) : (r.hasFocusIn || "focusin" !== t && "focusout" !== t || (m = !0, f = "focusin" === t ? "focus" : "blur", u = e => {
                                const t = Fs(e || s.event);
                                t.type = "focus" === t.type ? "focusin" : "focusout", r.executeHandlers(t, l)
                            }), a = r.events[l][t], a ? "ready" === t && r.domLoaded ? n(Fs({type: t})) : a.push({
                                func: n,
                                scope: o
                            }) : (r.events[l][t] = a = [{
                                func: n,
                                scope: o
                            }], a.fakeName = f, a.capture = m, a.nativeHandler = u, "ready" === t ? Us(e, u, r) : Is(e, f || t, u, m)))
                        }
                        return e = a = null, n
                    }

                    unbind(e, t, n) {
                        if (!e || tr(e) || rr(e)) return this;
                        const o = e[this.expando];
                        if (o) {
                            let r = this.events[o];
                            if (t) {
                                const o = t.split(" ");
                                let a = o.length;
                                for (; a--;) {
                                    const t = o[a], s = r[t];
                                    if (s) {
                                        if (n) {
                                            let e = s.length;
                                            for (; e--;) if (s[e].func === n) {
                                                const n = s.nativeHandler, o = s.fakeName, a = s.capture,
                                                    i = s.slice(0, e).concat(s.slice(e + 1));
                                                i.nativeHandler = n, i.fakeName = o, i.capture = a, r[t] = i
                                            }
                                        }
                                        n && 0 !== s.length || (delete r[t], Ms(e, s.fakeName || t, s.nativeHandler, s.capture))
                                    }
                                }
                            } else he(r, ((t, n) => {
                                Ms(e, t.fakeName || n, t.nativeHandler, t.capture)
                            })), r = {};
                            for (const e in r) if (ke(r, e)) return this;
                            delete this.events[o];
                            try {
                                delete e[this.expando]
                            } catch (t) {
                                e[this.expando] = null
                            }
                        }
                        return this
                    }

                    fire(e, t, n) {
                        return this.dispatch(e, t, n)
                    }

                    dispatch(e, t, n) {
                        if (!e || tr(e) || rr(e)) return this;
                        const o = Fs({type: t, target: e}, n);
                        do {
                            const t = e[this.expando];
                            t && this.executeHandlers(o, t), e = e.parentNode || e.ownerDocument || e.defaultView || e.parentWindow
                        } while (e && !o.isPropagationStopped());
                        return this
                    }

                    clean(e) {
                        if (!e || tr(e) || rr(e)) return this;
                        if (e[this.expando] && this.unbind(e), e.getElementsByTagName || (e = e.document), e && e.getElementsByTagName) {
                            this.unbind(e);
                            const t = e.getElementsByTagName("*");
                            let n = t.length;
                            for (; n--;) (e = t[n])[this.expando] && this.unbind(e)
                        }
                        return this
                    }

                    destroy() {
                        this.events = {}
                    }

                    cancel(e) {
                        return e && (e.preventDefault(), e.stopImmediatePropagation()), !1
                    }

                    executeHandlers(e, t) {
                        const n = this.events[t], o = n && n[e.type];
                        if (o) for (let t = 0, n = o.length; t < n; t++) {
                            const n = o[t];
                            if (n && !1 === n.func.call(n.scope, e) && e.preventDefault(), e.isImmediatePropagationStopped()) return
                        }
                    }
                }

                qs.Event = new qs;
                const js = Bt.each, Hs = Bt.grep, zs = "data-mce-style",
                    $s = Bt.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "),
                    Vs = (e, t, n) => {
                        E(n) || "" === n ? an(e, t) : en(e, t, n)
                    }, Ws = e => e.replace(/[A-Z]/g, (e => "-" + e.toLowerCase())), Ks = (e, t) => {
                        let n = 0;
                        if (e) for (let o = e.nodeType, r = e.previousSibling; r; r = r.previousSibling) {
                            const e = r.nodeType;
                            (!t || !tr(r) || e !== o && r.data.length) && (n++, o = e)
                        }
                        return n
                    }, Ys = (e, t) => {
                        const n = nn(t, "style"), o = e.serialize(e.parse(n), $t(t));
                        Vs(t, zs, o)
                    }, Gs = (e, t, n) => {
                        const o = Ws(t);
                        E(n) || "" === n ? go(e, o) : io(e, o, ((e, t) => S(e) ? ke($s, t) ? e + "" : e + "px" : e)(n, o))
                    }, Xs = (e, t = {}) => {
                        const n = {}, o = window, r = {};
                        let a = 0;
                        const s = za.forElement(yn.fromDom(e), {
                                contentCssCors: t.contentCssCors,
                                referrerPolicy: t.referrerPolicy
                            }), i = [], l = t.schema ? t.schema : ys({}), d = Rs({
                                url_converter: t.url_converter,
                                url_converter_scope: t.url_converter_scope,
                                force_hex_color: t.force_hex_color
                            }, t.schema), c = t.ownEvents ? new qs : qs.Event, u = l.getBlockElements(),
                            m = t => t && e && g(t) ? e.getElementById(t) : t, f = e => {
                                const t = m(e);
                                return w(t) ? yn.fromDom(t) : null
                            }, p = (e, t, n = "") => {
                                let o;
                                const r = f(e);
                                if (w(r) && Yt(r)) {
                                    const e = Y[t];
                                    o = e && e.get ? e.get(r.dom, t) : nn(r, t)
                                }
                                return w(o) ? o : n
                            }, h = e => {
                                const t = m(e);
                                return E(t) ? [] : t.attributes
                            }, b = (e, n, o) => {
                                D(e, (e => {
                                    if (Vo(e)) {
                                        const r = yn.fromDom(e), a = "" === o ? null : o, s = nn(r, n), i = Y[n];
                                        i && i.set ? i.set(r.dom, a, n) : Vs(r, n, a), s !== a && t.onSetAttrib && t.onSetAttrib({
                                            attrElm: r.dom,
                                            attrName: n,
                                            attrValue: a
                                        })
                                    }
                                }))
                            }, y = () => t.root_element || e.body, C = (t, n) => ja(e.body, m(t), n), S = (e, t, n) => {
                                const o = m(e);
                                var r;
                                if (!E(o) && (Wo(o) || Vo(r = o) && "http://www.w3.org/2000/svg" === r.namespaceURI)) return n ? co(yn.fromDom(o), Ws(t)) : ("float" === (t = t.replace(/-(\D)/g, ((e, t) => t.toUpperCase()))) && (t = "cssFloat"), o.style ? o.style[t] : void 0)
                            }, k = e => {
                                const t = m(e);
                                if (!t) return {w: 0, h: 0};
                                let n = S(t, "width"), o = S(t, "height");
                                return n && -1 !== n.indexOf("px") || (n = "0"), o && -1 !== o.indexOf("px") || (o = "0"), {
                                    w: parseInt(n, 10) || t.offsetWidth || t.clientWidth,
                                    h: parseInt(o, 10) || t.offsetHeight || t.clientHeight
                                }
                            }, A = (e, t) => {
                                if (!e) return !1;
                                const n = v(e) ? e : [e];
                                return V(n, (e => En(yn.fromDom(e), t)))
                            }, N = (e, t, n, o) => {
                                const r = [];
                                let a = m(e);
                                o = void 0 === o;
                                const s = n || ("BODY" !== y().nodeName ? y().parentNode : null);
                                if (g(t)) if ("*" === t) t = Vo; else {
                                    const e = t;
                                    t = t => A(t, e)
                                }
                                for (; a && !(a === s || E(a.nodeType) || ar(a) || sr(a));) {
                                    if (!t || t(a)) {
                                        if (!o) return [a];
                                        r.push(a)
                                    }
                                    a = a.parentNode
                                }
                                return o ? r : null
                            }, R = (e, t, n) => {
                                let o = t;
                                if (e) {
                                    g(t) && (o = e => A(e, t));
                                    for (let t = e[n]; t; t = t[n]) if (_(o) && o(t)) return t
                                }
                                return null
                            }, D = function (e, t, n) {
                                const o = null != n ? n : this;
                                if (v(e)) {
                                    const n = [];
                                    return js(e, ((e, r) => {
                                        const a = m(e);
                                        a && n.push(t.call(o, a, r))
                                    })), n
                                }
                                {
                                    const n = m(e);
                                    return !!n && t.call(o, n)
                                }
                            }, L = (e, t) => {
                                D(e, (e => {
                                    he(t, ((t, n) => {
                                        b(e, n, t)
                                    }))
                                }))
                            }, O = (e, t) => {
                                D(e, (e => {
                                    const n = yn.fromDom(e);
                                    xo(n, t)
                                }))
                            }, B = (t, n, o, r, a) => D(t, (t => {
                                const s = g(n) ? e.createElement(n) : n;
                                return w(o) && L(s, o), r && (!g(r) && r.nodeType ? s.appendChild(r) : g(r) && O(s, r)), a ? s : t.appendChild(s)
                            })), P = (t, n, o) => B(e.createElement(t), t, n, o, !0), I = is.encodeAllRaw,
                            M = (e, t) => D(e, (e => {
                                const n = yn.fromDom(e);
                                return t && K(Pn(n), (e => {
                                    Gt(e) && 0 === e.dom.length ? wo(e) : po(n, e)
                                })), wo(n), n.dom
                            })), F = (e, t, n) => {
                                D(e, (e => {
                                    if (Vo(e)) {
                                        const o = yn.fromDom(e), r = t.split(" ");
                                        K(r, (e => {
                                            if (w(n)) {
                                                (n ? fn : pn)(o, e)
                                            } else hn(o, e)
                                        }))
                                    }
                                }))
                            }, U = (e, t, n) => D(t, (o => {
                                var r;
                                const a = v(t) ? e.cloneNode(!0) : e;
                                return n && js(Hs(o.childNodes), (e => {
                                    a.appendChild(e)
                                })), null === (r = o.parentNode) || void 0 === r || r.replaceChild(a, o), o
                            })), q = e => {
                                if (Vo(e)) {
                                    const t = "a" === e.nodeName.toLowerCase() && !p(e, "href") && p(e, "id");
                                    if (p(e, "name") || p(e, "data-mce-bookmark") || t) return !0
                                }
                                return !1
                            }, j = () => e.createRange(), H = (n, r, a, s) => {
                                if (v(n)) {
                                    let e = n.length;
                                    const t = [];
                                    for (; e--;) t[e] = H(n[e], r, a, s);
                                    return t
                                }
                                return !t.collect || n !== e && n !== o || i.push([n, r, a, s]), c.bind(n, r, a, s || W)
                            }, z = (t, n, r) => {
                                if (v(t)) {
                                    let e = t.length;
                                    const o = [];
                                    for (; e--;) o[e] = z(t[e], n, r);
                                    return o
                                }
                                if (i.length > 0 && (t === e || t === o)) {
                                    let e = i.length;
                                    for (; e--;) {
                                        const [o, a, s] = i[e];
                                        t !== o || n && n !== a || r && r !== s || c.unbind(o, a, s)
                                    }
                                }
                                return c.unbind(t, n, r)
                            }, $ = e => {
                                if (e && Wo(e)) {
                                    const t = e.getAttribute("data-mce-contenteditable");
                                    return t && "inherit" !== t ? t : "inherit" !== e.contentEditable ? e.contentEditable : null
                                }
                                return null
                            }, W = {
                                doc: e,
                                settings: t,
                                win: o,
                                files: r,
                                stdMode: !0,
                                boxModel: !0,
                                styleSheetLoader: s,
                                boundEvents: i,
                                styles: d,
                                schema: l,
                                events: c,
                                isBlock: e => g(e) ? ke(u, e) : Vo(e) && (ke(u, e.nodeName) || Pa(l, e)),
                                root: null,
                                clone: (e, t) => e.cloneNode(t),
                                getRoot: y,
                                getViewPort: e => {
                                    const t = Fo(e);
                                    return {x: t.x, y: t.y, w: t.width, h: t.height}
                                },
                                getRect: e => {
                                    const t = m(e), n = C(t), o = k(t);
                                    return {x: n.x, y: n.y, w: o.w, h: o.h}
                                },
                                getSize: k,
                                getParent: (e, t, n) => {
                                    const o = N(e, t, n, !1);
                                    return o && o.length > 0 ? o[0] : null
                                },
                                getParents: N,
                                get: m,
                                getNext: (e, t) => R(e, t, "nextSibling"),
                                getPrev: (e, t) => R(e, t, "previousSibling"),
                                select: (n, o) => {
                                    var r, a;
                                    const s = null !== (a = null !== (r = m(o)) && void 0 !== r ? r : t.root_element) && void 0 !== a ? a : e;
                                    return _(s.querySelectorAll) ? me(s.querySelectorAll(n)) : []
                                },
                                is: A,
                                add: B,
                                create: P,
                                createHTML: (e, t, n = "") => {
                                    let o = "<" + e;
                                    for (const e in t) xe(t, e) && (o += " " + e + '="' + I(t[e]) + '"');
                                    return Je(n) && ke(l.getVoidElements(), e) ? o + " />" : o + ">" + n + "</" + e + ">"
                                },
                                createFragment: t => {
                                    const n = e.createElement("div"), o = e.createDocumentFragment();
                                    let r;
                                    for (o.appendChild(n), t && (n.innerHTML = t); r = n.firstChild;) o.appendChild(r);
                                    return o.removeChild(n), o
                                },
                                remove: M,
                                setStyle: (e, n, o) => {
                                    D(e, (e => {
                                        const r = yn.fromDom(e);
                                        Gs(r, n, o), t.update_styles && Ys(d, r)
                                    }))
                                },
                                getStyle: S,
                                setStyles: (e, n) => {
                                    D(e, (e => {
                                        const o = yn.fromDom(e);
                                        he(n, ((e, t) => {
                                            Gs(o, t, e)
                                        })), t.update_styles && Ys(d, o)
                                    }))
                                },
                                removeAllAttribs: e => D(e, (e => {
                                    const t = e.attributes;
                                    for (let n = t.length - 1; n >= 0; n--) e.removeAttributeNode(t.item(n))
                                })),
                                setAttrib: b,
                                setAttribs: L,
                                getAttrib: p,
                                getPos: C,
                                parseStyle: e => d.parse(e),
                                serializeStyle: (e, t) => d.serialize(e, t),
                                addStyle: t => {
                                    if (W !== Xs.DOM && e === document) {
                                        if (n[t]) return;
                                        n[t] = !0
                                    }
                                    let o = e.getElementById("mceDefaultStyles");
                                    if (!o) {
                                        o = e.createElement("style"), o.id = "mceDefaultStyles", o.type = "text/css";
                                        const t = e.head;
                                        t.firstChild ? t.insertBefore(o, t.firstChild) : t.appendChild(o)
                                    }
                                    o.styleSheet ? o.styleSheet.cssText += t : o.appendChild(e.createTextNode(t))
                                },
                                loadCSS: e => {
                                    e || (e = ""), K(e.split(","), (e => {
                                        r[e] = !0, s.load(e).catch(x)
                                    }))
                                },
                                addClass: (e, t) => {
                                    F(e, t, !0)
                                },
                                removeClass: (e, t) => {
                                    F(e, t, !1)
                                },
                                hasClass: (e, t) => {
                                    const n = f(e), o = t.split(" ");
                                    return w(n) && re(o, (e => vn(n, e)))
                                },
                                toggleClass: F,
                                show: e => {
                                    D(e, (e => go(yn.fromDom(e), "display")))
                                },
                                hide: e => {
                                    D(e, (e => io(yn.fromDom(e), "display", "none")))
                                },
                                isHidden: e => {
                                    const t = f(e);
                                    return w(t) && Pt(mo(t, "display"), "none")
                                },
                                uniqueId: e => (e || "mce_") + a++,
                                setHTML: O,
                                getOuterHTML: e => {
                                    const t = f(e);
                                    return w(t) ? Vo(t.dom) ? t.dom.outerHTML : (e => {
                                        const t = yn.fromTag("div"), n = yn.fromDom(e.dom.cloneNode(!0));
                                        return bo(t, n), ko(t)
                                    })(t) : ""
                                },
                                setOuterHTML: (e, t) => {
                                    D(e, (e => {
                                        Vo(e) && (e.outerHTML = t)
                                    }))
                                },
                                decode: is.decode,
                                encode: I,
                                insertAfter: (e, t) => {
                                    const n = m(t);
                                    return D(e, (e => {
                                        const t = null == n ? void 0 : n.parentNode, o = null == n ? void 0 : n.nextSibling;
                                        return t && (o ? t.insertBefore(e, o) : t.appendChild(e)), e
                                    }))
                                },
                                replace: U,
                                rename: (e, t) => {
                                    if (e.nodeName !== t.toUpperCase()) {
                                        const n = P(t);
                                        return js(h(e), (t => {
                                            b(n, t.nodeName, p(e, t.nodeName))
                                        })), U(n, e, !0), n
                                    }
                                    return e
                                },
                                findCommonAncestor: (e, t) => {
                                    let n = e;
                                    for (; n;) {
                                        let e = t;
                                        for (; e && n !== e;) e = e.parentNode;
                                        if (n === e) break;
                                        n = n.parentNode
                                    }
                                    return !n && e.ownerDocument ? e.ownerDocument.documentElement : n
                                },
                                run: D,
                                getAttribs: h,
                                isEmpty: (e, t, n) => {
                                    let o = 0;
                                    if (q(e)) return !1;
                                    const r = e.firstChild;
                                    if (r) {
                                        const a = new Ho(r, e), s = l ? l.getWhitespaceElements() : {},
                                            i = t || (l ? l.getNonEmptyElements() : null);
                                        let d = r;
                                        do {
                                            if (Vo(d)) {
                                                const e = d.getAttribute("data-mce-bogus");
                                                if (e) {
                                                    d = a.next("all" === e);
                                                    continue
                                                }
                                                const t = d.nodeName.toLowerCase();
                                                if (i && i[t]) {
                                                    if ("br" === t) {
                                                        o++, d = a.next();
                                                        continue
                                                    }
                                                    return !1
                                                }
                                                if (q(d)) return !1
                                            }
                                            if (rr(d)) return !1;
                                            if (tr(d) && !ia(d.data) && (!(null == n ? void 0 : n.includeZwsp) || !la(d.data))) return !1;
                                            if (tr(d) && d.parentNode && s[d.parentNode.nodeName] && ia(d.data)) return !1;
                                            d = a.next()
                                        } while (d)
                                    }
                                    return o <= 1
                                },
                                createRng: j,
                                nodeIndex: Ks,
                                split: (e, t, n) => {
                                    let o, r, a = j();
                                    if (e && t && e.parentNode && t.parentNode) {
                                        const s = e.parentNode;
                                        return a.setStart(s, Ks(e)), a.setEnd(t.parentNode, Ks(t)), o = a.extractContents(), a = j(), a.setStart(t.parentNode, Ks(t) + 1), a.setEnd(s, Ks(e) + 1), r = a.extractContents(), s.insertBefore(Ka(W, o, l), e), n ? s.insertBefore(n, e) : s.insertBefore(t, e), s.insertBefore(Ka(W, r, l), e), M(e), n || t
                                    }
                                },
                                bind: H,
                                unbind: z,
                                fire: (e, t, n) => c.dispatch(e, t, n),
                                dispatch: (e, t, n) => c.dispatch(e, t, n),
                                getContentEditable: $,
                                getContentEditableParent: e => {
                                    const t = y();
                                    let n = null;
                                    for (let o = e; o && o !== t && (n = $(o), null === n); o = o.parentNode) ;
                                    return n
                                },
                                isEditable: e => {
                                    if (w(e)) {
                                        const t = Vo(e) ? e : e.parentElement;
                                        return w(t) && Wo(t) && oo(yn.fromDom(t))
                                    }
                                    return !1
                                },
                                destroy: () => {
                                    if (i.length > 0) {
                                        let e = i.length;
                                        for (; e--;) {
                                            const [t, n, o] = i[e];
                                            c.unbind(t, n, o)
                                        }
                                    }
                                    he(r, ((e, t) => {
                                        s.unload(t), delete r[t]
                                    }))
                                },
                                isChildOf: (e, t) => e === t || t.contains(e),
                                dumpRng: e => "startContainer: " + e.startContainer.nodeName + ", startOffset: " + e.startOffset + ", endContainer: " + e.endContainer.nodeName + ", endOffset: " + e.endOffset
                            }, Y = ((e, t, n) => {
                                const o = t.keep_values, r = {
                                    set: (e, o, r) => {
                                        const a = yn.fromDom(e);
                                        _(t.url_converter) && w(o) && (o = t.url_converter.call(t.url_converter_scope || n(), String(o), r, e)), Vs(a, "data-mce-" + r, o), Vs(a, r, o)
                                    }, get: (e, t) => {
                                        const n = yn.fromDom(e);
                                        return nn(n, "data-mce-" + t) || nn(n, t)
                                    }
                                }, a = {
                                    style: {
                                        set: (t, n) => {
                                            const r = yn.fromDom(t);
                                            o && Vs(r, zs, n), an(r, "style"), g(n) && lo(r, e.parse(n))
                                        }, get: t => {
                                            const n = yn.fromDom(t), o = nn(n, zs) || nn(n, "style");
                                            return e.serialize(e.parse(o), $t(n))
                                        }
                                    }
                                };
                                return o && (a.href = a.src = r), a
                            })(d, t, T(W));
                        return W
                    };
                Xs.DOM = Xs(document), Xs.nodeIndex = Ks;
                const Js = Xs.DOM;

                class Qs {
                    constructor(e = {}) {
                        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = e
                    }

                    _setReferrerPolicy(e) {
                        this.settings.referrerPolicy = e
                    }

                    loadScript(e) {
                        return new Promise(((t, n) => {
                            const o = Js;
                            let r;
                            const a = () => {
                                o.remove(s), r && (r.onerror = r.onload = r = null)
                            }, s = o.uniqueId();
                            r = document.createElement("script"), r.id = s, r.type = "text/javascript", r.src = Bt._addCacheSuffix(e), this.settings.referrerPolicy && o.setAttrib(r, "referrerpolicy", this.settings.referrerPolicy), r.onload = () => {
                                a(), t()
                            }, r.onerror = () => {
                                a(), n("Failed to load script: " + e)
                            }, (document.getElementsByTagName("head")[0] || document.body).appendChild(r)
                        }))
                    }

                    isDone(e) {
                        return 2 === this.states[e]
                    }

                    markDone(e) {
                        this.states[e] = 2
                    }

                    add(e) {
                        const t = this;
                        t.queue.push(e);
                        return void 0 === t.states[e] && (t.states[e] = 0), new Promise(((n, o) => {
                            t.scriptLoadedCallbacks[e] || (t.scriptLoadedCallbacks[e] = []), t.scriptLoadedCallbacks[e].push({
                                resolve: n,
                                reject: o
                            })
                        }))
                    }

                    load(e) {
                        return this.add(e)
                    }

                    remove(e) {
                        delete this.states[e], delete this.scriptLoadedCallbacks[e]
                    }

                    loadQueue() {
                        const e = this.queue;
                        return this.queue = [], this.loadScripts(e)
                    }

                    loadScripts(e) {
                        const t = this, n = (e, n) => {
                                Se(t.scriptLoadedCallbacks, n).each((t => {
                                    K(t, (t => t[e](n)))
                                })), delete t.scriptLoadedCallbacks[n]
                            }, o = e => {
                                const t = X(e, (e => "rejected" === e.status));
                                return t.length > 0 ? Promise.reject(oe(t, (({reason: e}) => v(e) ? e : [e]))) : Promise.resolve()
                            },
                            r = e => Promise.allSettled(W(e, (e => 2 === t.states[e] ? (n("resolve", e), Promise.resolve()) : 3 === t.states[e] ? (n("reject", e), Promise.reject(e)) : (t.states[e] = 1, t.loadScript(e).then((() => {
                                t.states[e] = 2, n("resolve", e);
                                const a = t.queue;
                                return a.length > 0 ? (t.queue = [], r(a).then(o)) : Promise.resolve()
                            }), (() => (t.states[e] = 3, n("reject", e), Promise.reject(e)))))))),
                            a = e => (t.loading = !0, r(e).then((e => {
                                t.loading = !1;
                                const n = t.queueLoadedCallbacks.shift();
                                return U.from(n).each(I), o(e)
                            }))), s = Ae(e);
                        return t.loading ? new Promise(((e, n) => {
                            t.queueLoadedCallbacks.push((() => {
                                a(s).then(e, n)
                            }))
                        })) : a(s)
                    }
                }

                Qs.ScriptLoader = new Qs;
                const Zs = e => {
                    let t = e;
                    return {
                        get: () => t, set: e => {
                            t = e
                        }
                    }
                }, ei = {}, ti = Zs("en"), ni = () => Se(ei, ti.get()), oi = {
                    getData: () => ve(ei, (e => ({...e}))),
                    setCode: e => {
                        e && ti.set(e)
                    },
                    getCode: () => ti.get(),
                    add: (e, t) => {
                        let n = ei[e];
                        n || (ei[e] = n = {});
                        const o = W(ge(t), (e => e.toLowerCase()));
                        he(t, ((e, r) => {
                            const a = r.toLowerCase();
                            a !== r && ((e, t) => {
                                const n = e.indexOf(t);
                                return -1 !== n && e.indexOf(t, n + 1) > n
                            })(o, a) ? (ke(t, a) || (n[a] = e), n[r] = e) : n[a] = e
                        }))
                    },
                    translate: e => {
                        const t = ni().getOr({}),
                            n = e => _(e) ? Object.prototype.toString.call(e) : o(e) ? "" : "" + e,
                            o = e => "" === e || null == e, r = e => {
                                const o = n(e);
                                return ke(t, o) ? n(t[o]) : Se(t, o.toLowerCase()).map(n).getOr(o)
                            }, a = e => e.replace(/{context:\w+}$/, "");
                        if (o(e)) return "";
                        if (p(s = e) && ke(s, "raw")) return n(e.raw);
                        var s;
                        if ((e => v(e) && e.length > 1)(e)) {
                            const t = e.slice(1);
                            return a(r(e[0]).replace(/\{([0-9]+)\}/g, ((e, o) => ke(t, o) ? n(t[o]) : e)))
                        }
                        return a(r(e))
                    },
                    isRtl: () => ni().bind((e => Se(e, "_dir"))).exists((e => "rtl" === e)),
                    hasCode: e => ke(ei, e)
                }, ri = () => {
                    const e = [], t = {}, n = {}, o = [], r = (e, t) => {
                            const n = X(o, (n => n.name === e && n.state === t));
                            K(n, (e => e.resolve()))
                        }, a = e => ke(t, e), s = (e, n) => {
                            const o = oi.getCode();
                            !o || n && -1 === ("," + (n || "") + ",").indexOf("," + o + ",") || Qs.ScriptLoader.add(t[e] + "/langs/" + o + ".js")
                        },
                        i = (e, t = "added") => "added" === t && (e => ke(n, e))(e) || "loaded" === t && a(e) ? Promise.resolve() : new Promise((n => {
                            o.push({name: e, state: t, resolve: n})
                        }));
                    return {
                        items: e,
                        urls: t,
                        lookup: n,
                        get: e => {
                            if (n[e]) return n[e].instance
                        },
                        requireLangPack: (e, t) => {
                            !1 !== ri.languageLoad && (a(e) ? s(e, t) : i(e, "loaded").then((() => s(e, t))))
                        },
                        add: (t, o) => (e.push(o), n[t] = {instance: o}, r(t, "added"), o),
                        remove: e => {
                            delete t[e], delete n[e]
                        },
                        createUrl: (e, t) => g(t) ? g(e) ? {prefix: "", resource: t, suffix: ""} : {
                            prefix: e.prefix,
                            resource: t,
                            suffix: e.suffix
                        } : t,
                        load: (e, o) => {
                            if (t[e]) return Promise.resolve();
                            let a = g(o) ? o : o.prefix + o.resource + o.suffix;
                            0 !== a.indexOf("/") && -1 === a.indexOf("://") && (a = ri.baseURL + "/" + a), t[e] = a.substring(0, a.lastIndexOf("/"));
                            const s = () => (r(e, "loaded"), Promise.resolve());
                            return n[e] ? s() : Qs.ScriptLoader.add(a).then(s)
                        },
                        waitFor: i
                    }
                };
                ri.languageLoad = !0, ri.baseURL = "", ri.PluginManager = ri(), ri.ThemeManager = ri(), ri.ModelManager = ri();
                const ai = e => {
                        const t = Zs(U.none()), n = () => t.get().each((e => clearInterval(e)));
                        return {
                            clear: () => {
                                n(), t.set(U.none())
                            }, isSet: () => t.get().isSome(), get: () => t.get(), set: o => {
                                n(), t.set(U.some(setInterval(o, e)))
                            }
                        }
                    }, si = () => {
                        const e = (e => {
                            const t = Zs(U.none()), n = () => t.get().each(e);
                            return {
                                clear: () => {
                                    n(), t.set(U.none())
                                }, isSet: () => t.get().isSome(), get: () => t.get(), set: e => {
                                    n(), t.set(U.some(e))
                                }
                            }
                        })(x);
                        return {...e, on: t => e.get().each(t)}
                    }, ii = (e, t) => {
                        let n = null;
                        return {
                            cancel: () => {
                                b(n) || (clearTimeout(n), n = null)
                            }, throttle: (...o) => {
                                b(n) && (n = setTimeout((() => {
                                    n = null, e.apply(null, o)
                                }), t))
                            }
                        }
                    }, li = (e, t) => {
                        let n = null;
                        const o = () => {
                            b(n) || (clearTimeout(n), n = null)
                        };
                        return {
                            cancel: o, throttle: (...r) => {
                                o(), n = setTimeout((() => {
                                    n = null, e.apply(null, r)
                                }), t)
                            }
                        }
                    }, di = T("mce-annotation"), ci = T("data-mce-annotation"), ui = T("data-mce-annotation-uid"),
                    mi = T("data-mce-annotation-active"), fi = T("data-mce-annotation-classes"),
                    gi = T("data-mce-annotation-attrs"), pi = e => t => _n(t, e), hi = (e, t) => {
                        const n = e.selection.getRng(), o = yn.fromDom(n.startContainer), r = yn.fromDom(e.getBody()),
                            a = t.fold((() => "." + di()), (e => `[${ci()}="${e}"]`)), s = In(o, n.startOffset).getOr(o);
                        return no(s, a, pi(r)).bind((t => on(t, `${ui()}`).bind((n => on(t, `${ci()}`).map((t => {
                            const o = bi(e, n);
                            return {uid: n, name: t, elements: o}
                        }))))))
                    }, vi = (e, t) => rn(e, "data-mce-bogus") || jo(e, '[data-mce-bogus="all"]', pi(t)), bi = (e, t) => {
                        const n = yn.fromDom(e.getBody()), o = qo(n, `[${ui()}="${t}"]`);
                        return X(o, (e => !vi(e, n)))
                    }, yi = (e, t) => {
                        const n = yn.fromDom(e.getBody()), o = qo(n, `[${ci()}="${t}"]`), r = {};
                        return K(o, (e => {
                            if (!vi(e, n)) {
                                const t = nn(e, ui()), n = Se(r, t).getOr([]);
                                r[t] = n.concat([e])
                            }
                        })), r
                    }, Ci = (e, t) => {
                        const n = Zs({}), o = () => ({listeners: [], previous: si()}), r = (e, t) => {
                            a(e, (e => (t(e), e)))
                        }, a = (e, t) => {
                            const r = n.get(), a = t(Se(r, e).getOrThunk(o));
                            r[e] = a, n.set(r)
                        }, s = (t, n) => {
                            K(bi(e, t), (e => {
                                n ? en(e, mi(), "true") : an(e, mi())
                            }))
                        }, i = li((() => {
                            const n = le(t.getNames());
                            K(n, (t => {
                                a(t, (n => {
                                    const o = n.previous.get();
                                    return hi(e, U.some(t)).fold((() => {
                                        o.each((e => {
                                            (e => {
                                                r(e, (t => {
                                                    K(t.listeners, (t => t(!1, e)))
                                                }))
                                            })(t), n.previous.clear(), s(e, !1)
                                        }))
                                    }), (({uid: e, name: t, elements: a}) => {
                                        Pt(o, e) || (o.each((e => s(e, !1))), ((e, t, n) => {
                                            r(e, (o => {
                                                K(o.listeners, (o => o(!0, e, {uid: t, nodes: W(n, (e => e.dom))})))
                                            }))
                                        })(t, e, a), n.previous.set(e), s(e, !0))
                                    })), {previous: n.previous, listeners: n.listeners}
                                }))
                            }))
                        }), 30);
                        e.on("remove", (() => {
                            i.cancel()
                        })), e.on("NodeChange", (() => {
                            i.throttle()
                        }));
                        return {
                            addListener: (e, t) => {
                                a(e, (e => ({previous: e.previous, listeners: e.listeners.concat([t])})))
                            }
                        }
                    };
                let Ei = 0;
                const wi = e => {
                        const t = (new Date).getTime(), n = Math.floor(1e9 * Math.random());
                        return Ei++, e + "_" + n + Ei + String(t)
                    }, _i = (e, t) => yn.fromDom(e.dom.cloneNode(t)), Si = e => _i(e, !1), ki = e => _i(e, !0),
                    xi = (e, t) => {
                        const n = ((e, t) => {
                            const n = yn.fromTag(t), o = sn(e);
                            return tn(n, o), n
                        })(e, t);
                        ho(e, n);
                        const o = Pn(e);
                        return Co(n, o), wo(e), n
                    }, Ai = (e, t, n = M) => {
                        const o = new Ho(e, t), r = e => {
                            let t;
                            do {
                                t = o[e]()
                            } while (t && !tr(t) && !n(t));
                            return U.from(t).filter(tr)
                        };
                        return {
                            current: () => U.from(o.current()).filter(tr),
                            next: () => r("next"),
                            prev: () => r("prev"),
                            prev2: () => r("prev2")
                        }
                    }, Ni = (e, t) => {
                        const n = t || (t => e.isBlock(t) || ir(t) || cr(t)), o = (e, t, n, r) => {
                            if (tr(e)) {
                                const n = r(e, t, e.data);
                                if (-1 !== n) return U.some({container: e, offset: n})
                            }
                            return n().bind((e => o(e.container, e.offset, n, r)))
                        };
                        return {
                            backwards: (t, r, a, s) => {
                                const i = Ai(t, null != s ? s : e.getRoot(), n);
                                return o(t, r, (() => i.prev().map((e => ({
                                    container: e,
                                    offset: e.length
                                })))), a).getOrNull()
                            }, forwards: (t, r, a, s) => {
                                const i = Ai(t, null != s ? s : e.getRoot(), n);
                                return o(t, r, (() => i.next().map((e => ({container: e, offset: 0})))), a).getOrNull()
                            }
                        }
                    }, Ti = Math.round, Ri = e => e ? {
                        left: Ti(e.left),
                        top: Ti(e.top),
                        bottom: Ti(e.bottom),
                        right: Ti(e.right),
                        width: Ti(e.width),
                        height: Ti(e.height)
                    } : {left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0},
                    Di = (e, t) => (e = Ri(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e),
                    Li = (e, t, n) => e >= 0 && e <= Math.min(t.height, n.height) / 2, Oi = (e, t) => {
                        const n = Math.min(t.height / 2, e.height / 2);
                        return e.bottom - n < t.top || !(e.top > t.bottom) && Li(t.top - e.bottom, e, t)
                    }, Bi = (e, t) => e.top > t.bottom || !(e.bottom < t.top) && Li(t.bottom - e.top, e, t),
                    Pi = (e, t, n) => {
                        const o = Math.max(Math.min(t, e.left + e.width), e.left),
                            r = Math.max(Math.min(n, e.top + e.height), e.top);
                        return Math.sqrt((t - o) * (t - o) + (n - r) * (n - r))
                    }, Ii = e => {
                        const t = e.startContainer, n = e.startOffset;
                        return t === e.endContainer && t.hasChildNodes() && e.endOffset === n + 1 ? t.childNodes[n] : null
                    }, Mi = (e, t) => {
                        if (Vo(e) && e.hasChildNodes()) {
                            const n = e.childNodes, o = ((e, t, n) => Math.min(Math.max(e, t), n))(t, 0, n.length - 1);
                            return n[o]
                        }
                        return e
                    },
                    Fi = new RegExp("[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]"),
                    Ui = e => g(e) && e.charCodeAt(0) >= 768 && Fi.test(e), qi = Vo, ji = oa,
                    Hi = Go("display", "block table"), zi = Go("float", "left right"), $i = ((...e) => t => {
                        for (let n = 0; n < e.length; n++) if (!e[n](t)) return !1;
                        return !0
                    })(qi, ji, O(zi)), Vi = O(Go("white-space", "pre pre-line pre-wrap")), Wi = tr, Ki = ir,
                    Yi = Xs.nodeIndex, Gi = (e, t) => t < 0 && Vo(e) && e.hasChildNodes() ? void 0 : Mi(e, t),
                    Xi = e => e ? e.createRange() : Xs.DOM.createRng(), Ji = e => g(e) && /[\r\n\t ]/.test(e),
                    Qi = e => !!e.setStart && !!e.setEnd, Zi = e => {
                        const t = e.startContainer, n = e.startOffset;
                        if (Ji(e.toString()) && Vi(t.parentNode) && tr(t)) {
                            const e = t.data;
                            if (Ji(e[n - 1]) || Ji(e[n + 1])) return !0
                        }
                        return !1
                    }, el = e => 0 === e.left && 0 === e.right && 0 === e.top && 0 === e.bottom, tl = e => {
                        var t;
                        let n;
                        const o = e.getClientRects();
                        return n = o.length > 0 ? Ri(o[0]) : Ri(e.getBoundingClientRect()), !Qi(e) && Ki(e) && el(n) ? (e => {
                            const t = e.ownerDocument, n = Xi(t), o = t.createTextNode(br), r = e.parentNode;
                            r.insertBefore(o, e), n.setStart(o, 0), n.setEnd(o, 1);
                            const a = Ri(n.getBoundingClientRect());
                            return r.removeChild(o), a
                        })(e) : el(n) && Qi(e) && null !== (t = (e => {
                            const t = e.startContainer, n = e.endContainer, o = e.startOffset, r = e.endOffset;
                            if (t === n && tr(n) && 0 === o && 1 === r) {
                                const t = e.cloneRange();
                                return t.setEndAfter(n), tl(t)
                            }
                            return null
                        })(e)) && void 0 !== t ? t : n
                    }, nl = (e, t) => {
                        const n = Di(e, t);
                        return n.width = 1, n.right = n.left + 1, n
                    }, ol = e => {
                        const t = [], n = e => {
                            var n, o;
                            0 !== e.height && (t.length > 0 && (n = e, o = t[t.length - 1], n.left === o.left && n.top === o.top && n.bottom === o.bottom && n.right === o.right) || t.push(e))
                        }, o = (e, t) => {
                            const o = Xi(e.ownerDocument);
                            if (t < e.data.length) {
                                if (Ui(e.data[t])) return;
                                if (Ui(e.data[t - 1]) && (o.setStart(e, t), o.setEnd(e, t + 1), !Zi(o))) return void n(nl(tl(o), !1))
                            }
                            t > 0 && (o.setStart(e, t - 1), o.setEnd(e, t), Zi(o) || n(nl(tl(o), !1))), t < e.data.length && (o.setStart(e, t), o.setEnd(e, t + 1), Zi(o) || n(nl(tl(o), !0)))
                        }, r = e.container(), a = e.offset();
                        if (Wi(r)) return o(r, a), t;
                        if (qi(r)) if (e.isAtEnd()) {
                            const e = Gi(r, a);
                            Wi(e) && o(e, e.data.length), $i(e) && !Ki(e) && n(nl(tl(e), !1))
                        } else {
                            const s = Gi(r, a);
                            if (Wi(s) && o(s, 0), $i(s) && e.isAtEnd()) return n(nl(tl(s), !1)), t;
                            const i = Gi(e.container(), e.offset() - 1);
                            $i(i) && !Ki(i) && (Hi(i) || Hi(s) || !$i(s)) && n(nl(tl(i), !1)), $i(s) && n(nl(tl(s), !0))
                        }
                        return t
                    }, rl = (e, t, n) => {
                        const o = () => (n || (n = ol(rl(e, t))), n);
                        return {
                            container: T(e),
                            offset: T(t),
                            toRange: () => {
                                const n = Xi(e.ownerDocument);
                                return n.setStart(e, t), n.setEnd(e, t), n
                            },
                            getClientRects: o,
                            isVisible: () => o().length > 0,
                            isAtStart: () => (Wi(e), 0 === t),
                            isAtEnd: () => Wi(e) ? t >= e.data.length : t >= e.childNodes.length,
                            isEqual: n => n && e === n.container() && t === n.offset(),
                            getNode: n => Gi(e, n ? t - 1 : t)
                        }
                    };
                rl.fromRangeStart = e => rl(e.startContainer, e.startOffset), rl.fromRangeEnd = e => rl(e.endContainer, e.endOffset), rl.after = e => rl(e.parentNode, Yi(e) + 1), rl.before = e => rl(e.parentNode, Yi(e)), rl.isAbove = (e, t) => Mt(ce(t.getClientRects()), ue(e.getClientRects()), Oi).getOr(!1), rl.isBelow = (e, t) => Mt(ue(t.getClientRects()), ce(e.getClientRects()), Bi).getOr(!1), rl.isAtStart = e => !!e && e.isAtStart(), rl.isAtEnd = e => !!e && e.isAtEnd(), rl.isTextPosition = e => !!e && tr(e.container()), rl.isElementPosition = e => !rl.isTextPosition(e);
                const al = (e, t) => {
                        tr(t) && 0 === t.data.length && e.remove(t)
                    }, sl = (e, t, n) => {
                        sr(n) ? ((e, t, n) => {
                            const o = U.from(n.firstChild), r = U.from(n.lastChild);
                            t.insertNode(n), o.each((t => al(e, t.previousSibling))), r.each((t => al(e, t.nextSibling)))
                        })(e, t, n) : ((e, t, n) => {
                            t.insertNode(n), al(e, n.previousSibling), al(e, n.nextSibling)
                        })(e, t, n)
                    }, il = tr, ll = Jo, dl = Xs.nodeIndex, cl = e => {
                        const t = e.parentNode;
                        return ll(t) ? cl(t) : t
                    },
                    ul = e => e ? Oe(e.childNodes, ((e, t) => (ll(t) && "BR" !== t.nodeName ? e = e.concat(ul(t)) : e.push(t), e)), []) : [],
                    ml = e => t => e === t, fl = e => (il(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + (e => {
                        let t, n;
                        t = ul(cl(e)), n = Be(t, ml(e), e), t = t.slice(0, n + 1);
                        const o = Oe(t, ((e, n, o) => (il(n) && il(t[o - 1]) && e++, e)), 0);
                        return t = Le(t, Yo([e.nodeName])), n = Be(t, ml(e), e), n - o
                    })(e) + "]", gl = (e, t) => {
                        let n, o = [], r = t.container(), a = t.offset();
                        if (il(r)) n = ((e, t) => {
                            let n = e;
                            for (; (n = n.previousSibling) && il(n);) t += n.data.length;
                            return t
                        })(r, a); else {
                            const e = r.childNodes;
                            a >= e.length ? (n = "after", a = e.length - 1) : n = "before", r = e[a]
                        }
                        o.push(fl(r));
                        let s = ((e, t, n) => {
                            const o = [];
                            for (let r = t.parentNode; r && r !== e && (!n || !n(r)); r = r.parentNode) o.push(r);
                            return o
                        })(e, r);
                        return s = Le(s, O(Jo)), o = o.concat(De(s, (e => fl(e)))), o.reverse().join("/") + "," + n
                    }, pl = (e, t) => {
                        if (!t) return null;
                        const n = t.split(","), o = n[0].split("/"), r = n.length > 1 ? n[1] : "before",
                            a = Oe(o, ((e, t) => {
                                const n = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(t);
                                return n ? ("text()" === n[1] && (n[1] = "#text"), ((e, t, n) => {
                                    let o = ul(e);
                                    return o = Le(o, ((e, t) => !il(e) || !il(o[t - 1]))), o = Le(o, Yo([t])), o[n]
                                })(e, n[1], parseInt(n[2], 10))) : null
                            }), e);
                        if (!a) return null;
                        if (!il(a) && a.parentNode) {
                            let e;
                            return e = "after" === r ? dl(a) + 1 : dl(a), rl(a.parentNode, e)
                        }
                        return ((e, t) => {
                            let n = e, o = 0;
                            for (; il(n);) {
                                const r = n.data.length;
                                if (t >= o && t <= o + r) {
                                    e = n, t -= o;
                                    break
                                }
                                if (!il(n.nextSibling)) {
                                    e = n, t = r;
                                    break
                                }
                                o += r, n = n.nextSibling
                            }
                            return il(e) && t > e.data.length && (t = e.data.length), rl(e, t)
                        })(a, parseInt(r, 10))
                    }, hl = cr, vl = (e, t, n, o, r) => {
                        const a = r ? o.startContainer : o.endContainer;
                        let s = r ? o.startOffset : o.endOffset;
                        const i = [], l = e.getRoot();
                        if (tr(a)) i.push(n ? ((e, t, n) => {
                            let o = e(t.data.slice(0, n)).length;
                            for (let n = t.previousSibling; n && tr(n); n = n.previousSibling) o += e(n.data).length;
                            return o
                        })(t, a, s) : s); else {
                            let t = 0;
                            const o = a.childNodes;
                            s >= o.length && o.length && (t = 1, s = Math.max(0, o.length - 1)), i.push(e.nodeIndex(o[s], n) + t)
                        }
                        for (let t = a; t && t !== l; t = t.parentNode) i.push(e.nodeIndex(t, n));
                        return i
                    }, bl = (e, t, n) => {
                        let o = 0;
                        return Bt.each(e.select(t), (e => "all" === e.getAttribute("data-mce-bogus") ? void 0 : e !== n && void o++)), o
                    }, yl = (e, t) => {
                        let n = t ? e.startContainer : e.endContainer, o = t ? e.startOffset : e.endOffset;
                        if (Vo(n) && "TR" === n.nodeName) {
                            const r = n.childNodes;
                            n = r[Math.min(t ? o : o - 1, r.length - 1)], n && (o = t ? 0 : n.childNodes.length, t ? e.setStart(n, o) : e.setEnd(n, o))
                        }
                    }, Cl = e => (yl(e, !0), yl(e, !1), e), El = (e, t) => {
                        if (Vo(e) && (e = Mi(e, t), hl(e))) return e;
                        if (jr(e)) {
                            tr(e) && Ur(e) && (e = e.parentNode);
                            let t = e.previousSibling;
                            if (hl(t)) return t;
                            if (t = e.nextSibling, hl(t)) return t
                        }
                    }, wl = (e, t, n) => {
                        const o = n.getNode(), r = n.getRng();
                        if ("IMG" === o.nodeName || hl(o)) {
                            const e = o.nodeName;
                            return {name: e, index: bl(n.dom, e, o)}
                        }
                        const a = (e => El(e.startContainer, e.startOffset) || El(e.endContainer, e.endOffset))(r);
                        if (a) {
                            const e = a.tagName;
                            return {name: e, index: bl(n.dom, e, a)}
                        }
                        return ((e, t, n, o) => {
                            const r = t.dom, a = vl(r, e, n, o, !0), s = t.isForward(), i = Yr(o) ? {isFakeCaret: !0} : {};
                            return t.isCollapsed() ? {start: a, forward: s, ...i} : {
                                start: a,
                                end: vl(r, e, n, o, !1),
                                forward: s, ...i
                            }
                        })(e, n, t, r)
                    }, _l = (e, t, n) => {
                        const o = {"data-mce-type": "bookmark", id: t, style: "overflow:hidden;line-height:0px"};
                        return n ? e.create("span", o, "&#xFEFF;") : e.create("span", o)
                    }, Sl = (e, t) => {
                        const n = e.dom;
                        let o = e.getRng();
                        const r = n.uniqueId(), a = e.isCollapsed(), s = e.getNode(), i = s.nodeName, l = e.isForward();
                        if ("IMG" === i) return {name: i, index: bl(n, i, s)};
                        const d = Cl(o.cloneRange());
                        if (!a) {
                            d.collapse(!1);
                            const e = _l(n, r + "_end", t);
                            sl(n, d, e)
                        }
                        o = Cl(o), o.collapse(!0);
                        const c = _l(n, r + "_start", t);
                        return sl(n, o, c), e.moveToBookmark({id: r, keep: !0, forward: l}), {id: r, forward: l}
                    }, kl = (e, t, n = !1) => 2 === t ? wl(Ir, n, e) : 3 === t ? (e => {
                        const t = e.getRng();
                        return {
                            start: gl(e.dom.getRoot(), rl.fromRangeStart(t)),
                            end: gl(e.dom.getRoot(), rl.fromRangeEnd(t)),
                            forward: e.isForward()
                        }
                    })(e) : t ? (e => ({rng: e.getRng(), forward: e.isForward()}))(e) : Sl(e, !1), xl = L(wl, R, !0),
                    Al = e => {
                        const t = t => t(e), n = T(e), o = () => r, r = {
                            tag: !0,
                            inner: e,
                            fold: (t, n) => n(e),
                            isValue: F,
                            isError: M,
                            map: t => Tl.value(t(e)),
                            mapError: o,
                            bind: t,
                            exists: t,
                            forall: t,
                            getOr: n,
                            or: o,
                            getOrThunk: n,
                            orThunk: o,
                            getOrDie: n,
                            each: t => {
                                t(e)
                            },
                            toOptional: () => U.some(e)
                        };
                        return r
                    }, Nl = e => {
                        const t = () => n, n = {
                            tag: !1,
                            inner: e,
                            fold: (t, n) => t(e),
                            isValue: M,
                            isError: F,
                            map: t,
                            mapError: t => Tl.error(t(e)),
                            bind: t,
                            exists: M,
                            forall: F,
                            getOr: R,
                            or: R,
                            getOrThunk: P,
                            orThunk: P,
                            getOrDie: B(String(e)),
                            each: x,
                            toOptional: U.none
                        };
                        return n
                    }, Tl = {value: Al, error: Nl, fromOption: (e, t) => e.fold((() => Nl(t)), Al)}, Rl = e => {
                        if (!v(e)) throw new Error("cases must be an array");
                        if (0 === e.length) throw new Error("there must be at least one case");
                        const t = [], n = {};
                        return K(e, ((o, r) => {
                            const a = ge(o);
                            if (1 !== a.length) throw new Error("one and only one name per case");
                            const s = a[0], i = o[s];
                            if (void 0 !== n[s]) throw new Error("duplicate key detected:" + s);
                            if ("cata" === s) throw new Error("cannot have a case named cata (sorry)");
                            if (!v(i)) throw new Error("case arguments must be an array");
                            t.push(s), n[s] = (...n) => {
                                const o = n.length;
                                if (o !== i.length) throw new Error("Wrong number of arguments to case " + s + ". Expected " + i.length + " (" + i + "), got " + o);
                                return {
                                    fold: (...t) => {
                                        if (t.length !== e.length) throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                                        return t[r].apply(null, n)
                                    }, match: e => {
                                        const o = ge(e);
                                        if (t.length !== o.length) throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + o.join(","));
                                        if (!re(t, (e => $(o, e)))) throw new Error("Not all branches were specified when using match. Specified: " + o.join(", ") + "\nRequired: " + t.join(", "));
                                        return e[s].apply(null, n)
                                    }, log: e => {
                                        console.log(e, {constructors: t, constructor: s, params: n})
                                    }
                                }
                            }
                        })), n
                    };
                Rl([{bothErrors: ["error1", "error2"]}, {firstError: ["error1", "value2"]}, {secondError: ["value1", "error2"]}, {bothValues: ["value1", "value2"]}]);
                const Dl = e => "inline-command" === e.type || "inline-format" === e.type,
                    Ll = e => "block-command" === e.type || "block-format" === e.type, Ol = e => {
                        const t = t => Tl.error({message: t, pattern: e}), n = (n, o, r) => {
                            if (void 0 !== e.format) {
                                let r;
                                if (v(e.format)) {
                                    if (!re(e.format, g)) return t(n + " pattern has non-string items in the `format` array");
                                    r = e.format
                                } else {
                                    if (!g(e.format)) return t(n + " pattern has non-string `format` parameter");
                                    r = [e.format]
                                }
                                return Tl.value(o(r))
                            }
                            return void 0 !== e.cmd ? g(e.cmd) ? Tl.value(r(e.cmd, e.value)) : t(n + " pattern has non-string `cmd` parameter") : t(n + " pattern is missing both `format` and `cmd` parameters")
                        };
                        if (!p(e)) return t("Raw pattern is not an object");
                        if (!g(e.start)) return t("Raw pattern is missing `start` parameter");
                        if (void 0 !== e.end) {
                            if (!g(e.end)) return t("Inline pattern has non-string `end` parameter");
                            if (0 === e.start.length && 0 === e.end.length) return t("Inline pattern has empty `start` and `end` parameters");
                            let o = e.start, r = e.end;
                            return 0 === r.length && (r = o, o = ""), n("Inline", (e => ({
                                type: "inline-format",
                                start: o,
                                end: r,
                                format: e
                            })), ((e, t) => ({type: "inline-command", start: o, end: r, cmd: e, value: t})))
                        }
                        return void 0 !== e.replacement ? g(e.replacement) ? 0 === e.start.length ? t("Replacement pattern has empty `start` parameter") : Tl.value({
                            type: "inline-command",
                            start: "",
                            end: e.start,
                            cmd: "mceInsertContent",
                            value: e.replacement
                        }) : t("Replacement pattern has non-string `replacement` parameter") : 0 === e.start.length ? t("Block pattern has empty `start` parameter") : n("Block", (t => ({
                            type: "block-format",
                            start: e.start,
                            format: t[0]
                        })), ((t, n) => ({type: "block-command", start: e.start, cmd: t, value: n})))
                    }, Bl = e => X(e, Ll), Pl = e => X(e, Dl), Il = e => {
                        const t = (e => {
                            const t = [], n = [];
                            return K(e, (e => {
                                e.fold((e => {
                                    t.push(e)
                                }), (e => {
                                    n.push(e)
                                }))
                            })), {errors: t, values: n}
                        })(W(e, Ol));
                        return K(t.errors, (e => console.error(e.message, e.pattern))), t.values
                    }, Ml = _t().deviceType, Fl = Ml.isTouch(), Ul = Xs.DOM, ql = e => f(e, RegExp),
                    jl = e => t => t.options.get(e), Hl = e => g(e) || p(e), zl = (e, t = "") => n => {
                        const o = g(n);
                        if (o) {
                            if (-1 !== n.indexOf("=")) {
                                const r = (e => {
                                    const t = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
                                    return Q(t, ((e, t) => {
                                        const n = t.split("="), o = n[0], r = n.length > 1 ? n[1] : o;
                                        return e[Ke(o)] = Ke(r), e
                                    }), {})
                                })(n);
                                return {value: Se(r, e.id).getOr(t), valid: o}
                            }
                            return {value: n, valid: o}
                        }
                        return {valid: !1, message: "Must be a string."}
                    }, $l = jl("iframe_attrs"), Vl = jl("doctype"), Wl = jl("document_base_url"), Kl = jl("body_id"),
                    Yl = jl("body_class"), Gl = jl("content_security_policy"), Xl = jl("br_in_pre"),
                    Jl = jl("forced_root_block"), Ql = jl("forced_root_block_attrs"), Zl = jl("newline_behavior"),
                    ed = jl("br_newline_selector"), td = jl("no_newline_selector"), nd = jl("keep_styles"),
                    od = jl("end_container_on_empty_block"), rd = jl("automatic_uploads"),
                    ad = jl("images_reuse_filename"), sd = jl("images_replace_blob_uris"), id = jl("icons"),
                    ld = jl("icons_url"), dd = jl("images_upload_url"), cd = jl("images_upload_base_path"),
                    ud = jl("images_upload_credentials"), md = jl("images_upload_handler"), fd = jl("content_css_cors"),
                    gd = jl("referrer_policy"), pd = jl("language"), hd = jl("language_url"),
                    vd = jl("indent_use_margin"), bd = jl("indentation"), yd = jl("content_css"),
                    Cd = jl("content_style"), Ed = jl("font_css"), wd = jl("directionality"),
                    _d = jl("inline_boundaries_selector"), Sd = jl("object_resizing"),
                    kd = jl("resize_img_proportional"), xd = jl("placeholder"), Ad = jl("event_root"),
                    Nd = jl("service_message"), Td = jl("theme"), Rd = jl("theme_url"), Dd = jl("model"),
                    Ld = jl("model_url"), Od = jl("inline_boundaries"), Bd = jl("formats"), Pd = jl("preview_styles"),
                    Id = jl("format_empty_lines"), Md = jl("format_noneditable_selector"),
                    Fd = jl("custom_ui_selector"), Ud = jl("inline"), qd = jl("hidden_input"), jd = jl("submit_patch"),
                    Hd = jl("add_form_submit_trigger"), zd = jl("add_unload_trigger"),
                    $d = jl("custom_undo_redo_levels"), Vd = jl("disable_nodechange"), Wd = jl("readonly"),
                    Kd = jl("editable_root"), Yd = jl("content_css_cors"), Gd = jl("plugins"),
                    Xd = jl("external_plugins"), Jd = jl("block_unsupported_drop"), Qd = jl("visual"),
                    Zd = jl("visual_table_class"), ec = jl("visual_anchor_class"), tc = jl("iframe_aria_text"),
                    nc = jl("setup"), oc = jl("init_instance_callback"), rc = jl("urlconverter_callback"),
                    ac = jl("auto_focus"), sc = jl("browser_spellcheck"), ic = jl("protect"),
                    lc = jl("paste_block_drop"), dc = jl("paste_data_images"), cc = jl("paste_preprocess"),
                    uc = jl("paste_postprocess"), mc = jl("newdocument_content"), fc = jl("paste_webkit_styles"),
                    gc = jl("paste_remove_styles_if_webkit"), pc = jl("paste_merge_formats"), hc = jl("smart_paste"),
                    vc = jl("paste_as_text"), bc = jl("paste_tab_spaces"), yc = jl("allow_html_data_urls"),
                    Cc = jl("text_patterns"), Ec = jl("text_patterns_lookup"), wc = jl("noneditable_class"),
                    _c = jl("editable_class"), Sc = jl("noneditable_regexp"), kc = jl("preserve_cdata"),
                    xc = jl("highlight_on_focus"), Ac = jl("xss_sanitization"), Nc = jl("init_content_sync"),
                    Tc = e => Bt.explode(e.options.get("images_file_types")), Rc = jl("table_tab_navigation"),
                    Dc = jl("details_initial_state"), Lc = jl("details_serialized_state"), Oc = jl("force_hex_color"),
                    Bc = jl("sandbox_iframes"), Pc = Vo, Ic = tr, Mc = e => {
                        const t = e.parentNode;
                        t && t.removeChild(e)
                    }, Fc = e => {
                        const t = Ir(e);
                        return {count: e.length - t.length, text: t}
                    }, Uc = e => {
                        let t;
                        for (; -1 !== (t = e.data.lastIndexOf(Br));) e.deleteData(t, 1)
                    }, qc = (e, t) => ($c(e), t), jc = (e, t) => {
                        const n = t.container(), o = ((e, t) => {
                            const n = z(e, t);
                            return -1 === n ? U.none() : U.some(n)
                        })(me(n.childNodes), e).map((e => e < t.offset() ? rl(n, t.offset() - 1) : t)).getOr(t);
                        return $c(e), o
                    }, Hc = (e, t) => Ic(e) && t.container() === e ? ((e, t) => {
                        const n = Fc(e.data.substr(0, t.offset())), o = Fc(e.data.substr(t.offset()));
                        return (n.text + o.text).length > 0 ? (Uc(e), rl(e, t.offset() - n.count)) : t
                    })(e, t) : qc(e, t),
                    zc = (e, t) => rl.isTextPosition(t) ? Hc(e, t) : ((e, t) => t.container() === e.parentNode ? jc(e, t) : qc(e, t))(e, t),
                    $c = e => {
                        Pc(e) && jr(e) && (Hr(e) ? e.removeAttribute("data-mce-caret") : Mc(e)), Ic(e) && (Uc(e), 0 === e.data.length && Mc(e))
                    }, Vc = cr, Wc = fr, Kc = ur, Yc = (e, t, n) => {
                        const o = Di(t.getBoundingClientRect(), n);
                        let r, a;
                        if ("BODY" === e.tagName) {
                            const t = e.ownerDocument.documentElement;
                            r = e.scrollLeft || t.scrollLeft, a = e.scrollTop || t.scrollTop
                        } else {
                            const t = e.getBoundingClientRect();
                            r = e.scrollLeft - t.left, a = e.scrollTop - t.top
                        }
                        o.left += r, o.right += r, o.top += a, o.bottom += a, o.width = 1;
                        let s = t.offsetWidth - t.clientWidth;
                        return s > 0 && (n && (s *= -1), o.left += s, o.right += s), o
                    }, Gc = (e, t, n, o) => {
                        const r = si();
                        let a, s;
                        const i = Jl(e), l = e.dom, d = () => {
                            (e => {
                                var t, n;
                                const o = qo(yn.fromDom(e), "*[contentEditable=false],video,audio,embed,object");
                                for (let e = 0; e < o.length; e++) {
                                    const r = o[e].dom;
                                    let a = r.previousSibling;
                                    if (Wr(a)) {
                                        const e = a.data;
                                        1 === e.length ? null === (t = a.parentNode) || void 0 === t || t.removeChild(a) : a.deleteData(e.length - 1, 1)
                                    }
                                    a = r.nextSibling, Vr(a) && (1 === a.data.length ? null === (n = a.parentNode) || void 0 === n || n.removeChild(a) : a.deleteData(0, 1))
                                }
                            })(t), s && ($c(s), s = null), r.on((e => {
                                l.remove(e.caret), r.clear()
                            })), a && (clearInterval(a), a = void 0)
                        }, c = () => {
                            a = setInterval((() => {
                                r.on((e => {
                                    o() ? l.toggleClass(e.caret, "mce-visual-caret-hidden") : l.addClass(e.caret, "mce-visual-caret-hidden")
                                }))
                            }), 500)
                        };
                        return {
                            show: (e, o) => {
                                let a;
                                if (d(), Kc(o)) return null;
                                if (!n(o)) return s = ((e, t) => {
                                    var n;
                                    const o = (null !== (n = e.ownerDocument) && void 0 !== n ? n : document).createTextNode(Br),
                                        r = e.parentNode;
                                    if (t) {
                                        const t = e.previousSibling;
                                        if (Fr(t)) {
                                            if (jr(t)) return t;
                                            if (Wr(t)) return t.splitText(t.data.length - 1)
                                        }
                                        null == r || r.insertBefore(o, e)
                                    } else {
                                        const t = e.nextSibling;
                                        if (Fr(t)) {
                                            if (jr(t)) return t;
                                            if (Vr(t)) return t.splitText(1), t
                                        }
                                        e.nextSibling ? null == r || r.insertBefore(o, e.nextSibling) : null == r || r.appendChild(o)
                                    }
                                    return o
                                })(o, e), a = o.ownerDocument.createRange(), Jc(s.nextSibling) ? (a.setStart(s, 0), a.setEnd(s, 0)) : (a.setStart(s, 1), a.setEnd(s, 1)), a;
                                {
                                    const n = ((e, t, n) => {
                                        var o;
                                        const r = (null !== (o = t.ownerDocument) && void 0 !== o ? o : document).createElement(e);
                                        r.setAttribute("data-mce-caret", n ? "before" : "after"), r.setAttribute("data-mce-bogus", "all"), r.appendChild(Lr().dom);
                                        const a = t.parentNode;
                                        return n ? null == a || a.insertBefore(r, t) : t.nextSibling ? null == a || a.insertBefore(r, t.nextSibling) : null == a || a.appendChild(r), r
                                    })(i, o, e), d = Yc(t, o, e);
                                    l.setStyle(n, "top", d.top), s = n;
                                    const u = l.create("div", {class: "mce-visual-caret", "data-mce-bogus": "all"});
                                    l.setStyles(u, {...d}), l.add(t, u), r.set({
                                        caret: u,
                                        element: o,
                                        before: e
                                    }), e && l.addClass(u, "mce-visual-caret-before"), c(), a = o.ownerDocument.createRange(), a.setStart(n, 0), a.setEnd(n, 0)
                                }
                                return a
                            },
                            hide: d,
                            getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
                            reposition: () => {
                                r.on((e => {
                                    const n = Yc(t, e.element, e.before);
                                    l.setStyles(e.caret, {...n})
                                }))
                            },
                            destroy: () => clearInterval(a)
                        }
                    }, Xc = () => Rt.browser.isFirefox(), Jc = e => Vc(e) || Wc(e),
                    Qc = e => (Jc(e) || Qo(e) && Xc()) && Tn(yn.fromDom(e)).exists(oo), Zc = dr, eu = cr, tu = fr,
                    nu = Go("display", "block table table-cell table-caption list-item"), ou = jr, ru = Ur, au = Vo,
                    su = tr, iu = oa, lu = e => e > 0, du = e => e < 0, cu = (e, t) => {
                        let n;
                        for (; n = e(t);) if (!ru(n)) return n;
                        return null
                    }, uu = (e, t, n, o, r) => {
                        const a = new Ho(e, o), s = eu(e) || ru(e);
                        let i;
                        if (du(t)) {
                            if (s && (i = cu(a.prev.bind(a), !0), n(i))) return i;
                            for (; i = cu(a.prev.bind(a), r);) if (n(i)) return i
                        }
                        if (lu(t)) {
                            if (s && (i = cu(a.next.bind(a), !0), n(i))) return i;
                            for (; i = cu(a.next.bind(a), r);) if (n(i)) return i
                        }
                        return null
                    }, mu = (e, t) => {
                        for (; e && e !== t;) {
                            if (nu(e)) return e;
                            e = e.parentNode
                        }
                        return null
                    }, fu = (e, t, n) => mu(e.container(), n) === mu(t.container(), n), gu = (e, t) => {
                        if (!t) return U.none();
                        const n = t.container(), o = t.offset();
                        return au(n) ? U.from(n.childNodes[o + e]) : U.none()
                    }, pu = (e, t) => {
                        var n;
                        const o = (null !== (n = t.ownerDocument) && void 0 !== n ? n : document).createRange();
                        return e ? (o.setStartBefore(t), o.setEndBefore(t)) : (o.setStartAfter(t), o.setEndAfter(t)), o
                    }, hu = (e, t, n) => mu(t, e) === mu(n, e), vu = (e, t, n) => {
                        const o = e ? "previousSibling" : "nextSibling";
                        let r = n;
                        for (; r && r !== t;) {
                            let e = r[o];
                            if (e && ou(e) && (e = e[o]), eu(e) || tu(e)) {
                                if (hu(t, e, r)) return e;
                                break
                            }
                            if (iu(e)) break;
                            r = r.parentNode
                        }
                        return null
                    }, bu = L(pu, !0), yu = L(pu, !1), Cu = (e, t, n) => {
                        let o;
                        const r = L(vu, !0, t), a = L(vu, !1, t), s = n.startContainer, i = n.startOffset;
                        if (Ur(s)) {
                            const e = su(s) ? s.parentNode : s, t = e.getAttribute("data-mce-caret");
                            if ("before" === t && (o = e.nextSibling, Qc(o))) return bu(o);
                            if ("after" === t && (o = e.previousSibling, Qc(o))) return yu(o)
                        }
                        if (!n.collapsed) return n;
                        if (tr(s)) {
                            if (ou(s)) {
                                if (1 === e) {
                                    if (o = a(s), o) return bu(o);
                                    if (o = r(s), o) return yu(o)
                                }
                                if (-1 === e) {
                                    if (o = r(s), o) return yu(o);
                                    if (o = a(s), o) return bu(o)
                                }
                                return n
                            }
                            if (Wr(s) && i >= s.data.length - 1) return 1 === e && (o = a(s), o) ? bu(o) : n;
                            if (Vr(s) && i <= 1) return -1 === e && (o = r(s), o) ? yu(o) : n;
                            if (i === s.data.length) return o = a(s), o ? bu(o) : n;
                            if (0 === i) return o = r(s), o ? yu(o) : n
                        }
                        return n
                    }, Eu = (e, t) => gu(e ? 0 : -1, t).filter(eu), wu = (e, t, n) => {
                        const o = Cu(e, t, n);
                        return -1 === e ? rl.fromRangeStart(o) : rl.fromRangeEnd(o)
                    }, _u = e => U.from(e.getNode()).map(yn.fromDom), Su = (e, t) => {
                        let n = t;
                        for (; n = e(n);) if (n.isVisible()) return n;
                        return n
                    }, ku = (e, t) => {
                        const n = fu(e, t);
                        return !(n || !ir(e.getNode())) || n
                    };
                var xu;
                !function (e) {
                    e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards"
                }(xu || (xu = {}));
                const Au = cr, Nu = tr, Tu = Vo, Ru = ir, Du = oa,
                    Lu = e => ea(e) || (e => !!ra(e) && !Q(me(e.getElementsByTagName("*")), ((e, t) => e || Gr(t)), !1))(e),
                    Ou = aa, Bu = (e, t) => e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null,
                    Pu = (e, t) => {
                        if (lu(e)) {
                            if (Du(t.previousSibling) && !Nu(t.previousSibling)) return rl.before(t);
                            if (Nu(t)) return rl(t, 0)
                        }
                        if (du(e)) {
                            if (Du(t.nextSibling) && !Nu(t.nextSibling)) return rl.after(t);
                            if (Nu(t)) return rl(t, t.data.length)
                        }
                        return du(e) ? Ru(t) ? rl.before(t) : rl.after(t) : rl.before(t)
                    }, Iu = (e, t, n) => {
                        let o, r, a, s;
                        if (!Tu(n) || !t) return null;
                        if (t.isEqual(rl.after(n)) && n.lastChild) {
                            if (s = rl.after(n.lastChild), du(e) && Du(n.lastChild) && Tu(n.lastChild)) return Ru(n.lastChild) ? rl.before(n.lastChild) : s
                        } else s = t;
                        const i = s.container();
                        let l = s.offset();
                        if (Nu(i)) {
                            if (du(e) && l > 0) return rl(i, --l);
                            if (lu(e) && l < i.length) return rl(i, ++l);
                            o = i
                        } else {
                            if (du(e) && l > 0 && (r = Bu(i, l - 1), Du(r))) return !Lu(r) && (a = uu(r, e, Ou, r), a) ? Nu(a) ? rl(a, a.data.length) : rl.after(a) : Nu(r) ? rl(r, r.data.length) : rl.before(r);
                            if (lu(e) && l < i.childNodes.length && (r = Bu(i, l), Du(r))) return Ru(r) ? ((e, t) => {
                                const n = t.nextSibling;
                                return n && Du(n) ? Nu(n) ? rl(n, 0) : rl.before(n) : Iu(xu.Forwards, rl.after(t), e)
                            })(n, r) : !Lu(r) && (a = uu(r, e, Ou, r), a) ? Nu(a) ? rl(a, 0) : rl.before(a) : Nu(r) ? rl(r, 0) : rl.after(r);
                            o = r || s.getNode()
                        }
                        if (o && (lu(e) && s.isAtEnd() || du(e) && s.isAtStart()) && (o = uu(o, e, F, n, !0), Ou(o, n))) return Pu(e, o);
                        r = o ? uu(o, e, Ou, n) : o;
                        const d = Pe(X(((e, t) => {
                            const n = [];
                            let o = e;
                            for (; o && o !== t;) n.push(o), o = o.parentNode;
                            return n
                        })(i, n), Au));
                        return !d || r && d.contains(r) ? r ? Pu(e, r) : null : (s = lu(e) ? rl.after(d) : rl.before(d), s)
                    }, Mu = e => ({next: t => Iu(xu.Forwards, t, e), prev: t => Iu(xu.Backwards, t, e)}),
                    Fu = e => rl.isTextPosition(e) ? 0 === e.offset() : oa(e.getNode()), Uu = e => {
                        if (rl.isTextPosition(e)) {
                            const t = e.container();
                            return e.offset() === t.data.length
                        }
                        return oa(e.getNode(!0))
                    }, qu = (e, t) => !rl.isTextPosition(e) && !rl.isTextPosition(t) && e.getNode() === t.getNode(!0),
                    ju = (e, t, n) => {
                        return e ? !qu(t, n) && (o = t, !(!rl.isTextPosition(o) && ir(o.getNode()))) && Uu(t) && Fu(n) : !qu(n, t) && Fu(t) && Uu(n);
                        var o
                    }, Hu = (e, t, n) => {
                        const o = Mu(t);
                        return U.from(e ? o.next(n) : o.prev(n))
                    }, zu = (e, t, n) => Hu(e, t, n).bind((o => fu(n, o, t) && ju(e, n, o) ? Hu(e, t, o) : U.some(o))),
                    $u = (e, t, n, o) => zu(e, t, n).bind((n => o(n) ? $u(e, t, n, o) : U.some(n))), Vu = (e, t) => {
                        const n = e ? t.firstChild : t.lastChild;
                        return tr(n) ? U.some(rl(n, e ? 0 : n.data.length)) : n ? oa(n) ? U.some(e ? rl.before(n) : ir(o = n) ? rl.before(o) : rl.after(o)) : ((e, t, n) => {
                            const o = e ? rl.before(n) : rl.after(n);
                            return Hu(e, t, o)
                        })(e, t, n) : U.none();
                        var o
                    }, Wu = L(Hu, !0), Ku = L(Hu, !1), Yu = L(Vu, !0), Gu = L(Vu, !1), Xu = "_mce_caret",
                    Ju = e => Vo(e) && e.id === Xu, Qu = (e, t) => {
                        let n = t;
                        for (; n && n !== e;) {
                            if (Ju(n)) return n;
                            n = n.parentNode
                        }
                        return null
                    }, Zu = e => ke(e, "name"), em = e => Bt.isArray(e.start),
                    tm = e => !(!Zu(e) && y(e.forward)) || e.forward,
                    nm = (e, t) => (Vo(t) && e.isBlock(t) && !t.innerHTML && (t.innerHTML = '<br data-mce-bogus="1" />'), t),
                    om = (e, t) => Gu(e).fold(M, (e => (t.setStart(e.container(), e.offset()), t.setEnd(e.container(), e.offset()), !0))),
                    rm = (e, t, n) => !(!(e => !e.hasChildNodes())(t) || !Qu(e, t)) && (((e, t) => {
                        var n;
                        const o = (null !== (n = e.ownerDocument) && void 0 !== n ? n : document).createTextNode(Br);
                        e.appendChild(o), t.setStart(o, 0), t.setEnd(o, 0)
                    })(t, n), !0), am = (e, t, n, o) => {
                        const r = n[t ? "start" : "end"], a = e.getRoot();
                        if (r) {
                            let e = a, n = r[0];
                            for (let t = r.length - 1; e && t >= 1; t--) {
                                const n = e.childNodes;
                                if (rm(a, e, o)) return !0;
                                if (r[t] > n.length - 1) return !!rm(a, e, o) || om(e, o);
                                e = n[r[t]]
                            }
                            tr(e) && (n = Math.min(r[0], e.data.length)), Vo(e) && (n = Math.min(r[0], e.childNodes.length)), t ? o.setStart(e, n) : o.setEnd(e, n)
                        }
                        return !0
                    }, sm = e => tr(e) && e.data.length > 0, im = (e, t, n) => {
                        const o = e.get(n.id + "_" + t), r = null == o ? void 0 : o.parentNode, a = n.keep;
                        if (o && r) {
                            let s, i;
                            if ("start" === t ? a ? o.hasChildNodes() ? (s = o.firstChild, i = 1) : sm(o.nextSibling) ? (s = o.nextSibling, i = 0) : sm(o.previousSibling) ? (s = o.previousSibling, i = o.previousSibling.data.length) : (s = r, i = e.nodeIndex(o) + 1) : (s = r, i = e.nodeIndex(o)) : a ? o.hasChildNodes() ? (s = o.firstChild, i = 1) : sm(o.previousSibling) ? (s = o.previousSibling, i = o.previousSibling.data.length) : (s = r, i = e.nodeIndex(o)) : (s = r, i = e.nodeIndex(o)), !a) {
                                const r = o.previousSibling, a = o.nextSibling;
                                let l;
                                for (Bt.each(Bt.grep(o.childNodes), (e => {
                                    tr(e) && (e.data = e.data.replace(/\uFEFF/g, ""))
                                })); l = e.get(n.id + "_" + t);) e.remove(l, !0);
                                if (tr(a) && tr(r) && !Rt.browser.isOpera()) {
                                    const t = r.data.length;
                                    r.appendData(a.data), e.remove(a), s = r, i = t
                                }
                            }
                            return U.some(rl(s, i))
                        }
                        return U.none()
                    }, lm = (e, t) => {
                        const n = e.dom;
                        if (t) {
                            if (em(t)) return ((e, t) => {
                                const n = e.createRng();
                                return am(e, !0, t, n) && am(e, !1, t, n) ? U.some({range: n, forward: tm(t)}) : U.none()
                            })(n, t);
                            if ((e => g(e.start))(t)) return ((e, t) => {
                                const n = U.from(pl(e.getRoot(), t.start)), o = U.from(pl(e.getRoot(), t.end));
                                return Mt(n, o, ((n, o) => {
                                    const r = e.createRng();
                                    return r.setStart(n.container(), n.offset()), r.setEnd(o.container(), o.offset()), {
                                        range: r,
                                        forward: tm(t)
                                    }
                                }))
                            })(n, t);
                            if ((e => ke(e, "id"))(t)) return ((e, t) => {
                                const n = im(e, "start", t), o = im(e, "end", t);
                                return Mt(n, o.or(n), ((n, o) => {
                                    const r = e.createRng();
                                    return r.setStart(nm(e, n.container()), n.offset()), r.setEnd(nm(e, o.container()), o.offset()), {
                                        range: r,
                                        forward: tm(t)
                                    }
                                }))
                            })(n, t);
                            if (Zu(t)) return ((e, t) => U.from(e.select(t.name)[t.index]).map((t => {
                                const n = e.createRng();
                                return n.selectNode(t), {range: n, forward: !0}
                            })))(n, t);
                            if ((e => ke(e, "rng"))(t)) return U.some({range: t.rng, forward: tm(t)})
                        }
                        return U.none()
                    }, dm = (e, t, n) => kl(e, t, n), cm = (e, t) => {
                        lm(e, t).each((({range: t, forward: n}) => {
                            e.setRng(t, n)
                        }))
                    }, um = e => Vo(e) && "SPAN" === e.tagName && "bookmark" === e.getAttribute("data-mce-type"),
                    mm = (fm = br, e => fm === e);
                var fm;
                const gm = e => "" !== e && -1 !== " \f\n\r\t\v".indexOf(e), pm = e => !gm(e) && !mm(e) && !yr(e),
                    hm = e => {
                        const t = [];
                        if (e) for (let n = 0; n < e.rangeCount; n++) t.push(e.getRangeAt(n));
                        return t
                    }, vm = e => X((e => oe(e, (e => {
                        const t = Ii(e);
                        return t ? [yn.fromDom(t)] : []
                    })))(e), Tr), bm = (e, t) => {
                        const n = qo(t, "td[data-mce-selected],th[data-mce-selected]");
                        return n.length > 0 ? n : vm(e)
                    }, ym = e => bm(hm(e.selection.getSel()), yn.fromDom(e.getBody())), Cm = (e, t) => eo(e, "table", t),
                    Em = e => Mn(e).fold(T([e]), (t => [e].concat(Em(t)))),
                    wm = e => Fn(e).fold(T([e]), (t => "br" === $t(t) ? Dn(t).map((t => [e].concat(wm(t)))).getOr([]) : [e].concat(wm(t)))),
                    _m = (e, t) => Mt((e => {
                        const t = e.startContainer, n = e.startOffset;
                        return tr(t) ? 0 === n ? U.some(yn.fromDom(t)) : U.none() : U.from(t.childNodes[n]).map(yn.fromDom)
                    })(t), (e => {
                        const t = e.endContainer, n = e.endOffset;
                        return tr(t) ? n === t.data.length ? U.some(yn.fromDom(t)) : U.none() : U.from(t.childNodes[n - 1]).map(yn.fromDom)
                    })(t), ((t, n) => {
                        const o = ee(Em(e), L(_n, t)), r = ee(wm(e), L(_n, n));
                        return o.isSome() && r.isSome()
                    })).getOr(!1), Sm = (e, t, n, o) => {
                        const r = n, a = new Ho(n, r),
                            s = Ee(e.schema.getMoveCaretBeforeOnEnterElements(), ((e, t) => !$(["td", "th", "table"], t.toLowerCase())));
                        let i = n;
                        do {
                            if (tr(i) && 0 !== Bt.trim(i.data).length) return void (o ? t.setStart(i, 0) : t.setEnd(i, i.data.length));
                            if (s[i.nodeName]) return void (o ? t.setStartBefore(i) : "BR" === i.nodeName ? t.setEndBefore(i) : t.setEndAfter(i))
                        } while (i = o ? a.next() : a.prev());
                        "BODY" === r.nodeName && (o ? t.setStart(r, 0) : t.setEnd(r, r.childNodes.length))
                    }, km = e => {
                        const t = e.selection.getSel();
                        return w(t) && t.rangeCount > 0
                    }, xm = (e, t) => {
                        const n = ym(e);
                        n.length > 0 ? K(n, (n => {
                            const o = n.dom, r = e.dom.createRng();
                            r.setStartBefore(o), r.setEndAfter(o), t(r, !0)
                        })) : t(e.selection.getRng(), !1)
                    }, Am = (e, t, n) => {
                        const o = Sl(e, t);
                        n(o), e.moveToBookmark(o)
                    }, Nm = e => S(null == e ? void 0 : e.nodeType), Tm = e => Vo(e) && !um(e) && !Ju(e) && !Jo(e),
                    Rm = (e, t, n) => {
                        const {selection: o, dom: r} = e, a = o.getNode(), s = cr(a);
                        Am(o, !0, (() => {
                            t()
                        }));
                        s && cr(a) && r.isChildOf(a, e.getBody()) ? e.selection.select(a) : n(o.getStart()) && Dm(r, o)
                    }, Dm = (e, t) => {
                        var n, o;
                        const r = t.getRng(), {startContainer: a, startOffset: s} = r;
                        if (!((e, t) => {
                            if (Tm(t) && !/^(TD|TH)$/.test(t.nodeName)) {
                                const n = e.getAttrib(t, "data-mce-selected"), o = parseInt(n, 10);
                                return !isNaN(o) && o > 0
                            }
                            return !1
                        })(e, t.getNode()) && Vo(a)) {
                            const i = a.childNodes, l = e.getRoot();
                            let d;
                            if (s < i.length) {
                                const t = i[s];
                                d = new Ho(t, null !== (n = e.getParent(t, e.isBlock)) && void 0 !== n ? n : l)
                            } else {
                                const t = i[i.length - 1];
                                d = new Ho(t, null !== (o = e.getParent(t, e.isBlock)) && void 0 !== o ? o : l), d.next(!0)
                            }
                            for (let n = d.current(); n; n = d.next()) {
                                if ("false" === e.getContentEditable(n)) return;
                                if (tr(n) && !Pm(n)) return r.setStart(n, 0), void t.setRng(r)
                            }
                        }
                    }, Lm = (e, t, n) => {
                        if (e) {
                            const o = t ? "nextSibling" : "previousSibling";
                            for (e = n ? e : e[o]; e; e = e[o]) if (Vo(e) || !Pm(e)) return e
                        }
                    }, Om = (e, t) => !!e.getTextBlockElements()[t.nodeName.toLowerCase()] || Pa(e, t),
                    Bm = (e, t, n) => e.schema.isValidChild(t, n), Pm = (e, t = !1) => {
                        if (w(e) && tr(e)) {
                            const n = t ? e.data.replace(/ /g, " ") : e.data;
                            return ia(n)
                        }
                        return !1
                    }, Im = (e, t) => {
                        const n = e.dom;
                        return Tm(t) && "false" === n.getContentEditable(t) && ((e, t) => {
                            const n = "[data-mce-cef-wrappable]", o = Md(e), r = Je(o) ? n : `${n},${o}`;
                            return En(yn.fromDom(t), r)
                        })(e, t) && 0 === n.select('[contenteditable="true"]', t).length
                    }, Mm = (e, t) => _(e) ? e(t) : (w(t) && (e = e.replace(/%(\w+)/g, ((e, n) => t[n] || e))), e),
                    Fm = (e, t) => (t = t || "", e = "" + ((e = e || "").nodeName || e), t = "" + (t.nodeName || t), e.toLowerCase() === t.toLowerCase()),
                    Um = (e, t) => {
                        if (E(e)) return null;
                        {
                            let n = String(e);
                            return "color" !== t && "backgroundColor" !== t || (n = Ts(n)), "fontWeight" === t && 700 === e && (n = "bold"), "fontFamily" === t && (n = n.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), n
                        }
                    }, qm = (e, t, n) => {
                        const o = e.getStyle(t, n);
                        return Um(o, n)
                    }, jm = (e, t) => {
                        let n;
                        return e.getParent(t, (t => !!Vo(t) && (n = e.getStyle(t, "text-decoration"), !!n && "none" !== n))), n
                    }, Hm = (e, t, n) => e.getParents(t, n, e.getRoot()), zm = (e, t, n) => {
                        const o = e.formatter.get(t);
                        return w(o) && V(o, n)
                    }, $m = (e, t, n) => {
                        const o = ["inline", "block", "selector", "attributes", "styles", "classes"],
                            r = e => Ee(e, ((e, t) => V(o, (e => e === t))));
                        return zm(e, t, (t => {
                            const o = r(t);
                            return zm(e, n, (e => {
                                const t = r(e);
                                return ((e, t, n = i) => s(n).eq(e, t))(o, t)
                            }))
                        }))
                    }, Vm = e => xe(e, "block"), Wm = e => xe(e, "selector"), Km = e => xe(e, "inline"),
                    Ym = e => Wm(e) && !1 !== e.expand && !Km(e), Gm = e => (e => {
                        const t = [];
                        let n = e;
                        for (; n;) {
                            if (tr(n) && n.data !== Br || n.childNodes.length > 1) return [];
                            Vo(n) && t.push(n), n = n.firstChild
                        }
                        return t
                    })(e).length > 0, Xm = e => Ju(e.dom) && Gm(e.dom), Jm = um, Qm = Hm, Zm = Pm, ef = Om, tf = (e, t) => {
                        let n = t;
                        for (; n;) {
                            if (Vo(n) && e.getContentEditable(n)) return "false" === e.getContentEditable(n) ? n : t;
                            n = n.parentNode
                        }
                        return t
                    }, nf = (e, t, n, o) => {
                        const r = t.data;
                        if (e) {
                            for (let e = n; e > 0; e--) if (o(r.charAt(e - 1))) return e
                        } else for (let e = n; e < r.length; e++) if (o(r.charAt(e))) return e;
                        return -1
                    }, of = (e, t, n) => nf(e, t, n, (e => mm(e) || gm(e))), rf = (e, t, n) => nf(e, t, n, pm),
                    af = (e, t, n, o, r, a) => {
                        let s;
                        const i = e.getParent(n, e.isBlock) || t, l = (t, n, o) => {
                            const a = Ni(e), l = r ? a.backwards : a.forwards;
                            return U.from(l(t, n, ((e, t) => Jm(e.parentNode) ? -1 : (s = e, o(r, e, t))), i))
                        };
                        return l(n, o, of).bind((e => a ? l(e.container, e.offset + (r ? -1 : 0), rf) : U.some(e))).orThunk((() => s ? U.some({
                            container: s,
                            offset: r ? 0 : s.length
                        }) : U.none()))
                    }, sf = (e, t, n, o, r) => {
                        const a = o[r];
                        tr(o) && Je(o.data) && a && (o = a);
                        const s = Qm(e, o);
                        for (let o = 0; o < s.length; o++) for (let r = 0; r < t.length; r++) {
                            const a = t[r];
                            if ((!w(a.collapsed) || a.collapsed === n.collapsed) && (Wm(a) && e.is(s[o], a.selector))) return s[o]
                        }
                        return o
                    }, lf = (e, t, n, o) => {
                        var r;
                        let a = n;
                        const s = e.getRoot(), i = t[0];
                        if (Vm(i) && (a = i.wrapper ? null : e.getParent(n, i.block, s)), !a) {
                            const t = null !== (r = e.getParent(n, "LI,TD,TH,SUMMARY")) && void 0 !== r ? r : s;
                            a = e.getParent(tr(n) ? n.parentNode : n, (t => t !== s && ef(e.schema, t)), t)
                        }
                        if (a && Vm(i) && i.wrapper && (a = Qm(e, a, "ul,ol").reverse()[0] || a), !a) for (a = n; a && a[o] && !e.isBlock(a[o]) && (a = a[o], !Fm(a, "br"));) ;
                        return a || n
                    }, df = (e, t, n, o) => {
                        const r = n.parentNode;
                        return !w(n[o]) && (!(r !== t && !E(r) && !e.isBlock(r)) || df(e, t, r, o))
                    }, cf = (e, t, n, o, r) => {
                        let a = n;
                        const s = r ? "previousSibling" : "nextSibling", i = e.getRoot();
                        if (tr(n) && !Zm(n) && (r ? o > 0 : o < n.data.length)) return n;
                        for (; a;) {
                            if (!t[0].block_expand && e.isBlock(a)) return a;
                            for (let t = a[s]; t; t = t[s]) {
                                const n = tr(t) && !df(e, i, t, s);
                                if (!Jm(t) && (!ir(l = t) || !l.getAttribute("data-mce-bogus") || l.nextSibling) && !Zm(t, n)) return a
                            }
                            if (a === i || a.parentNode === i) {
                                n = a;
                                break
                            }
                            a = a.parentNode
                        }
                        var l;
                        return n
                    }, uf = e => Jm(e.parentNode) || Jm(e), mf = (e, t, n, o = !1) => {
                        let {startContainer: r, startOffset: a, endContainer: s, endOffset: i} = t;
                        const l = n[0];
                        if (Vo(r) && r.hasChildNodes() && (r = Mi(r, a), tr(r) && (a = 0)), Vo(s) && s.hasChildNodes() && (s = Mi(s, t.collapsed ? i : i - 1), tr(s) && (i = s.data.length)), r = tf(e, r), s = tf(e, s), uf(r) && (r = Jm(r) ? r : r.parentNode, r = t.collapsed ? r.previousSibling || r : r.nextSibling || r, tr(r) && (a = t.collapsed ? r.length : 0)), uf(s) && (s = Jm(s) ? s : s.parentNode, s = t.collapsed ? s.nextSibling || s : s.previousSibling || s, tr(s) && (i = t.collapsed ? 0 : s.length)), t.collapsed) {
                            af(e, e.getRoot(), r, a, !0, o).each((({container: e, offset: t}) => {
                                r = e, a = t
                            }));
                            af(e, e.getRoot(), s, i, !1, o).each((({container: e, offset: t}) => {
                                s = e, i = t
                            }))
                        }
                        return (Km(l) || l.block_expand) && (Km(l) && tr(r) && 0 !== a || (r = cf(e, n, r, a, !0)), Km(l) && tr(s) && i !== s.data.length || (s = cf(e, n, s, i, !1))), Ym(l) && (r = sf(e, n, t, r, "previousSibling"), s = sf(e, n, t, s, "nextSibling")), (Vm(l) || Wm(l)) && (r = lf(e, n, r, "previousSibling"), s = lf(e, n, s, "nextSibling"), Vm(l) && (e.isBlock(r) || (r = cf(e, n, r, a, !0)), e.isBlock(s) || (s = cf(e, n, s, i, !1)))), Vo(r) && r.parentNode && (a = e.nodeIndex(r), r = r.parentNode), Vo(s) && s.parentNode && (i = e.nodeIndex(s) + 1, s = s.parentNode), {
                            startContainer: r,
                            startOffset: a,
                            endContainer: s,
                            endOffset: i
                        }
                    }, ff = (e, t, n) => {
                        var o;
                        const r = t.startOffset, a = Mi(t.startContainer, r), s = t.endOffset,
                            i = Mi(t.endContainer, s - 1), l = e => {
                                const t = e[0];
                                tr(t) && t === a && r >= t.data.length && e.splice(0, 1);
                                const n = e[e.length - 1];
                                return 0 === s && e.length > 0 && n === i && tr(n) && e.splice(e.length - 1, 1), e
                            }, d = (e, t, n) => {
                                const o = [];
                                for (; e && e !== n; e = e[t]) o.push(e);
                                return o
                            }, c = (t, n) => e.getParent(t, (e => e.parentNode === n), n), u = (e, t, o) => {
                                const r = o ? "nextSibling" : "previousSibling";
                                for (let a = e, s = a.parentNode; a && a !== t; a = s) {
                                    s = a.parentNode;
                                    const t = d(a === e ? a : a[r], r);
                                    t.length && (o || t.reverse(), n(l(t)))
                                }
                            };
                        if (a === i) return n(l([a]));
                        const m = null !== (o = e.findCommonAncestor(a, i)) && void 0 !== o ? o : e.getRoot();
                        if (e.isChildOf(a, i)) return u(a, m, !0);
                        if (e.isChildOf(i, a)) return u(i, m);
                        const f = c(a, m) || a, g = c(i, m) || i;
                        u(a, f, !0);
                        const p = d(f === a ? f : f.nextSibling, "nextSibling", g === i ? g.nextSibling : g);
                        p.length && n(l(p)), u(i, g)
                    },
                    gf = ['pre[class*=language-][contenteditable="false"]', "figure.image", "div[data-ephox-embed-iri]", "div.tiny-pageembed", "div.mce-toc", "div[data-mce-toc]"],
                    pf = (e, t, n, o) => Nn(t).fold((() => "skipping"), (r => "br" === o || (e => Gt(e) && Er(e) === Br)(t) ? "valid" : (e => Yt(e) && vn(e, di()))(t) ? "existing" : Ju(t.dom) ? "caret" : V(gf, (e => En(t, e))) ? "valid-block" : Bm(e, n, o) && Bm(e, $t(r), n) ? "valid" : "invalid-child")),
                    hf = (e, t, n, o, r, a) => {
                        const {uid: s = t, ...i} = n;
                        fn(e, di()), en(e, `${ui()}`, s), en(e, `${ci()}`, o);
                        const {attributes: l = {}, classes: d = []} = r(s, i);
                        if (tn(e, l), ((e, t) => {
                            K(t, (t => {
                                fn(e, t)
                            }))
                        })(e, d), a) {
                            d.length > 0 && en(e, `${fi()}`, d.join(","));
                            const t = ge(l);
                            t.length > 0 && en(e, `${gi()}`, t.join(","))
                        }
                    }, vf = e => {
                        pn(e, di()), an(e, `${ui()}`), an(e, `${ci()}`), an(e, `${mi()}`);
                        const t = on(e, `${gi()}`).map((e => e.split(","))).getOr([]),
                            n = on(e, `${fi()}`).map((e => e.split(","))).getOr([]);
                        var o;
                        K(t, (t => an(e, t))), o = e, K(n, (e => {
                            pn(o, e)
                        })), an(e, `${fi()}`), an(e, `${gi()}`)
                    }, bf = (e, t, n, o, r) => {
                        const a = yn.fromTag("span", e);
                        return hf(a, t, n, o, r, !1), a
                    }, yf = (e, t, n, o, r, a) => {
                        const s = [], i = bf(e.getDoc(), n, a, o, r), l = si(), d = () => {
                            l.clear()
                        }, c = e => {
                            K(e, u)
                        }, u = t => {
                            switch (pf(e, t, "span", $t(t))) {
                                case"invalid-child": {
                                    d();
                                    const e = Pn(t);
                                    c(e), d();
                                    break
                                }
                                case"valid-block":
                                    d(), hf(t, n, a, o, r, !0);
                                    break;
                                case"valid": {
                                    const e = l.get().getOrThunk((() => {
                                        const e = Si(i);
                                        return s.push(e), l.set(e), e
                                    }));
                                    yo(t, e);
                                    break
                                }
                            }
                        };
                        return ff(e.dom, t, (e => {
                            d(), (e => {
                                const t = W(e, yn.fromDom);
                                c(t)
                            })(e)
                        })), s
                    }, Cf = (e, t, n, o) => {
                        e.undoManager.transact((() => {
                            const r = e.selection, a = r.getRng(), s = ym(e).length > 0, i = wi("mce-annotation");
                            if (a.collapsed && !s && ((e, t) => {
                                const n = mf(e.dom, t, [{inline: "span"}]);
                                t.setStart(n.startContainer, n.startOffset), t.setEnd(n.endContainer, n.endOffset), e.selection.setRng(t)
                            })(e, a), r.getRng().collapsed && !s) {
                                const a = bf(e.getDoc(), i, o, t, n.decorate);
                                xo(a, br), r.getRng().insertNode(a.dom), r.select(a.dom)
                            } else Am(r, !1, (() => {
                                xm(e, (r => {
                                    yf(e, r, i, t, n.decorate, o)
                                }))
                            }))
                        }))
                    }, Ef = e => {
                        const t = (() => {
                            const e = {};
                            return {
                                register: (t, n) => {
                                    e[t] = {name: t, settings: n}
                                }, lookup: t => Se(e, t).map((e => e.settings)), getNames: () => ge(e)
                            }
                        })();
                        ((e, t) => {
                            const n = ci(), o = e => U.from(e.attr(n)).bind(t.lookup), r = e => {
                                var t, n;
                                e.attr(ui(), null), e.attr(ci(), null), e.attr(mi(), null);
                                const o = U.from(e.attr(gi())).map((e => e.split(","))).getOr([]),
                                    r = U.from(e.attr(fi())).map((e => e.split(","))).getOr([]);
                                K(o, (t => e.attr(t, null)));
                                const a = null !== (n = null === (t = e.attr("class")) || void 0 === t ? void 0 : t.split(" ")) && void 0 !== n ? n : [],
                                    s = se(a, [di()].concat(r));
                                e.attr("class", s.length > 0 ? s.join(" ") : null), e.attr(fi(), null), e.attr(gi(), null)
                            };
                            e.serializer.addTempAttr(mi()), e.serializer.addAttributeFilter(n, (e => {
                                for (const t of e) o(t).each((e => {
                                    !1 === e.persistent && ("span" === t.name ? t.unwrap() : r(t))
                                }))
                            }))
                        })(e, t);
                        const n = Ci(e, t), o = Qt("span"), r = e => {
                            K(e, (e => {
                                o(e) ? _o(e) : vf(e)
                            }))
                        };
                        return {
                            register: (e, n) => {
                                t.register(e, n)
                            }, annotate: (n, o) => {
                                t.lookup(n).each((t => {
                                    Cf(e, n, t, o)
                                }))
                            }, annotationChanged: (e, t) => {
                                n.addListener(e, t)
                            }, remove: t => {
                                hi(e, U.some(t)).each((({elements: t}) => {
                                    const n = e.selection.getBookmark();
                                    r(t), e.selection.moveToBookmark(n)
                                }))
                            }, removeAll: t => {
                                const n = e.selection.getBookmark();
                                he(yi(e, t), ((e, t) => {
                                    r(e)
                                })), e.selection.moveToBookmark(n)
                            }, getAll: t => {
                                const n = yi(e, t);
                                return ve(n, (e => W(e, (e => e.dom))))
                            }
                        }
                    }, wf = e => ({getBookmark: L(dm, e), moveToBookmark: L(cm, e)});
                wf.isBookmarkNode = um;
                const _f = (e, t, n) => !n.collapsed && V(n.getClientRects(), (n => ((e, t, n) => t >= e.left && t <= e.right && n >= e.top && n <= e.bottom)(n, e, t))),
                    Sf = (e, t, n) => {
                        e.dispatch(t, n)
                    }, kf = (e, t, n, o) => {
                        e.dispatch("FormatApply", {format: t, node: n, vars: o})
                    }, xf = (e, t, n, o) => {
                        e.dispatch("FormatRemove", {format: t, node: n, vars: o})
                    }, Af = (e, t) => e.dispatch("SetContent", t), Nf = (e, t) => e.dispatch("GetContent", t),
                    Tf = (e, t) => e.dispatch("PastePlainTextToggle", {state: t}), Rf = {
                        BACKSPACE: 8,
                        DELETE: 46,
                        DOWN: 40,
                        ENTER: 13,
                        ESC: 27,
                        LEFT: 37,
                        RIGHT: 39,
                        SPACEBAR: 32,
                        TAB: 9,
                        UP: 38,
                        PAGE_UP: 33,
                        PAGE_DOWN: 34,
                        END: 35,
                        HOME: 36,
                        modifierPressed: e => e.shiftKey || e.ctrlKey || e.altKey || Rf.metaKeyPressed(e),
                        metaKeyPressed: e => Rt.os.isMacOS() || Rt.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
                    }, Df = "data-mce-selected", Lf = Math.abs, Of = Math.round,
                    Bf = {nw: [0, 0, -1, -1], ne: [1, 0, 1, -1], se: [1, 1, 1, 1], sw: [0, 1, -1, 1]}, Pf = (e, t) => {
                        const n = t.dom, o = t.getDoc(), r = document, a = t.getBody();
                        let s, i, l, d, c, u, m, f, g, p, h, v, b, y, C;
                        const E = e => w(e) && (lr(e) || n.is(e, "figure.image")),
                            _ = e => fr(e) || n.hasClass(e, "mce-preview-object"), S = e => {
                                const n = e.target;
                                ((e, t) => {
                                    if ((e => "longpress" === e.type || 0 === e.type.indexOf("touch"))(e)) {
                                        const n = e.touches[0];
                                        return E(e.target) && !_f(n.clientX, n.clientY, t)
                                    }
                                    return E(e.target) && !_f(e.clientX, e.clientY, t)
                                })(e, t.selection.getRng()) && !e.isDefaultPrevented() && t.selection.select(n)
                            },
                            k = e => n.hasClass(e, "mce-preview-object") && w(e.firstElementChild) ? [e, e.firstElementChild] : n.is(e, "figure.image") ? [e.querySelector("img")] : [e],
                            x = e => {
                                const o = Sd(t);
                                return !!o && ("false" !== e.getAttribute("data-mce-resize") && (e !== t.getBody() && (n.hasClass(e, "mce-preview-object") && w(e.firstElementChild) ? En(yn.fromDom(e.firstElementChild), o) : En(yn.fromDom(e), o))))
                            }, A = (e, o, r) => {
                                if (w(r)) {
                                    const a = k(e);
                                    K(a, (e => {
                                        e.style[o] || !t.schema.isValid(e.nodeName.toLowerCase(), o) ? n.setStyle(e, o, r) : n.setAttrib(e, o, "" + r)
                                    }))
                                }
                            }, N = (e, t, n) => {
                                A(e, "width", t), A(e, "height", n)
                            }, T = e => {
                                let o, r, c, w, S;
                                o = e.screenX - u, r = e.screenY - m, v = o * d[2] + f, b = r * d[3] + g, v = v < 5 ? 5 : v, b = b < 5 ? 5 : b, c = (E(s) || _(s)) && !1 !== kd(t) ? !Rf.modifierPressed(e) : Rf.modifierPressed(e), c && (Lf(o) > Lf(r) ? (b = Of(v * p), v = Of(b / p)) : (v = Of(b / p), b = Of(v * p))), N(i, v, b), w = d.startPos.x + o, S = d.startPos.y + r, w = w > 0 ? w : 0, S = S > 0 ? S : 0, n.setStyles(l, {
                                    left: w,
                                    top: S,
                                    display: "block"
                                }), l.innerHTML = v + " &times; " + b, d[2] < 0 && i.clientWidth <= v && n.setStyle(i, "left", undefined + (f - v)), d[3] < 0 && i.clientHeight <= b && n.setStyle(i, "top", undefined + (g - b)), o = a.scrollWidth - y, r = a.scrollHeight - C, o + r !== 0 && n.setStyles(l, {
                                    left: w - o,
                                    top: S - r
                                }), h || (((e, t, n, o, r) => {
                                    e.dispatch("ObjectResizeStart", {target: t, width: n, height: o, origin: r})
                                })(t, s, f, g, "corner-" + d.name), h = !0)
                            }, R = () => {
                                const e = h;
                                h = !1, e && (A(s, "width", v), A(s, "height", b)), n.unbind(o, "mousemove", T), n.unbind(o, "mouseup", R), r !== o && (n.unbind(r, "mousemove", T), n.unbind(r, "mouseup", R)), n.remove(i), n.remove(l), n.remove(c), D(s), e && (((e, t, n, o, r) => {
                                    e.dispatch("ObjectResized", {target: t, width: n, height: o, origin: r})
                                })(t, s, v, b, "corner-" + d.name), n.setAttrib(s, "style", n.getAttrib(s, "style"))), t.nodeChanged()
                            }, D = e => {
                                I();
                                const h = n.getPos(e, a), E = h.x, w = h.y, S = e.getBoundingClientRect(),
                                    A = S.width || S.right - S.left, D = S.height || S.bottom - S.top;
                                s !== e && (O(), s = e, v = b = 0);
                                const L = t.dispatch("ObjectSelected", {target: e});
                                x(e) && !L.isDefaultPrevented() ? he(Bf, ((e, t) => {
                                    const h = h => {
                                        const v = k(s)[0];
                                        var b;
                                        u = h.screenX, m = h.screenY, f = v.clientWidth, g = v.clientHeight, p = g / f, d = e, d.name = t, d.startPos = {
                                            x: A * e[0] + E,
                                            y: D * e[1] + w
                                        }, y = a.scrollWidth, C = a.scrollHeight, c = n.add(a, "div", {
                                            class: "mce-resize-backdrop",
                                            "data-mce-bogus": "all"
                                        }), n.setStyles(c, {
                                            position: "fixed",
                                            left: "0",
                                            top: "0",
                                            width: "100%",
                                            height: "100%"
                                        }), i = _(b = s) ? n.create("img", {src: Rt.transparentSrc}) : b.cloneNode(!0), n.addClass(i, "mce-clonedresizable"), n.setAttrib(i, "data-mce-bogus", "all"), i.contentEditable = "false", n.setStyles(i, {
                                            left: E,
                                            top: w,
                                            margin: 0
                                        }), N(i, A, D), i.removeAttribute(Df), a.appendChild(i), n.bind(o, "mousemove", T), n.bind(o, "mouseup", R), r !== o && (n.bind(r, "mousemove", T), n.bind(r, "mouseup", R)), l = n.add(a, "div", {
                                            class: "mce-resize-helper",
                                            "data-mce-bogus": "all"
                                        }, f + " &times; " + g)
                                    };
                                    let v = n.get("mceResizeHandle" + t);
                                    v && n.remove(v), v = n.add(a, "div", {
                                        id: "mceResizeHandle" + t,
                                        "data-mce-bogus": "all",
                                        class: "mce-resizehandle",
                                        unselectable: !0,
                                        style: "cursor:" + t + "-resize; margin:0; padding:0"
                                    }), n.bind(v, "mousedown", (e => {
                                        e.stopImmediatePropagation(), e.preventDefault(), h(e)
                                    })), e.elm = v, n.setStyles(v, {
                                        left: A * e[0] + E - v.offsetWidth / 2,
                                        top: D * e[1] + w - v.offsetHeight / 2
                                    })
                                })) : O(!1)
                            }, L = ii(D, 0), O = (e = !0) => {
                                L.cancel(), I(), s && e && s.removeAttribute(Df), he(Bf, ((e, t) => {
                                    const o = n.get("mceResizeHandle" + t);
                                    o && (n.unbind(o), n.remove(o))
                                }))
                            }, B = (e, t) => n.isChildOf(e, t), P = o => {
                                if (h || t.removed || t.composing) return;
                                const r = "mousedown" === o.type ? o.target : e.getNode(),
                                    s = no(yn.fromDom(r), "table,img,figure.image,hr,video,span.mce-preview-object,details").map((e => e.dom)).filter((e => n.isEditable(e.parentElement) || "IMG" === e.nodeName && n.isEditable(e))).getOrUndefined(),
                                    i = w(s) ? n.getAttrib(s, Df, "1") : "1";
                                if (K(n.select(`img[${Df}],hr[${Df}]`), (e => {
                                    e.removeAttribute(Df)
                                })), w(s) && B(s, a) && t.hasFocus()) {
                                    M();
                                    const t = e.getStart(!0);
                                    if (B(t, s) && B(e.getEnd(!0), s)) return n.setAttrib(s, Df, i), void L.throttle(s)
                                }
                                O()
                            }, I = () => {
                                he(Bf, (e => {
                                    e.elm && (n.unbind(e.elm), delete e.elm)
                                }))
                            }, M = () => {
                                try {
                                    t.getDoc().execCommand("enableObjectResizing", !1, "false")
                                } catch (e) {
                                }
                            };
                        t.on("init", (() => {
                            M(), t.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", P), t.on("keyup compositionend", (e => {
                                s && "TABLE" === s.nodeName && P(e)
                            })), t.on("hide blur", O), t.on("contextmenu longpress", S, !0)
                        })), t.on("remove", I);
                        return {
                            isResizable: x, showResizeRect: D, hideResizeRect: O, updateResizeRect: P, destroy: () => {
                                L.cancel(), s = i = c = null
                            }
                        }
                    }, If = (e, t, n) => {
                        const o = e.document.createRange();
                        var r;
                        return r = o, t.fold((e => {
                            r.setStartBefore(e.dom)
                        }), ((e, t) => {
                            r.setStart(e.dom, t)
                        }), (e => {
                            r.setStartAfter(e.dom)
                        })), ((e, t) => {
                            t.fold((t => {
                                e.setEndBefore(t.dom)
                            }), ((t, n) => {
                                e.setEnd(t.dom, n)
                            }), (t => {
                                e.setEndAfter(t.dom)
                            }))
                        })(o, n), o
                    }, Mf = (e, t, n, o, r) => {
                        const a = e.document.createRange();
                        return a.setStart(t.dom, n), a.setEnd(o.dom, r), a
                    },
                    Ff = Rl([{ltr: ["start", "soffset", "finish", "foffset"]}, {rtl: ["start", "soffset", "finish", "foffset"]}]),
                    Uf = (e, t, n) => t(yn.fromDom(n.startContainer), n.startOffset, yn.fromDom(n.endContainer), n.endOffset),
                    qf = (e, t) => {
                        const n = ((e, t) => t.match({
                            domRange: e => ({ltr: T(e), rtl: U.none}),
                            relative: (t, n) => ({ltr: Ie((() => If(e, t, n))), rtl: Ie((() => U.some(If(e, n, t))))}),
                            exact: (t, n, o, r) => ({
                                ltr: Ie((() => Mf(e, t, n, o, r))),
                                rtl: Ie((() => U.some(Mf(e, o, r, t, n))))
                            })
                        }))(e, t);
                        return ((e, t) => {
                            const n = t.ltr();
                            if (n.collapsed) return t.rtl().filter((e => !1 === e.collapsed)).map((e => Ff.rtl(yn.fromDom(e.endContainer), e.endOffset, yn.fromDom(e.startContainer), e.startOffset))).getOrThunk((() => Uf(0, Ff.ltr, n)));
                            return Uf(0, Ff.ltr, n)
                        })(0, n)
                    };
                Ff.ltr, Ff.rtl;
                const jf = (e, t, n, o) => ({start: e, soffset: t, finish: n, foffset: o}), Hf = (e, t, n) => {
                        var o, r;
                        return U.from(null === (r = (o = e.dom).caretPositionFromPoint) || void 0 === r ? void 0 : r.call(o, t, n)).bind((t => {
                            if (null === t.offsetNode) return U.none();
                            const n = e.dom.createRange();
                            return n.setStart(t.offsetNode, t.offset), n.collapse(), U.some(n)
                        }))
                    }, zf = (e, t, n) => {
                        var o, r;
                        return U.from(null === (r = (o = e.dom).caretRangeFromPoint) || void 0 === r ? void 0 : r.call(o, t, n))
                    }, $f = document.caretPositionFromPoint ? Hf : document.caretRangeFromPoint ? zf : U.none,
                    Vf = Rl([{before: ["element"]}, {on: ["element", "offset"]}, {after: ["element"]}]), Wf = {
                        before: Vf.before,
                        on: Vf.on,
                        after: Vf.after,
                        cata: (e, t, n, o) => e.fold(t, n, o),
                        getStart: e => e.fold(R, R, R)
                    },
                    Kf = Rl([{domRange: ["rng"]}, {relative: ["startSitu", "finishSitu"]}, {exact: ["start", "soffset", "finish", "foffset"]}]),
                    Yf = {
                        domRange: Kf.domRange,
                        relative: Kf.relative,
                        exact: Kf.exact,
                        exactFromRange: e => Kf.exact(e.start, e.soffset, e.finish, e.foffset),
                        getWin: e => {
                            const t = (e => e.match({
                                domRange: e => yn.fromDom(e.startContainer),
                                relative: (e, t) => Wf.getStart(e),
                                exact: (e, t, n, o) => e
                            }))(e);
                            return An(t)
                        },
                        range: jf
                    }, Gf = (e, t) => {
                        const n = $t(e);
                        return "input" === n ? Wf.after(e) : $(["br", "img"], n) ? 0 === t ? Wf.before(e) : Wf.after(e) : Wf.on(e, t)
                    }, Xf = (e, t) => {
                        const n = e.fold(Wf.before, Gf, Wf.after), o = t.fold(Wf.before, Gf, Wf.after);
                        return Yf.relative(n, o)
                    }, Jf = (e, t, n, o) => {
                        const r = Gf(e, t), a = Gf(n, o);
                        return Yf.relative(r, a)
                    }, Qf = (e, t) => {
                        const n = (t || document).createDocumentFragment();
                        return K(e, (e => {
                            n.appendChild(e.dom)
                        })), yn.fromDom(n)
                    }, Zf = e => {
                        const t = Yf.getWin(e).dom, n = (e, n, o, r) => Mf(t, e, n, o, r), o = (e => e.match({
                            domRange: e => {
                                const t = yn.fromDom(e.startContainer), n = yn.fromDom(e.endContainer);
                                return Jf(t, e.startOffset, n, e.endOffset)
                            }, relative: Xf, exact: Jf
                        }))(e);
                        return qf(t, o).match({ltr: n, rtl: n})
                    }, eg = (e, t, n) => ((e, t, n) => {
                        const o = yn.fromDom(e.document);
                        return $f(o, t, n).map((e => jf(yn.fromDom(e.startContainer), e.startOffset, yn.fromDom(e.endContainer), e.endOffset)))
                    })(e, t, n), tg = (e, t, n) => {
                        const o = An(yn.fromDom(n));
                        return eg(o.dom, e, t).map((e => {
                            const t = n.createRange();
                            return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), t
                        })).getOrUndefined()
                    },
                    ng = (e, t) => w(e) && w(t) && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset,
                    og = (e, t, n) => null !== ((e, t, n) => {
                        let o = e;
                        for (; o && o !== t;) {
                            if (n(o)) return o;
                            o = o.parentNode
                        }
                        return null
                    })(e, t, n), rg = (e, t, n) => og(e, t, (e => e.nodeName === n)),
                    ag = (e, t) => jr(e) && !og(e, t, Ju), sg = (e, t, n) => {
                        const o = t.parentNode;
                        if (o) {
                            const r = new Ho(t, e.getParent(o, e.isBlock) || e.getRoot());
                            let a;
                            for (; a = r[n ? "prev" : "next"]();) if (ir(a)) return !0
                        }
                        return !1
                    }, ig = (e, t, n, o, r) => {
                        const a = e.getRoot(), s = e.schema.getNonEmptyElements(), i = r.parentNode;
                        let l, d;
                        if (!i) return U.none();
                        const c = e.getParent(i, e.isBlock) || a;
                        if (o && ir(r) && t && e.isEmpty(c)) return U.some(rl(i, e.nodeIndex(r)));
                        const u = new Ho(r, c);
                        for (; d = u[o ? "prev" : "next"]();) {
                            if ("false" === e.getContentEditableParent(d) || ag(d, a)) return U.none();
                            if (tr(d) && d.data.length > 0) return rg(d, a, "A") ? U.none() : U.some(rl(d, o ? d.data.length : 0));
                            if (e.isBlock(d) || s[d.nodeName.toLowerCase()]) return U.none();
                            l = d
                        }
                        return rr(l) ? U.none() : n && l ? U.some(rl(l, 0)) : U.none()
                    }, lg = (e, t, n, o) => {
                        const r = e.getRoot();
                        let a, s = !1, i = n ? o.startContainer : o.endContainer, l = n ? o.startOffset : o.endOffset;
                        const d = Vo(i) && l === i.childNodes.length, c = e.schema.getNonEmptyElements();
                        let u = n;
                        if (jr(i)) return U.none();
                        if (Vo(i) && l > i.childNodes.length - 1 && (u = !1), ar(i) && (i = r, l = 0), i === r) {
                            if (u && (a = i.childNodes[l > 0 ? l - 1 : 0], a)) {
                                if (jr(a)) return U.none();
                                if (c[a.nodeName] || Qo(a)) return U.none()
                            }
                            if (i.hasChildNodes()) {
                                if (l = Math.min(!u && l > 0 ? l - 1 : l, i.childNodes.length - 1), i = i.childNodes[l], l = tr(i) && d ? i.data.length : 0, !t && i === r.lastChild && Qo(i)) return U.none();
                                if (((e, t) => {
                                    let n = t;
                                    for (; n && n !== e;) {
                                        if (cr(n)) return !0;
                                        n = n.parentNode
                                    }
                                    return !1
                                })(r, i) || jr(i)) return U.none();
                                if (pr(i)) return U.none();
                                if (i.hasChildNodes() && !Qo(i)) {
                                    a = i;
                                    const t = new Ho(i, r);
                                    do {
                                        if (cr(a) || jr(a)) {
                                            s = !1;
                                            break
                                        }
                                        if (tr(a) && a.data.length > 0) {
                                            l = u ? 0 : a.data.length, i = a, s = !0;
                                            break
                                        }
                                        if (c[a.nodeName.toLowerCase()] && !mr(a)) {
                                            l = e.nodeIndex(a), i = a.parentNode, u || l++, s = !0;
                                            break
                                        }
                                    } while (a = u ? t.next() : t.prev())
                                }
                            }
                        }
                        return t && (tr(i) && 0 === l && ig(e, d, t, !0, i).each((e => {
                            i = e.container(), l = e.offset(), s = !0
                        })), Vo(i) && (a = i.childNodes[l], a || (a = i.childNodes[l - 1]), !a || !ir(a) || ((e, t) => {
                            var n;
                            return (null === (n = e.previousSibling) || void 0 === n ? void 0 : n.nodeName) === t
                        })(a, "A") || sg(e, a, !1) || sg(e, a, !0) || ig(e, d, t, !0, a).each((e => {
                            i = e.container(), l = e.offset(), s = !0
                        })))), u && !t && tr(i) && l === i.data.length && ig(e, d, t, !1, i).each((e => {
                            i = e.container(), l = e.offset(), s = !0
                        })), s && i ? U.some(rl(i, l)) : U.none()
                    }, dg = (e, t) => {
                        const n = t.collapsed, o = t.cloneRange(), r = rl.fromRangeStart(t);
                        return lg(e, n, !0, o).each((e => {
                            n && rl.isAbove(r, e) || o.setStart(e.container(), e.offset())
                        })), n || lg(e, n, !1, o).each((e => {
                            o.setEnd(e.container(), e.offset())
                        })), n && o.collapse(!0), ng(t, o) ? U.none() : U.some(o)
                    }, cg = (e, t) => e.splitText(t), ug = e => {
                        let t = e.startContainer, n = e.startOffset, o = e.endContainer, r = e.endOffset;
                        if (t === o && tr(t)) {
                            if (n > 0 && n < t.data.length) if (o = cg(t, n), t = o.previousSibling, r > n) {
                                r -= n;
                                const e = cg(o, r).previousSibling;
                                t = o = e, r = e.data.length, n = 0
                            } else r = 0
                        } else if (tr(t) && n > 0 && n < t.data.length && (t = cg(t, n), n = 0), tr(o) && r > 0 && r < o.data.length) {
                            const e = cg(o, r).previousSibling;
                            o = e, r = e.data.length
                        }
                        return {startContainer: t, startOffset: n, endContainer: o, endOffset: r}
                    }, mg = e => ({
                        walk: (t, n) => ff(e, t, n),
                        split: ug,
                        expand: (t, n = {type: "word"}) => {
                            if ("word" === n.type) {
                                const n = mf(e, t, [{inline: "span"}]), o = e.createRng();
                                return o.setStart(n.startContainer, n.startOffset), o.setEnd(n.endContainer, n.endOffset), o
                            }
                            return t
                        },
                        normalize: t => dg(e, t).fold(M, (e => (t.setStart(e.startContainer, e.startOffset), t.setEnd(e.endContainer, e.endOffset), !0)))
                    });
                mg.compareRanges = ng, mg.getCaretRangeFromPoint = tg, mg.getSelectedNode = Ii, mg.getNode = Mi;
                const fg = ((e, t) => {
                    const n = n => {
                        const o = t(n);
                        if (o <= 0 || null === o) {
                            const t = co(n, e);
                            return parseFloat(t) || 0
                        }
                        return o
                    }, o = (e, t) => Q(t, ((t, n) => {
                        const o = co(e, n), r = void 0 === o ? 0 : parseInt(o, 10);
                        return isNaN(r) ? t : t + r
                    }), 0);
                    return {
                        set: (t, n) => {
                            if (!S(n) && !n.match(/^[0-9]+$/)) throw new Error(e + ".set accepts only positive integer values. Value was " + n);
                            const o = t.dom;
                            ao(o) && (o.style[e] = n + "px")
                        }, get: n, getOuter: n, aggregate: o, max: (e, t, n) => {
                            const r = o(e, n);
                            return t > r ? t - r : 0
                        }
                    }
                })("height", (e => {
                    const t = e.dom;
                    return Yn(e) ? t.getBoundingClientRect().height : t.offsetHeight
                })), gg = () => yn.fromDom(document), pg = (e, t) => e.view(t).fold(T([]), (t => {
                    const n = e.owner(t), o = pg(e, n);
                    return [t].concat(o)
                }));
                var hg = Object.freeze({
                    __proto__: null, view: e => {
                        var t;
                        return (e.dom === document ? U.none() : U.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(yn.fromDom)
                    }, owner: e => xn(e)
                });
                const vg = e => {
                        const t = gg(), n = Bo(t), o = ((e, t) => {
                            const n = t.owner(e);
                            return pg(t, n)
                        })(e, hg), r = Oo(e), a = J(o, ((e, t) => {
                            const n = Oo(t);
                            return {left: e.left + n.left, top: e.top + n.top}
                        }), {left: 0, top: 0});
                        return Do(a.left + r.left + n.left, a.top + r.top + n.top)
                    }, bg = e => "textarea" === $t(e), yg = (e, t) => {
                        const n = (e => {
                            const t = e.dom.ownerDocument, n = t.body, o = t.defaultView, r = t.documentElement;
                            if (n === e.dom) return Do(n.offsetLeft, n.offsetTop);
                            const a = Lo(null == o ? void 0 : o.pageYOffset, r.scrollTop),
                                s = Lo(null == o ? void 0 : o.pageXOffset, r.scrollLeft), i = Lo(r.clientTop, n.clientTop),
                                l = Lo(r.clientLeft, n.clientLeft);
                            return Oo(e).translate(s - l, a - i)
                        })(e), o = (e => fg.get(e))(e);
                        return {element: e, bottom: n.top + o, height: o, pos: n, cleanup: t}
                    }, Cg = (e, t) => {
                        const n = ((e, t) => {
                                const n = Pn(e);
                                if (0 === n.length || bg(e)) return {element: e, offset: t};
                                if (t < n.length && !bg(n[t])) return {element: n[t], offset: 0};
                                {
                                    const o = n[n.length - 1];
                                    return bg(o) ? {element: e, offset: t} : "img" === $t(o) ? {
                                        element: o,
                                        offset: 1
                                    } : Gt(o) ? {element: o, offset: Er(o).length} : {element: o, offset: Pn(o).length}
                                }
                            })(e, t),
                            o = yn.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">\ufeff</span>');
                        return po(n.element, o), yg(o, (() => wo(o)))
                    }, Eg = (e, t, n, o) => {
                        kg(e, ((r, a) => _g(e, t, n, o)), n)
                    }, wg = (e, t, n, o, r) => {
                        const a = {elm: o.element.dom, alignToTop: r};
                        if (((e, t) => e.dispatch("ScrollIntoView", t).isDefaultPrevented())(e, a)) return;
                        n(e, t, Bo(t).top, o, r), ((e, t) => {
                            e.dispatch("AfterScrollIntoView", t)
                        })(e, a)
                    }, _g = (e, t, n, o) => {
                        const r = yn.fromDom(e.getBody()), a = yn.fromDom(e.getDoc());
                        r.dom.offsetWidth;
                        const s = Cg(yn.fromDom(n.startContainer), n.startOffset);
                        wg(e, a, t, s, o), s.cleanup()
                    }, Sg = (e, t, n, o) => {
                        const r = yn.fromDom(e.getDoc());
                        wg(e, r, n, (e => yg(yn.fromDom(e), x))(t), o)
                    }, kg = (e, t, n) => {
                        const o = n.startContainer, r = n.startOffset, a = n.endContainer, s = n.endOffset;
                        t(yn.fromDom(o), yn.fromDom(a));
                        const i = e.dom.createRng();
                        i.setStart(o, r), i.setEnd(a, s), e.selection.setRng(n)
                    }, xg = (e, t, n, o, r) => {
                        const a = t.pos;
                        if (o) Po(a.left, a.top, r); else {
                            const o = a.top - n + t.height;
                            Po(-e.getBody().getBoundingClientRect().left, o, r)
                        }
                    }, Ag = (e, t, n, o, r, a) => {
                        const s = o + n, i = r.pos.top, l = r.bottom, d = l - i >= o;
                        if (i < n) xg(e, r, o, !1 !== a, t); else if (i > s) {
                            xg(e, r, o, d ? !1 !== a : !0 === a, t)
                        } else l > s && !d && xg(e, r, o, !0 === a, t)
                    }, Ng = (e, t, n, o, r) => {
                        const a = An(t).dom.innerHeight;
                        Ag(e, t, n, a, o, r)
                    }, Tg = (e, t, n, o, r) => {
                        const a = An(t).dom.innerHeight;
                        Ag(e, t, n, a, o, r);
                        const s = vg(o.element), i = Fo(window);
                        s.top < i.y ? Io(o.element, !1 !== r) : s.top > i.bottom && Io(o.element, !0 === r)
                    }, Rg = (e, t, n) => Eg(e, Ng, t, n), Dg = (e, t, n) => Sg(e, t, Ng, n),
                    Lg = (e, t, n) => Eg(e, Tg, t, n), Og = (e, t, n) => Sg(e, t, Tg, n), Bg = (e, t, n) => {
                        (e.inline ? Rg : Lg)(e, t, n)
                    }, Pg = (e, t = !1) => e.dom.focus({preventScroll: t}), Ig = e => {
                        const t = zn(e).dom;
                        return e.dom === t.activeElement
                    }, Mg = (e = gg()) => U.from(e.dom.activeElement).map(yn.fromDom), Fg = (e, t) => {
                        const n = Gt(t) ? Er(t).length : Pn(t).length + 1;
                        return e > n ? n : e < 0 ? 0 : e
                    }, Ug = e => Yf.range(e.start, Fg(e.soffset, e.start), e.finish, Fg(e.foffset, e.finish)),
                    qg = (e, t) => !$o(t.dom) && (Sn(e, t) || _n(e, t)),
                    jg = e => t => qg(e, t.start) && qg(e, t.finish),
                    Hg = e => Yf.range(yn.fromDom(e.startContainer), e.startOffset, yn.fromDom(e.endContainer), e.endOffset),
                    zg = e => (e => {
                        const t = e.getSelection();
                        return (t && 0 !== t.rangeCount ? U.from(t.getRangeAt(0)) : U.none()).map(Hg)
                    })(An(e).dom).filter(jg(e)), $g = e => {
                        const t = document.createRange();
                        try {
                            return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), U.some(t)
                        } catch (e) {
                            return U.none()
                        }
                    }, Vg = e => {
                        const t = (e => e.inline || Rt.browser.isFirefox())(e) ? zg(yn.fromDom(e.getBody())) : U.none();
                        e.bookmark = t.isSome() ? t : e.bookmark
                    },
                    Wg = e => (e.bookmark ? e.bookmark : U.none()).bind((t => ((e, t) => U.from(t).filter(jg(e)).map(Ug))(yn.fromDom(e.getBody()), t))).bind($g),
                    Kg = {
                        isEditorUIElement: e => {
                            const t = e.className.toString();
                            return -1 !== t.indexOf("tox-") || -1 !== t.indexOf("mce-")
                        }
                    }, Yg = {
                        setEditorTimeout: (e, t, n) => ((e, t) => (S(t) || (t = 0), setTimeout(e, t)))((() => {
                            e.removed || t()
                        }), n), setEditorInterval: (e, t, n) => {
                            const o = ((e, t) => (S(t) || (t = 0), setInterval(e, t)))((() => {
                                e.removed ? clearInterval(o) : t()
                            }), n);
                            return o
                        }
                    }, Gg = e => {
                        const t = ii((() => {
                            Vg(e)
                        }), 0);
                        e.on("init", (() => {
                            e.inline && ((e, t) => {
                                const n = () => {
                                    t.throttle()
                                };
                                Xs.DOM.bind(document, "mouseup", n), e.on("remove", (() => {
                                    Xs.DOM.unbind(document, "mouseup", n)
                                }))
                            })(e, t), ((e, t) => {
                                ((e, t) => {
                                    e.on("mouseup touchend", (e => {
                                        t.throttle()
                                    }))
                                })(e, t), e.on("keyup NodeChange AfterSetSelectionRange", (t => {
                                    (e => "nodechange" === e.type && e.selectionChange)(t) || Vg(e)
                                }))
                            })(e, t)
                        })), e.on("remove", (() => {
                            t.cancel()
                        }))
                    };
                let Xg;
                const Jg = Xs.DOM, Qg = e => {
                        const t = e.classList;
                        return void 0 !== t && (t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body"))
                    }, Zg = (e, t) => {
                        const n = Fd(e),
                            o = Jg.getParent(t, (t => (e => Vo(e) && Kg.isEditorUIElement(e))(t) || !!n && e.dom.is(t, n)));
                        return null !== o
                    }, ep = e => {
                        try {
                            const t = zn(yn.fromDom(e.getElement()));
                            return Mg(t).fold((() => document.body), (e => e.dom))
                        } catch (e) {
                            return document.body
                        }
                    }, tp = (e, t) => {
                        const n = t.editor;
                        Gg(n);
                        const o = (e, t) => {
                            if (xc(e) && !0 !== e.inline) {
                                t(yn.fromDom(e.getContainer()), "tox-edit-focus")
                            }
                        };
                        n.on("focusin", (() => {
                            const t = e.focusedEditor;
                            Qg(ep(n)) && o(n, fn), t !== n && (t && t.dispatch("blur", {focusedEditor: n}), e.setActive(n), e.focusedEditor = n, n.dispatch("focus", {blurredEditor: t}), n.focus(!0))
                        })), n.on("focusout", (() => {
                            Yg.setEditorTimeout(n, (() => {
                                const t = e.focusedEditor;
                                Qg(ep(n)) && t === n || o(n, pn), Zg(n, ep(n)) || t !== n || (n.dispatch("blur", {focusedEditor: null}), e.focusedEditor = null)
                            }))
                        })), Xg || (Xg = t => {
                            const n = e.activeEditor;
                            n && Wn(t).each((t => {
                                const o = t;
                                o.ownerDocument === document && (o === document.body || Zg(n, o) || e.focusedEditor !== n || (n.dispatch("blur", {focusedEditor: null}), e.focusedEditor = null))
                            }))
                        }, Jg.bind(document, "focusin", Xg))
                    }, np = (e, t) => {
                        e.focusedEditor === t.editor && (e.focusedEditor = null), !e.activeEditor && Xg && (Jg.unbind(document, "focusin", Xg), Xg = null)
                    },
                    op = (e, t) => (e => e.collapsed ? U.from(Mi(e.startContainer, e.startOffset)).map(yn.fromDom) : U.none())(t).bind((t => Nr(t) ? U.some(t) : Sn(e, t) ? U.none() : U.some(e))),
                    rp = (e, t) => {
                        op(yn.fromDom(e.getBody()), t).bind((e => Yu(e.dom))).fold((() => {
                            e.selection.normalize()
                        }), (t => e.selection.setRng(t.toRange())))
                    }, ap = e => {
                        if (e.setActive) try {
                            e.setActive()
                        } catch (t) {
                            e.focus()
                        } else e.focus()
                    }, sp = e => {
                        return Ig(e) || (t = e, Mg(zn(t)).filter((e => t.dom.contains(e.dom)))).isSome();
                        var t
                    }, ip = e => e.inline ? (e => {
                        const t = e.getBody();
                        return t && sp(yn.fromDom(t))
                    })(e) : (e => w(e.iframeElement) && Ig(yn.fromDom(e.iframeElement)))(e), lp = e => ip(e) || (e => {
                        const t = zn(yn.fromDom(e.getElement()));
                        return Mg(t).filter((t => !Qg(t.dom) && Zg(e, t.dom))).isSome()
                    })(e), dp = e => e.editorManager.setActive(e), cp = (e, t) => {
                        e.removed || (t ? dp(e) : (e => {
                            const t = e.selection, n = e.getBody();
                            let o = t.getRng();
                            e.quirks.refreshContentEditable(), w(e.bookmark) && !ip(e) && Wg(e).each((t => {
                                e.selection.setRng(t), o = t
                            }));
                            const r = ((e, t) => e.dom.getParent(t, (t => "true" === e.dom.getContentEditable(t))))(e, t.getNode());
                            if (r && e.dom.isChildOf(r, n)) return ap(r), rp(e, o), void dp(e);
                            e.inline || (Rt.browser.isOpera() || ap(n), e.getWin().focus()), (Rt.browser.isFirefox() || e.inline) && (ap(n), rp(e, o)), dp(e)
                        })(e))
                    },
                    up = (e, t) => t.collapsed ? e.isEditable(t.startContainer) : e.isEditable(t.startContainer) && e.isEditable(t.endContainer),
                    mp = (e, t, n, o, r) => {
                        const a = n ? t.startContainer : t.endContainer, s = n ? t.startOffset : t.endOffset;
                        return U.from(a).map(yn.fromDom).map((e => o && t.collapsed ? e : In(e, r(e, s)).getOr(e))).bind((e => Yt(e) ? U.some(e) : Nn(e).filter(Yt))).map((e => e.dom)).getOr(e)
                    }, fp = (e, t, n = !1) => mp(e, t, !0, n, ((e, t) => Math.min(Un(e), t))),
                    gp = (e, t, n = !1) => mp(e, t, !1, n, ((e, t) => t > 0 ? t - 1 : t)), pp = (e, t) => {
                        const n = e;
                        for (; e && tr(e) && 0 === e.length;) e = t ? e.nextSibling : e.previousSibling;
                        return e || n
                    }, hp = (e, t) => W(t, (t => {
                        const n = e.dispatch("GetSelectionRange", {range: t});
                        return n.range !== t ? n.range : t
                    })), vp = ["img", "br"], bp = e => {
                        const t = wr(e).filter((e => 0 !== e.trim().length || e.indexOf(br) > -1)).isSome();
                        return t || $(vp, $t(e)) || (e => Kt(e) && "false" === nn(e, "contenteditable"))(e)
                    }, yp = (e, t) => {
                        const n = e => {
                            const o = Pn(e);
                            for (let e = o.length - 1; e >= 0; e--) {
                                const r = o[e];
                                if (t(r)) return U.some(r);
                                const a = n(r);
                                if (a.isSome()) return a
                            }
                            return U.none()
                        };
                        return n(e)
                    }, Cp = "[data-mce-autocompleter]", Ep = (e, t) => {
                        if (wp(yn.fromDom(e.getBody())).isNone()) {
                            const o = yn.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
                            bo(o, yn.fromDom(t.extractContents())), t.insertNode(o.dom), Nn(o).each((e => e.dom.normalize())), (n = o, yp(n, bp)).map((t => {
                                e.selection.setCursorLocation(t.dom, (e => "img" === $t(e) ? 1 : wr(e).fold((() => Pn(e).length), (e => e.length)))(t))
                            }))
                        }
                        var n
                    }, wp = e => to(e, Cp),
                    _p = {"#text": 3, "#comment": 8, "#cdata": 4, "#pi": 7, "#doctype": 10, "#document-fragment": 11},
                    Sp = (e, t, n) => {
                        const o = n ? "lastChild" : "firstChild", r = n ? "prev" : "next";
                        if (e[o]) return e[o];
                        if (e !== t) {
                            let n = e[r];
                            if (n) return n;
                            for (let o = e.parent; o && o !== t; o = o.parent) if (n = o[r], n) return n
                        }
                    }, kp = e => {
                        var t;
                        const n = null !== (t = e.value) && void 0 !== t ? t : "";
                        if (!ia(n)) return !1;
                        const o = e.parent;
                        return !o || "span" === o.name && !o.attr("style") || !/^[ ]+$/.test(n)
                    }, xp = e => {
                        const t = "a" === e.name && !e.attr("href") && e.attr("id");
                        return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t
                    };

                class Ap {
                    static create(e, t) {
                        const n = new Ap(e, _p[e] || 1);
                        return t && he(t, ((e, t) => {
                            n.attr(t, e)
                        })), n
                    }

                    constructor(e, t) {
                        this.name = e, this.type = t, 1 === t && (this.attributes = [], this.attributes.map = {})
                    }

                    replace(e) {
                        const t = this;
                        return e.parent && e.remove(), t.insert(e, t), t.remove(), t
                    }

                    attr(e, t) {
                        const n = this;
                        if (!g(e)) return w(e) && he(e, ((e, t) => {
                            n.attr(t, e)
                        })), n;
                        const o = n.attributes;
                        if (o) {
                            if (void 0 !== t) {
                                if (null === t) {
                                    if (e in o.map) {
                                        delete o.map[e];
                                        let t = o.length;
                                        for (; t--;) if (o[t].name === e) return o.splice(t, 1), n
                                    }
                                    return n
                                }
                                if (e in o.map) {
                                    let n = o.length;
                                    for (; n--;) if (o[n].name === e) {
                                        o[n].value = t;
                                        break
                                    }
                                } else o.push({name: e, value: t});
                                return o.map[e] = t, n
                            }
                            return o.map[e]
                        }
                    }

                    clone() {
                        const e = this, t = new Ap(e.name, e.type), n = e.attributes;
                        if (n) {
                            const e = [];
                            e.map = {};
                            for (let t = 0, o = n.length; t < o; t++) {
                                const o = n[t];
                                "id" !== o.name && (e[e.length] = {
                                    name: o.name,
                                    value: o.value
                                }, e.map[o.name] = o.value)
                            }
                            t.attributes = e
                        }
                        return t.value = e.value, t
                    }

                    wrap(e) {
                        const t = this;
                        return t.parent && (t.parent.insert(e, t), e.append(t)), t
                    }

                    unwrap() {
                        const e = this;
                        for (let t = e.firstChild; t;) {
                            const n = t.next;
                            e.insert(t, e, !0), t = n
                        }
                        e.remove()
                    }

                    remove() {
                        const e = this, t = e.parent, n = e.next, o = e.prev;
                        return t && (t.firstChild === e ? (t.firstChild = n, n && (n.prev = null)) : o && (o.next = n), t.lastChild === e ? (t.lastChild = o, o && (o.next = null)) : n && (n.prev = o), e.parent = e.next = e.prev = null), e
                    }

                    append(e) {
                        const t = this;
                        e.parent && e.remove();
                        const n = t.lastChild;
                        return n ? (n.next = e, e.prev = n, t.lastChild = e) : t.lastChild = t.firstChild = e, e.parent = t, e
                    }

                    insert(e, t, n) {
                        e.parent && e.remove();
                        const o = t.parent || this;
                        return n ? (t === o.firstChild ? o.firstChild = e : t.prev && (t.prev.next = e), e.prev = t.prev, e.next = t, t.prev = e) : (t === o.lastChild ? o.lastChild = e : t.next && (t.next.prev = e), e.next = t.next, e.prev = t, t.next = e), e.parent = o, e
                    }

                    getAll(e) {
                        const t = this, n = [];
                        for (let o = t.firstChild; o; o = Sp(o, t)) o.name === e && n.push(o);
                        return n
                    }

                    children() {
                        const e = [];
                        for (let t = this.firstChild; t; t = t.next) e.push(t);
                        return e
                    }

                    empty() {
                        const e = this;
                        if (e.firstChild) {
                            const t = [];
                            for (let n = e.firstChild; n; n = Sp(n, e)) t.push(n);
                            let n = t.length;
                            for (; n--;) {
                                const e = t[n];
                                e.parent = e.firstChild = e.lastChild = e.next = e.prev = null
                            }
                        }
                        return e.firstChild = e.lastChild = null, e
                    }

                    isEmpty(e, t = {}, n) {
                        var o;
                        const r = this;
                        let a = r.firstChild;
                        if (xp(r)) return !1;
                        if (a) do {
                            if (1 === a.type) {
                                if (a.attr("data-mce-bogus")) continue;
                                if (e[a.name]) return !1;
                                if (xp(a)) return !1
                            }
                            if (8 === a.type) return !1;
                            if (3 === a.type && !kp(a)) return !1;
                            if (3 === a.type && a.parent && t[a.parent.name] && ia(null !== (o = a.value) && void 0 !== o ? o : "")) return !1;
                            if (n && n(a)) return !1
                        } while (a = Sp(a, r));
                        return !0
                    }

                    walk(e) {
                        return Sp(this, null, e)
                    }
                }

                const Np = Bt.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "),
                    Tp = e => g(e.nodeValue) && e.nodeValue.includes(Br),
                    Rp = e => (0 === e.length ? "" : `${W(e, (e => `[${e}]`)).join(",")},`) + '[data-mce-bogus="all"]',
                    Dp = e => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (e => Tp(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP)),
                    Lp = e => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (e => {
                        if (Tp(e)) {
                            const t = e.parentNode;
                            return t && ke(Np, t.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
                        }
                        return NodeFilter.FILTER_SKIP
                    })), Op = e => null !== Dp(e).nextNode(), Bp = e => null !== Lp(e).nextNode(),
                    Pp = (e, t) => null !== t.querySelector(Rp(e)), Ip = (e, t) => {
                        K(((e, t) => t.querySelectorAll(Rp(e)))(e, t), (t => {
                            const n = yn.fromDom(t);
                            "all" === nn(n, "data-mce-bogus") ? wo(n) : K(e, (e => {
                                rn(n, e) && an(n, e)
                            }))
                        }))
                    }, Mp = e => {
                        let t = e.nextNode();
                        for (; null !== t;) t.nodeValue = null, t = e.nextNode()
                    }, Fp = A(Mp, Dp), Up = A(Mp, Lp), qp = (e, t) => {
                        const n = [{condition: L(Pp, t), action: L(Ip, t)}, {condition: Op, action: Fp}, {
                            condition: Bp,
                            action: Up
                        }];
                        let o = e, r = !1;
                        return K(n, (({condition: t, action: n}) => {
                            t(o) && (r || (o = e.cloneNode(!0), r = !0), n(o))
                        })), o
                    }, jp = e => {
                        const t = qo(e, "[data-mce-bogus]");
                        K(t, (e => {
                            "all" === nn(e, "data-mce-bogus") ? wo(e) : Sr(e) ? (po(e, yn.fromText(vr)), wo(e)) : _o(e)
                        }))
                    }, Hp = e => {
                        const t = qo(e, "input");
                        K(t, (e => {
                            an(e, "name")
                        }))
                    }, zp = (e, t) => {
                        const n = e.getDoc(), o = zn(yn.fromDom(e.getBody())), r = yn.fromTag("div", n);
                        en(r, "data-mce-bogus", "all"), lo(r, {
                            position: "fixed",
                            left: "-9999999px",
                            top: "0"
                        }), xo(r, t.innerHTML), jp(r), Hp(r);
                        const a = (e => qn(e) ? e : yn.fromDom(xn(e).dom.body))(o);
                        bo(a, r);
                        const s = Ir(r.dom.innerText);
                        return wo(r), s
                    }, $p = (e, t, n) => {
                        let o;
                        o = "raw" === t.format ? Bt.trim(Ir(qp(n, e.serializer.getTempAttrs()).innerHTML)) : "text" === t.format ? zp(e, n) : "tree" === t.format ? e.serializer.serialize(n, t) : ((e, t) => {
                            const n = Jl(e),
                                o = new RegExp(`^(<${n}[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/${n}>[\r\n]*|<br \\/>[\r\n]*)$`);
                            return t.replace(o, "")
                        })(e, e.serializer.serialize(n, t));
                        return "text" !== t.format && !Rr(yn.fromDom(n)) && g(o) ? Bt.trim(o) : o
                    }, Vp = Bt.makeMap, Wp = e => {
                        const t = [], n = (e = e || {}).indent, o = Vp(e.indent_before || ""), r = Vp(e.indent_after || ""),
                            a = is.getEncodeFunc(e.entity_encoding || "raw", e.entities), s = "xhtml" !== e.element_format;
                        return {
                            start: (e, i, l) => {
                                if (n && o[e] && t.length > 0) {
                                    const e = t[t.length - 1];
                                    e.length > 0 && "\n" !== e && t.push("\n")
                                }
                                if (t.push("<", e), i) for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    t.push(" ", n.name, '="', a(n.value, !0), '"')
                                }
                                if (t[t.length] = !l || s ? ">" : " />", l && n && r[e] && t.length > 0) {
                                    const e = t[t.length - 1];
                                    e.length > 0 && "\n" !== e && t.push("\n")
                                }
                            }, end: e => {
                                let o;
                                t.push("</", e, ">"), n && r[e] && t.length > 0 && (o = t[t.length - 1], o.length > 0 && "\n" !== o && t.push("\n"))
                            }, text: (e, n) => {
                                e.length > 0 && (t[t.length] = n ? e : a(e))
                            }, cdata: e => {
                                t.push("<![CDATA[", e, "]]>")
                            }, comment: e => {
                                t.push("\x3c!--", e, "--\x3e")
                            }, pi: (e, o) => {
                                o ? t.push("<?", e, " ", a(o), "?>") : t.push("<?", e, "?>"), n && t.push("\n")
                            }, doctype: e => {
                                t.push("<!DOCTYPE", e, ">", n ? "\n" : "")
                            }, reset: () => {
                                t.length = 0
                            }, getContent: () => t.join("").replace(/\n$/, "")
                        }
                    }, Kp = (e = {}, t = ys()) => {
                        const n = Wp(e);
                        e.validate = !("validate" in e) || e.validate;
                        return {
                            serialize: o => {
                                const r = e.validate, a = {
                                    3: e => {
                                        var t;
                                        n.text(null !== (t = e.value) && void 0 !== t ? t : "", e.raw)
                                    }, 8: e => {
                                        var t;
                                        n.comment(null !== (t = e.value) && void 0 !== t ? t : "")
                                    }, 7: e => {
                                        n.pi(e.name, e.value)
                                    }, 10: e => {
                                        var t;
                                        n.doctype(null !== (t = e.value) && void 0 !== t ? t : "")
                                    }, 4: e => {
                                        var t;
                                        n.cdata(null !== (t = e.value) && void 0 !== t ? t : "")
                                    }, 11: e => {
                                        let t = e;
                                        if (t = t.firstChild) do {
                                            s(t)
                                        } while (t = t.next)
                                    }
                                };
                                n.reset();
                                const s = e => {
                                    var o;
                                    const i = a[e.type];
                                    if (i) i(e); else {
                                        const a = e.name, i = a in t.getVoidElements();
                                        let l = e.attributes;
                                        if (r && l && l.length > 1) {
                                            const n = [];
                                            n.map = {};
                                            const o = t.getElementRule(e.name);
                                            if (o) {
                                                for (let e = 0, t = o.attributesOrder.length; e < t; e++) {
                                                    const t = o.attributesOrder[e];
                                                    if (t in l.map) {
                                                        const e = l.map[t];
                                                        n.map[t] = e, n.push({name: t, value: e})
                                                    }
                                                }
                                                for (let e = 0, t = l.length; e < t; e++) {
                                                    const t = l[e].name;
                                                    if (!(t in n.map)) {
                                                        const e = l.map[t];
                                                        n.map[t] = e, n.push({name: t, value: e})
                                                    }
                                                }
                                                l = n
                                            }
                                        }
                                        if (n.start(a, l, i), Ca(a)) g(e.value) && n.text(e.value, !0), n.end(a); else if (!i) {
                                            let t = e.firstChild;
                                            if (t) {
                                                "pre" !== a && "textarea" !== a || 3 !== t.type || "\n" !== (null === (o = t.value) || void 0 === o ? void 0 : o[0]) || n.text("\n", !0);
                                                do {
                                                    s(t)
                                                } while (t = t.next)
                                            }
                                            n.end(a)
                                        }
                                    }
                                };
                                return 1 !== o.type || e.inner ? 3 === o.type ? a[3](o) : a[11](o) : s(o), n.getContent()
                            }
                        }
                    }, Yp = new Set;
                K(["margin", "margin-left", "margin-right", "margin-top", "margin-bottom", "padding", "padding-left", "padding-right", "padding-top", "padding-bottom", "border", "border-width", "border-style", "border-color", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "float", "position", "left", "right", "top", "bottom", "z-index", "display", "transform", "width", "max-width", "min-width", "height", "max-height", "min-height", "overflow", "overflow-x", "overflow-y", "text-overflow", "vertical-align", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function"], (e => {
                    Yp.add(e)
                }));
                const Gp = ["font", "text-decoration", "text-emphasis"],
                    Xp = (e, t) => ge(e.parseStyle(e.getAttrib(t, "style"))),
                    Jp = (e, t) => re(Xp(e, t), (e => !(e => Yp.has(e))(e))), Qp = (e, t, n) => {
                        const o = Xp(e, t), r = Xp(e, n), a = o => {
                            var r, a;
                            const s = null !== (r = e.getStyle(t, o)) && void 0 !== r ? r : "",
                                i = null !== (a = e.getStyle(n, o)) && void 0 !== a ? a : "";
                            return Xe(s) && Xe(i) && s !== i
                        };
                        return V(o, (e => {
                            const t = t => V(t, (t => t === e));
                            if (!t(r) && t(Gp)) {
                                const e = X(r, (e => V(Gp, (t => $e(e, t)))));
                                return V(e, a)
                            }
                            return a(e)
                        }))
                    }, Zp = (e, t, n) => U.from(n.container()).filter(tr).exists((o => {
                        const r = e ? 0 : -1;
                        return t(o.data.charAt(n.offset() + r))
                    })), eh = L(Zp, !0, gm), th = L(Zp, !1, gm), nh = e => {
                        const t = e.container();
                        return tr(t) && (0 === t.data.length || Pr(t.data) && wf.isBookmarkNode(t.parentNode))
                    }, oh = (e, t) => n => gu(e ? 0 : -1, n).filter(t).isSome(),
                    rh = e => lr(e) && "block" === co(yn.fromDom(e), "display"),
                    ah = e => cr(e) && !(e => Vo(e) && "all" === e.getAttribute("data-mce-bogus"))(e), sh = oh(!0, rh),
                    ih = oh(!1, rh), lh = oh(!0, fr), dh = oh(!1, fr), ch = oh(!0, Qo), uh = oh(!1, Qo),
                    mh = oh(!0, ah), fh = oh(!1, ah),
                    gh = (e, t) => ((e, t, n) => Sn(t, e) ? Rn(e, (e => n(e) || _n(e, t))).slice(0, -1) : [])(e, t, M),
                    ph = (e, t) => [e].concat(gh(e, t)), hh = (e, t, n) => $u(e, t, n, nh),
                    vh = (e, t, n) => ee(ph(yn.fromDom(t.container()), e), (e => t => e.isBlock($t(t)))(n)),
                    bh = (e, t, n, o) => hh(e, t.dom, n).forall((e => vh(t, n, o).fold((() => !fu(e, n, t.dom)), (o => !fu(e, n, t.dom) && Sn(o, yn.fromDom(e.container())))))),
                    yh = (e, t, n, o) => vh(t, n, o).fold((() => hh(e, t.dom, n).forall((e => !fu(e, n, t.dom)))), (t => hh(e, t.dom, n).isNone())),
                    Ch = L(yh, !1), Eh = L(yh, !0), wh = L(bh, !1), _h = L(bh, !0), Sh = e => _u(e).exists(Sr),
                    kh = (e, t, n, o) => {
                        const r = X(ph(yn.fromDom(n.container()), t), (e => o.isBlock($t(e)))), a = ce(r).getOr(t);
                        return Hu(e, a.dom, n).filter(Sh)
                    }, xh = (e, t, n) => _u(t).exists(Sr) || kh(!0, e, t, n).isSome(),
                    Ah = (e, t, n) => (e => U.from(e.getNode(!0)).map(yn.fromDom))(t).exists(Sr) || kh(!1, e, t, n).isSome(),
                    Nh = L(kh, !1), Th = L(kh, !0), Rh = e => rl.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(),
                    Dh = (e, t, n) => {
                        const o = X(ph(yn.fromDom(t.container()), e), (e => n.isBlock($t(e))));
                        return ce(o).getOr(e)
                    }, Lh = (e, t, n) => Rh(t) ? th(t) : th(t) || Ku(Dh(e, t, n).dom, t).exists(th),
                    Oh = (e, t, n) => Rh(t) ? eh(t) : eh(t) || Wu(Dh(e, t, n).dom, t).exists(eh),
                    Bh = e => _u(e).bind((e => Jn(e, Yt))).exists((e => (e => $(["pre", "pre-wrap"], e))(co(e, "white-space")))),
                    Ph = (e, t, n) => ((e, t) => Ku(e.dom, t).isNone())(e, t) || ((e, t) => Wu(e.dom, t).isNone())(e, t) || Ch(e, t, n) || Eh(e, t, n) || Ah(e, t, n) || xh(e, t, n),
                    Ih = (e, t) => n => {
                        return o = new Ho(n, e)[t](), w(o) && cr(o) && nu(o);
                        var o
                    }, Mh = (e, t, n) => !Bh(t) && (Ph(e, t, n) || Lh(e, t, n) || Oh(e, t, n)),
                    Fh = (e, t, n) => !Bh(t) && (Ch(e, t, n) || wh(e, t, n) || Ah(e, t, n) || Lh(e, t, n) || ((e, t) => {
                        const n = Ku(e.dom, t).getOr(t), o = Ih(e.dom, "prev");
                        return t.isAtStart() && (o(t.container()) || o(n.container()))
                    })(e, t)),
                    Uh = (e, t, n) => !Bh(t) && (Eh(e, t, n) || _h(e, t, n) || xh(e, t, n) || Oh(e, t, n) || ((e, t) => {
                        const n = Wu(e.dom, t).getOr(t), o = Ih(e.dom, "next");
                        return t.isAtEnd() && (o(t.container()) || o(n.container()))
                    })(e, t)), qh = (e, t, n) => Fh(e, t, n) || Uh(e, (e => {
                        const t = e.container(), n = e.offset();
                        return tr(t) && n < t.data.length ? rl(t, n + 1) : e
                    })(t), n), jh = (e, t) => mm(e.charAt(t)), Hh = (e, t) => gm(e.charAt(t)), zh = (e, t, n, o) => {
                        const r = t.data, a = rl(t, 0);
                        return n || !jh(r, 0) || qh(e, a, o) ? !!(n && Hh(r, 0) && Fh(e, a, o)) && (t.data = br + r.slice(1), !0) : (t.data = " " + r.slice(1), !0)
                    }, $h = e => {
                        const t = e.data, n = (e => {
                            const t = e.split("");
                            return W(t, ((e, n) => mm(e) && n > 0 && n < t.length - 1 && pm(t[n - 1]) && pm(t[n + 1]) ? " " : e)).join("")
                        })(t);
                        return n !== t && (e.data = n, !0)
                    }, Vh = (e, t, n, o) => {
                        const r = t.data, a = rl(t, r.length - 1);
                        return n || !jh(r, r.length - 1) || qh(e, a, o) ? !!(n && Hh(r, r.length - 1) && Uh(e, a, o)) && (t.data = r.slice(0, -1) + br, !0) : (t.data = r.slice(0, -1) + " ", !0)
                    }, Wh = (e, t, n) => {
                        const o = t.container();
                        if (!tr(o)) return U.none();
                        if ((e => {
                            const t = e.container();
                            return tr(t) && ze(t.data, br)
                        })(t)) {
                            const r = zh(e, o, !1, n) || $h(o) || Vh(e, o, !1, n);
                            return Ft(r, t)
                        }
                        if (qh(e, t, n)) {
                            const r = zh(e, o, !0, n) || Vh(e, o, !0, n);
                            return Ft(r, t)
                        }
                        return U.none()
                    }, Kh = (e, t, n, o) => {
                        if (0 === n) return;
                        const r = yn.fromDom(e), a = Xn(r, (e => o.isBlock($t(e)))).getOr(r), s = e.data.slice(t, t + n),
                            i = t + n >= e.data.length && Uh(a, rl(e, e.data.length), o), l = 0 === t && Fh(a, rl(e, 0), o);
                        e.replaceData(t, n, ca(s, 4, l, i))
                    }, Yh = (e, t, n) => {
                        const o = e.data.slice(t), r = o.length - Ye(o).length;
                        Kh(e, t, r, n)
                    }, Gh = (e, t, n) => {
                        const o = e.data.slice(0, t), r = o.length - Ge(o).length;
                        Kh(e, t - r, r, n)
                    }, Xh = (e, t, n, o, r = !0) => {
                        const a = Ge(e.data).length, s = r ? e : t, i = r ? t : e;
                        return r ? s.appendData(i.data) : s.insertData(0, i.data), wo(yn.fromDom(i)), o && Yh(s, a, n), s
                    }, Jh = (e, t) => ((e, t) => {
                        const n = e.container(), o = e.offset();
                        return !rl.isTextPosition(e) && n === t.parentNode && o > rl.before(t).offset()
                    })(t, e) ? rl(t.container(), t.offset() - 1) : t, Qh = e => {
                        return oa(e.previousSibling) ? U.some((t = e.previousSibling, tr(t) ? rl(t, t.data.length) : rl.after(t))) : e.previousSibling ? Gu(e.previousSibling) : U.none();
                        var t
                    }, Zh = e => {
                        return oa(e.nextSibling) ? U.some((t = e.nextSibling, tr(t) ? rl(t, 0) : rl.before(t))) : e.nextSibling ? Yu(e.nextSibling) : U.none();
                        var t
                    },
                    ev = (e, t) => Qh(t).orThunk((() => Zh(t))).orThunk((() => ((e, t) => U.from(t.previousSibling ? t.previousSibling : t.parentNode).bind((t => Ku(e, rl.before(t)))).orThunk((() => Wu(e, rl.after(t)))))(e, t))),
                    tv = (e, t) => Zh(t).orThunk((() => Qh(t))).orThunk((() => ((e, t) => Wu(e, rl.after(t)).orThunk((() => Ku(e, rl.before(t)))))(e, t))),
                    nv = (e, t, n) => ((e, t, n) => e ? tv(t, n) : ev(t, n))(e, t, n).map(L(Jh, n)), ov = (e, t, n) => {
                        n.fold((() => {
                            e.focus()
                        }), (n => {
                            e.selection.setRng(n.toRange(), t)
                        }))
                    }, rv = (e, t) => t && ke(e.schema.getBlockElements(), $t(t)), av = (e, t, n, o) => {
                        const r = Dn(e).filter(Gt), a = Ln(e).filter(Gt);
                        return wo(e), (s = r, i = a, l = t, d = (e, t, r) => {
                            const a = e.dom, s = t.dom, i = a.data.length;
                            return Xh(a, s, n, o), r.container() === s ? rl(a, i) : r
                        }, s.isSome() && i.isSome() && l.isSome() ? U.some(d(s.getOrDie(), i.getOrDie(), l.getOrDie())) : U.none()).orThunk((() => (o && (r.each((e => Gh(e.dom, e.dom.length, n))), a.each((e => Yh(e.dom, 0, n)))), t)));
                        var s, i, l, d
                    }, sv = (e, t, n, o = !0, r = !1) => {
                        const a = nv(t, e.getBody(), n.dom), s = Xn(n, L(rv, e), (i = e.getBody(), e => e.dom === i));
                        var i;
                        const l = av(n, a, e.schema, ((e, t) => ke(e.schema.getTextInlineElements(), $t(t)))(e, n));
                        e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : s.bind((e => ((e, t) => {
                            if (ya(e)) {
                                const n = yn.fromHtml('<br data-mce-bogus="1">');
                                return t ? K(Pn(e), (e => {
                                    Xm(e) || wo(e)
                                })) : Eo(e), bo(e, n), U.some(rl.before(n.dom))
                            }
                            return U.none()
                        })(e, r))).fold((() => {
                            o && ov(e, t, l)
                        }), (n => {
                            o && ov(e, t, U.some(n))
                        }))
                    }, iv = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/,
                    lv = (e, t) => En(yn.fromDom(t), _d(e)) && !Pa(e.schema, t) && e.dom.isEditable(t), dv = e => {
                        var t;
                        return "rtl" === Xs.DOM.getStyle(e, "direction", !0) || (e => iv.test(e))(null !== (t = e.textContent) && void 0 !== t ? t : "")
                    }, cv = (e, t, n) => {
                        const o = ((e, t, n) => X(Xs.DOM.getParents(n.container(), "*", t), e))(e, t, n);
                        return U.from(o[o.length - 1])
                    }, uv = (e, t) => {
                        const n = t.container(), o = t.offset();
                        return e ? qr(n) ? tr(n.nextSibling) ? rl(n.nextSibling, 0) : rl.after(n) : zr(t) ? rl(n, o + 1) : t : qr(n) ? tr(n.previousSibling) ? rl(n.previousSibling, n.previousSibling.data.length) : rl.before(n) : $r(t) ? rl(n, o - 1) : t
                    }, mv = L(uv, !0), fv = L(uv, !1), gv = (e, t) => {
                        const n = e => e.stopImmediatePropagation();
                        e.on("beforeinput input", n, !0), e.getDoc().execCommand(t), e.off("beforeinput input", n)
                    }, pv = e => gv(e, "Delete"), hv = e => kr(e) || Ar(e),
                    vv = (e, t) => Sn(e, t) ? Jn(t, hv, (e => t => Pt(Nn(t), e, _n))(e)) : U.none(),
                    bv = (e, t = !0) => {
                        e.dom.isEmpty(e.getBody()) && e.setContent("", {no_selection: !t})
                    }, yv = (e, t, n) => Mt(Yu(n), Gu(n), ((o, r) => {
                        const a = uv(!0, o), s = uv(!1, r), i = uv(!1, t);
                        return e ? Wu(n, i).exists((e => e.isEqual(s) && t.isEqual(a))) : Ku(n, i).exists((e => e.isEqual(a) && t.isEqual(s)))
                    })).getOr(!0), Cv = e => {
                        var t;
                        return (8 === Vt(t = e) || "#comment" === $t(t) ? Dn(e) : Fn(e)).bind(Cv).orThunk((() => U.some(e)))
                    }, Ev = (e, t, n, o = !0) => {
                        var r;
                        t.deleteContents();
                        const a = Cv(n).getOr(n),
                            s = yn.fromDom(null !== (r = e.dom.getParent(a.dom, e.dom.isBlock)) && void 0 !== r ? r : n.dom);
                        if (s.dom === e.getBody() ? bv(e, o) : ya(s) && (Or(s), o && e.selection.setCursorLocation(s.dom, 0)), !_n(n, s)) {
                            const e = Pt(Nn(s), n) ? [] : Nn(i = s).map(Pn).map((e => X(e, (e => !_n(i, e))))).getOr([]);
                            K(e.concat(Pn(n)), (e => {
                                _n(e, s) || Sn(e, s) || !ya(e) || wo(e)
                            }))
                        }
                        var i
                    }, wv = (e, t) => ((e, t) => {
                        const n = e.dom;
                        return n.parentNode ? Qn(yn.fromDom(n.parentNode), (n => !_n(e, n) && t(n))) : U.none()
                    })(e, t).isSome(), _v = (e, t) => Zn(e, t).isSome(), Sv = e => qo(e, "td,th"),
                    kv = (e, t) => Cm(yn.fromDom(e), t), xv = e => (e => Mt(e.startTable, e.endTable, ((t, n) => {
                        const o = _v(t, (e => _n(e, n))), r = _v(n, (e => _n(e, t)));
                        return o || r ? {
                            ...e,
                            startTable: o ? U.none() : e.startTable,
                            endTable: r ? U.none() : e.endTable,
                            isSameTable: !1,
                            isMultiTable: !1
                        } : e
                    })).getOr(e))(e), Av = (e, t) => ({start: e, end: t}),
                    Nv = Rl([{singleCellTable: ["rng", "cell"]}, {fullTable: ["table"]}, {partialTable: ["cells", "outsideDetails"]}, {multiTable: ["startTableCells", "endTableCells", "betweenRng"]}]),
                    Tv = (e, t) => no(yn.fromDom(e), "td,th", t), Rv = e => !_n(e.start, e.end),
                    Dv = (e, t) => Cm(e.start, t).bind((n => Cm(e.end, t).bind((e => Ft(_n(n, e), n))))),
                    Lv = e => t => Dv(t, e).map((e => ((e, t, n) => ({rng: e, table: t, cells: n}))(t, e, Sv(e)))),
                    Ov = (e, t, n, o) => {
                        if (n.collapsed || !e.forall(Rv)) return U.none();
                        if (t.isSameTable) {
                            const t = e.bind(Lv(o));
                            return U.some({start: t, end: t})
                        }
                        {
                            const e = Tv(n.startContainer, o), t = Tv(n.endContainer, o),
                                r = e.bind((e => t => Cm(t, e).bind((e => ue(Sv(e)).map((e => Av(t, e))))))(o)).bind(Lv(o)),
                                a = t.bind((e => t => Cm(t, e).bind((e => ce(Sv(e)).map((e => Av(e, t))))))(o)).bind(Lv(o));
                            return U.some({start: r, end: a})
                        }
                    }, Bv = (e, t) => te(e, (e => _n(e, t))),
                    Pv = e => Mt(Bv(e.cells, e.rng.start), Bv(e.cells, e.rng.end), ((t, n) => e.cells.slice(t, n + 1))),
                    Iv = (e, t, n) => e.exists((e => ((e, t) => !Rv(e) && Dv(e, t).exists((e => {
                        const t = e.dom.rows;
                        return 1 === t.length && 1 === t[0].cells.length
                    })))(e, n) && _m(e.start, t))), Mv = (e, t) => {
                        const {startTable: n, endTable: o} = t, r = e.cloneRange();
                        return n.each((e => r.setStartAfter(e.dom))), o.each((e => r.setEndBefore(e.dom))), r
                    }, Fv = (e, t) => {
                        const n = (e => t => _n(e, t))(e), o = ((e, t) => {
                            const n = Tv(e.startContainer, t), o = Tv(e.endContainer, t);
                            return Mt(n, o, Av)
                        })(t, n), r = ((e, t) => {
                            const n = kv(e.startContainer, t), o = kv(e.endContainer, t), r = n.isSome(), a = o.isSome(),
                                s = Mt(n, o, _n).getOr(!1);
                            return xv({
                                startTable: n,
                                endTable: o,
                                isStartInTable: r,
                                isEndInTable: a,
                                isSameTable: s,
                                isMultiTable: !s && r && a
                            })
                        })(t, n);
                        return Iv(o, t, n) ? o.map((e => Nv.singleCellTable(t, e.start))) : r.isMultiTable ? ((e, t, n, o) => Ov(e, t, n, o).bind((({
                                                                                                                                                        start: e,
                                                                                                                                                        end: o
                                                                                                                                                    }) => {
                            const r = e.bind(Pv).getOr([]), a = o.bind(Pv).getOr([]);
                            if (r.length > 0 && a.length > 0) {
                                const e = Mv(n, t);
                                return U.some(Nv.multiTable(r, a, e))
                            }
                            return U.none()
                        })))(o, r, t, n) : ((e, t, n, o) => Ov(e, t, n, o).bind((({
                                                                                      start: e,
                                                                                      end: t
                                                                                  }) => e.or(t))).bind((e => {
                            const {isSameTable: o} = t, r = Pv(e).getOr([]);
                            if (o && e.cells.length === r.length) return U.some(Nv.fullTable(e.table));
                            if (r.length > 0) {
                                if (o) return U.some(Nv.partialTable(r, U.none()));
                                {
                                    const e = Mv(n, t);
                                    return U.some(Nv.partialTable(r, U.some({...t, rng: e})))
                                }
                            }
                            return U.none()
                        })))(o, r, t, n)
                    }, Uv = e => K(e, (e => {
                        an(e, "contenteditable"), Or(e)
                    })), qv = (e, t, n, o) => {
                        const r = n.cloneRange();
                        o ? (r.setStart(n.startContainer, n.startOffset), r.setEndAfter(t.dom.lastChild)) : (r.setStartBefore(t.dom.firstChild), r.setEnd(n.endContainer, n.endOffset)), $v(e, r, t, !1).each((e => e()))
                    }, jv = e => {
                        const t = ym(e), n = yn.fromDom(e.selection.getNode());
                        ur(n.dom) && ya(n) ? e.selection.setCursorLocation(n.dom, 0) : e.selection.collapse(!0), t.length > 1 && V(t, (e => _n(e, n))) && en(n, "data-mce-selected", "1")
                    }, Hv = (e, t, n) => U.some((() => {
                        const o = e.selection.getRng(), r = n.bind((({rng: n, isStartInTable: r}) => {
                            const a = ((e, t) => U.from(e.dom.getParent(t, e.dom.isBlock)).map(yn.fromDom))(e, r ? n.endContainer : n.startContainer);
                            n.deleteContents(), ((e, t, n) => {
                                n.each((n => {
                                    t ? wo(n) : (Or(n), e.selection.setCursorLocation(n.dom, 0))
                                }))
                            })(e, r, a.filter(ya));
                            const s = r ? t[0] : t[t.length - 1];
                            return qv(e, s, o, r), ya(s) ? U.none() : U.some(r ? t.slice(1) : t.slice(0, -1))
                        })).getOr(t);
                        Uv(r), jv(e)
                    })), zv = (e, t, n, o) => U.some((() => {
                        const r = e.selection.getRng(), a = t[0], s = n[n.length - 1];
                        qv(e, a, r, !0), qv(e, s, r, !1);
                        const i = ya(a) ? t : t.slice(1), l = ya(s) ? n : n.slice(0, -1);
                        Uv(i.concat(l)), o.deleteContents(), jv(e)
                    })), $v = (e, t, n, o = !0) => U.some((() => {
                        Ev(e, t, n, o)
                    })), Vv = (e, t) => U.some((() => sv(e, !1, t))),
                    Wv = (e, t, n, o) => Yv(t, o).fold((() => ((e, t, n) => Fv(t, n).bind((t => t.fold(L($v, e), L(Vv, e), L(Hv, e), L(zv, e)))))(e, t, n)), (t => ((e, t) => Gv(e, t))(e, t))),
                    Kv = (e, t) => ee(ph(t, e), Tr), Yv = (e, t) => ee(ph(t, e), Qt("caption")),
                    Gv = (e, t) => U.some((() => {
                        Or(t), e.selection.setCursorLocation(t.dom, 0)
                    })),
                    Xv = (e, t, n, o, r) => zu(n, e.getBody(), r).fold((() => U.some(x)), (a => ((e, t, n, o) => Yu(e.dom).bind((r => Gu(e.dom).map((e => t ? n.isEqual(r) && o.isEqual(e) : n.isEqual(e) && o.isEqual(r))))).getOr(!0))(o, n, r, a) ? ((e, t) => Gv(e, t))(e, o) : ((e, t, n) => Yv(e, yn.fromDom(n.getNode())).fold((() => U.some(x)), (e => Ft(!_n(e, t), x))))(t, o, a))),
                    Jv = (e, t, n, o) => {
                        const r = rl.fromRangeStart(e.selection.getRng());
                        return Kv(n, o).bind((o => ya(o) ? Gv(e, o) : ((e, t, n, o, r) => zu(n, e.getBody(), r).bind((e => Kv(t, yn.fromDom(e.getNode())).bind((e => _n(e, o) ? U.none() : U.some(x))))))(e, n, t, o, r)))
                    }, Qv = (e, t) => e ? ch(t) : uh(t), Zv = (e, t, n) => {
                        const o = yn.fromDom(e.getBody());
                        return Yv(o, n).fold((() => Jv(e, t, o, n).orThunk((() => Ft(((e, t) => {
                            const n = rl.fromRangeStart(e.selection.getRng());
                            return Qv(t, n) || Hu(t, e.getBody(), n).exists((e => Qv(t, e)))
                        })(e, t), x)))), (n => ((e, t, n, o) => {
                            const r = rl.fromRangeStart(e.selection.getRng());
                            return ya(o) ? Gv(e, o) : Xv(e, n, t, o, r)
                        })(e, t, o, n)))
                    }, eb = (e, t) => {
                        const n = yn.fromDom(e.selection.getStart(!0)), o = ym(e);
                        return e.selection.isCollapsed() && 0 === o.length ? Zv(e, t, n) : ((e, t, n) => {
                            const o = yn.fromDom(e.getBody()), r = e.selection.getRng();
                            return 0 !== n.length ? Hv(e, n, U.none()) : Wv(e, o, r, t)
                        })(e, n, o)
                    }, tb = (e, t) => {
                        let n = t;
                        for (; n && n !== e;) {
                            if (dr(n) || cr(n)) return n;
                            n = n.parentNode
                        }
                        return null
                    }, nb = ["data-ephox-", "data-mce-", "data-alloy-", "data-snooker-", "_"], ob = Bt.each, rb = e => {
                        const t = e.dom, n = new Set(e.serializer.getTempAttrs()),
                            o = e => V(nb, (t => $e(e, t))) || n.has(e);
                        return {
                            compare: (e, n) => {
                                if (e.nodeName !== n.nodeName || e.nodeType !== n.nodeType) return !1;
                                const r = e => {
                                    const n = {};
                                    return ob(t.getAttribs(e), (r => {
                                        const a = r.nodeName.toLowerCase();
                                        "style" === a || o(a) || (n[a] = t.getAttrib(e, a))
                                    })), n
                                }, a = (e, t) => {
                                    for (const n in e) if (ke(e, n)) {
                                        const o = t[n];
                                        if (C(o)) return !1;
                                        if (e[n] !== o) return !1;
                                        delete t[n]
                                    }
                                    for (const e in t) if (ke(t, e)) return !1;
                                    return !0
                                };
                                if (Vo(e) && Vo(n)) {
                                    if (!a(r(e), r(n))) return !1;
                                    if (!a(t.parseStyle(t.getAttrib(e, "style")), t.parseStyle(t.getAttrib(n, "style")))) return !1
                                }
                                return !um(e) && !um(n)
                            }, isAttributeInternal: o
                        }
                    }, ab = e => ["h1", "h2", "h3", "h4", "h5", "h6"].includes(e.name), sb = (e, t, n, o) => {
                        const r = n.name;
                        for (let t = 0, a = e.length; t < a; t++) {
                            const a = e[t];
                            if (a.name === r) {
                                const e = o.nodes[r];
                                e ? e.nodes.push(n) : o.nodes[r] = {filter: a, nodes: [n]}
                            }
                        }
                        if (n.attributes) for (let e = 0, r = t.length; e < r; e++) {
                            const r = t[e], a = r.name;
                            if (a in n.attributes.map) {
                                const e = o.attributes[a];
                                e ? e.nodes.push(n) : o.attributes[a] = {filter: r, nodes: [n]}
                            }
                        }
                    }, ib = (e, t) => {
                        const n = (e, n) => {
                            he(e, (e => {
                                const o = me(e.nodes);
                                K(e.filter.callbacks, (r => {
                                    for (let t = o.length - 1; t >= 0; t--) {
                                        const r = o[t];
                                        (n ? void 0 !== r.attr(e.filter.name) : r.name === e.filter.name) && !E(r.parent) || o.splice(t, 1)
                                    }
                                    o.length > 0 && r(o, e.filter.name, t)
                                }))
                            }))
                        };
                        n(e.nodes, !1), n(e.attributes, !0)
                    }, lb = (e, t, n, o = {}) => {
                        const r = ((e, t, n) => {
                            const o = {nodes: {}, attributes: {}};
                            return n.firstChild && ((e, t) => {
                                let n = e;
                                for (; n = n.walk();) t(n)
                            })(n, (n => {
                                sb(e, t, n, o)
                            })), o
                        })(e, t, n);
                        ib(r, o)
                    }, db = (e, t, n, o) => {
                        if ((e.pad_empty_with_br || t.insert) && n(o)) {
                            const e = new Ap("br", 1);
                            t.insert && e.attr("data-mce-bogus", "1"), o.empty().append(e)
                        } else o.empty().append(new Ap("#text", 3)).value = br
                    }, cb = (e, t) => {
                        const n = null == e ? void 0 : e.firstChild;
                        return w(n) && n === e.lastChild && n.name === t
                    }, ub = (e, t, n, o) => o.isEmpty(t, n, (t => ((e, t) => {
                        const n = e.getElementRule(t.name);
                        return !0 === (null == n ? void 0 : n.paddEmpty)
                    })(e, t))), mb = e => {
                        let t;
                        for (let n = e; n; n = n.parent) {
                            const e = n.attr("contenteditable");
                            if ("false" === e) break;
                            "true" === e && (t = n)
                        }
                        return U.from(t)
                    }, fb = (e, t, n = e.parent) => {
                        if (t.getSpecialElements()[e.name]) e.empty().remove(); else {
                            const o = e.children();
                            for (const e of o) n && !t.isValidChild(n.name, e.name) && fb(e, t, n);
                            e.unwrap()
                        }
                    }, gb = (e, t, n, o = x) => {
                        const r = t.getTextBlockElements(), a = t.getNonEmptyElements(), s = t.getWhitespaceElements(),
                            i = Bt.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), l = new Set,
                            d = e => e !== n && !i[e.name];
                        for (let n = 0; n < e.length; n++) {
                            const i = e[n];
                            let c, u, m;
                            if (!i.parent || l.has(i)) continue;
                            if (r[i.name] && "li" === i.parent.name) {
                                let e = i.next;
                                for (; e && r[e.name];) e.name = "li", l.add(e), i.parent.insert(e, i.parent), e = e.next;
                                i.unwrap();
                                continue
                            }
                            const f = [i];
                            for (c = i.parent; c && !t.isValidChild(c.name, i.name) && d(c); c = c.parent) f.push(c);
                            if (c && f.length > 1) if (pb(t, i, c)) fb(i, t); else {
                                f.reverse(), u = f[0].clone(), o(u);
                                let e = u;
                                for (let n = 0; n < f.length - 1; n++) {
                                    t.isValidChild(e.name, f[n].name) && n > 0 ? (m = f[n].clone(), o(m), e.append(m)) : m = e;
                                    for (let e = f[n].firstChild; e && e !== f[n + 1];) {
                                        const t = e.next;
                                        m.append(e), e = t
                                    }
                                    e = m
                                }
                                ub(t, a, s, u) ? c.insert(i, f[0], !0) : (c.insert(u, f[0], !0), c.insert(i, u)), c = f[0], (ub(t, a, s, c) || cb(c, "br")) && c.empty().remove()
                            } else if (i.parent) {
                                if ("li" === i.name) {
                                    let e = i.prev;
                                    if (e && ("ul" === e.name || "ol" === e.name)) {
                                        e.append(i);
                                        continue
                                    }
                                    if (e = i.next, e && ("ul" === e.name || "ol" === e.name) && e.firstChild) {
                                        e.insert(i, e.firstChild, !0);
                                        continue
                                    }
                                    const t = new Ap("ul", 1);
                                    o(t), i.wrap(t);
                                    continue
                                }
                                if (t.isValidChild(i.parent.name, "div") && t.isValidChild("div", i.name)) {
                                    const e = new Ap("div", 1);
                                    o(e), i.wrap(e)
                                } else fb(i, t)
                            }
                        }
                    },
                    pb = (e, t, n = t.parent) => !!n && (!(!e.children[t.name] || e.isValidChild(n.name, t.name)) || (!("a" !== t.name || !((e, t) => {
                        let n = e;
                        for (; n;) {
                            if (n.name === t) return !0;
                            n = n.parent
                        }
                        return !1
                    })(n, "a")) || !(!(e => "summary" === e.name)(n) || !ab(t)) && !((null == n ? void 0 : n.firstChild) === t && (null == n ? void 0 : n.lastChild) === t))),
                    hb = e => {
                        const t = rl.fromRangeStart(e), n = rl.fromRangeEnd(e), o = e.commonAncestorContainer;
                        return Hu(!1, o, n).map((r => !fu(t, n, o) && fu(t, r, o) ? ((e, t, n, o) => {
                            const r = document.createRange();
                            return r.setStart(e, t), r.setEnd(n, o), r
                        })(t.container(), t.offset(), r.container(), r.offset()) : e)).getOr(e)
                    }, vb = e => e.collapsed ? e : hb(e),
                    bb = (e, t) => e.getBlockElements()[t.name] && (e => w(e.firstChild) && e.firstChild === e.lastChild)(t) && (e => "br" === e.name || e.value === br)(t.firstChild),
                    yb = (e, t) => {
                        let n = t.firstChild, o = t.lastChild;
                        return n && "meta" === n.name && (n = n.next), o && "mce_marker" === o.attr("id") && (o = o.prev), ((e, t) => {
                            const n = e.getNonEmptyElements();
                            return w(t) && (t.isEmpty(n) || bb(e, t))
                        })(e, o) && (o = null == o ? void 0 : o.prev), !(!n || n !== o) && ("ul" === n.name || "ol" === n.name)
                    },
                    Cb = e => w(null == e ? void 0 : e.firstChild) && e.firstChild === e.lastChild && (e => e.data === br || ir(e))(e.firstChild),
                    Eb = e => {
                        return e.length > 0 && (!(t = e[e.length - 1]).firstChild || Cb(t)) ? e.slice(0, -1) : e;
                        var t
                    }, wb = (e, t) => {
                        const n = e.getParent(t, e.isBlock);
                        return n && "LI" === n.nodeName ? n : null
                    }, _b = (e, t) => {
                        const n = rl.after(e), o = Mu(t).prev(n);
                        return o ? o.toRange() : null
                    }, Sb = (e, t, n) => {
                        const o = e.parentNode;
                        return o && Bt.each(t, (t => {
                            o.insertBefore(t, e)
                        })), ((e, t) => {
                            const n = rl.before(e), o = Mu(t).next(n);
                            return o ? o.toRange() : null
                        })(e, n)
                    }, kb = (e, t, n, o) => {
                        const r = ((e, t, n) => {
                                const o = t.serialize(n);
                                return (e => {
                                    var t, n;
                                    const o = e.firstChild, r = e.lastChild;
                                    return o && "META" === o.nodeName && (null === (t = o.parentNode) || void 0 === t || t.removeChild(o)), r && "mce_marker" === r.id && (null === (n = r.parentNode) || void 0 === n || n.removeChild(r)), e
                                })(e.createFragment(o))
                            })(t, e, o), a = wb(t, n.startContainer),
                            s = Eb((i = r.firstChild, X(null !== (l = null == i ? void 0 : i.childNodes) && void 0 !== l ? l : [], (e => "LI" === e.nodeName))));
                        var i, l;
                        const d = t.getRoot(), c = e => {
                            const o = rl.fromRangeStart(n), r = Mu(t.getRoot()), s = 1 === e ? r.prev(o) : r.next(o),
                                i = null == s ? void 0 : s.getNode();
                            return !i || wb(t, i) !== a
                        };
                        return a ? c(1) ? Sb(a, s, d) : c(2) ? ((e, t, n, o) => (o.insertAfter(t.reverse(), e), _b(t[0], n)))(a, s, d, t) : ((e, t, n, o) => {
                            const r = ((e, t) => {
                                const n = t.cloneRange(), o = t.cloneRange();
                                return n.setStartBefore(e), o.setEndAfter(e), [n.cloneContents(), o.cloneContents()]
                            })(e, o), a = e.parentNode;
                            return a && (a.insertBefore(r[0], e), Bt.each(t, (t => {
                                a.insertBefore(t, e)
                            })), a.insertBefore(r[1], e), a.removeChild(e)), _b(t[t.length - 1], n)
                        })(a, s, d, n) : null
                    }, xb = ["pre"], Ab = ur, Nb = (e, t, n) => {
                        U.from(e.getParent(t, "td,th")).map(yn.fromDom).each((e => ((e, t) => {
                            Fn(e).each((n => {
                                Dn(n).each((o => {
                                    t.isBlock($t(e)) && Sr(n) && t.isBlock($t(o)) && wo(n)
                                }))
                            }))
                        })(e, n)))
                    }, Tb = (e, t) => {
                        var n, o, r;
                        let a;
                        const s = e.dom, i = e.selection;
                        if (!t) return;
                        i.scrollIntoView(t);
                        const l = tb(e.getBody(), t);
                        if (l && "false" === s.getContentEditable(l)) return s.remove(t), void i.select(l);
                        let d = s.createRng();
                        const c = t.previousSibling;
                        if (tr(c)) {
                            d.setStart(c, null !== (o = null === (n = c.nodeValue) || void 0 === n ? void 0 : n.length) && void 0 !== o ? o : 0);
                            const e = t.nextSibling;
                            tr(e) && (c.appendData(e.data), null === (r = e.parentNode) || void 0 === r || r.removeChild(e))
                        } else d.setStartBefore(t), d.setEndBefore(t);
                        const u = s.getParent(t, s.isBlock);
                        if (s.remove(t), u && s.isEmpty(u)) {
                            const t = Ab(u);
                            Eo(yn.fromDom(u)), d.setStart(u, 0), d.setEnd(u, 0), t || (e => !!e.getAttribute("data-mce-fragment"))(u) || !(a = (t => {
                                let n = rl.fromRangeStart(t);
                                return n = Mu(e.getBody()).next(n), null == n ? void 0 : n.toRange()
                            })(d)) ? s.add(u, s.create("br", t ? {} : {"data-mce-bogus": "1"})) : (d = a, s.remove(u))
                        }
                        i.setRng(d)
                    }, Rb = e => {
                        const t = e.dom, n = vb(e.selection.getRng());
                        e.selection.setRng(n);
                        const o = t.getParent(n.startContainer, Ab);
                        ((e, t, n) => {
                            if (w(n)) return n === e.getParent(t.endContainer, Ab) && _m(yn.fromDom(n), t);
                            return !1
                        })(t, n, o) ? $v(e, n, yn.fromDom(o)) : n.startContainer === n.endContainer && n.endOffset - n.startOffset == 1 && tr(n.startContainer.childNodes[n.startOffset]) ? n.deleteContents() : e.getDoc().execCommand("Delete", !1)
                    }, Db = (e, t, n) => {
                        var o, r;
                        const a = e.selection, s = e.dom, i = e.parser, l = n.merge, d = Kp({validate: !0}, e.schema),
                            c = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
                        n.preserve_zwsp || (t = Ir(t)), -1 === t.indexOf("{$caret}") && (t += "{$caret}"), t = t.replace(/\{\$caret\}/, c);
                        let u = a.getRng();
                        const m = u.startContainer, f = e.getBody();
                        m === f && a.isCollapsed() && s.isBlock(f.firstChild) && ((e, t) => w(t) && !e.schema.getVoidElements()[t.nodeName])(e, f.firstChild) && s.isEmpty(f.firstChild) && (u = s.createRng(), u.setStart(f.firstChild, 0), u.setEnd(f.firstChild, 0), a.setRng(u)), a.isCollapsed() || Rb(e);
                        const g = a.getNode(), p = {context: g.nodeName.toLowerCase(), data: n.data, insert: !0},
                            h = i.parse(t, p);
                        if (!0 === n.paste && yb(e.schema, h) && ((e, t) => !!wb(e, t))(s, g)) return u = kb(d, s, a.getRng(), h), u && a.setRng(u), t;
                        !0 === n.paste && ((e, t, n, o) => {
                            var r;
                            const a = t.firstChild, s = t.lastChild,
                                i = a === ("bookmark" === s.attr("data-mce-type") ? s.prev : s), l = $(xb, a.name);
                            if (i && l) {
                                const t = "false" !== a.attr("contenteditable"),
                                    s = (null === (r = e.getParent(n, e.isBlock)) || void 0 === r ? void 0 : r.nodeName.toLowerCase()) === a.name,
                                    i = U.from(tb(o, n)).forall(dr);
                                return t && s && i
                            }
                            return !1
                        })(s, h, g, e.getBody()) && (null === (o = h.firstChild) || void 0 === o || o.unwrap()), (e => {
                            let t = e;
                            for (; t = t.walk();) 1 === t.type && t.attr("data-mce-fragment", "1")
                        })(h);
                        let v = h.lastChild;
                        if (v && "mce_marker" === v.attr("id")) {
                            const t = v;
                            for (v = v.prev; v; v = v.walk(!0)) if (3 === v.type || !s.isBlock(v.name)) {
                                v.parent && e.schema.isValidChild(v.parent.name, "span") && v.parent.insert(t, v, "br" === v.name);
                                break
                            }
                        }
                        if (e._selectionOverrides.showBlockCaretContainer(g), p.invalid || ((e, t, n) => {
                            var o;
                            return V(n.children(), ab) && "SUMMARY" === (null === (o = e.getParent(t, e.isBlock)) || void 0 === o ? void 0 : o.nodeName)
                        })(s, g, h)) {
                            e.selection.setContent(c);
                            let n, o = a.getNode();
                            const l = e.getBody();
                            for (ar(o) ? o = n = l : n = o; n && n !== l;) o = n, n = n.parentNode;
                            t = o === l ? l.innerHTML : s.getOuterHTML(o);
                            const u = i.parse(t), m = (e => {
                                for (let t = e; t; t = t.walk()) if ("mce_marker" === t.attr("id")) return U.some(t);
                                return U.none()
                            })(u), f = m.bind(mb).getOr(u);
                            m.each((e => e.replace(h)));
                            const g = h.children(), p = null !== (r = h.parent) && void 0 !== r ? r : u;
                            h.unwrap();
                            const v = X(g, (t => pb(e.schema, t, p)));
                            gb(v, e.schema, f), lb(i.getNodeFilters(), i.getAttributeFilters(), u), t = d.serialize(u), o === l ? s.setHTML(l, t) : s.setOuterHTML(o, t)
                        } else t = d.serialize(h), ((e, t, n) => {
                            var o;
                            if ("all" === n.getAttribute("data-mce-bogus")) null === (o = n.parentNode) || void 0 === o || o.insertBefore(e.dom.createFragment(t), n); else {
                                const o = n.firstChild, r = n.lastChild;
                                !o || o === r && "BR" === o.nodeName ? e.dom.setHTML(n, t) : e.selection.setContent(t, {no_events: !0})
                            }
                        })(e, t, g);
                        var b;
                        return ((e, t) => {
                            const n = e.schema.getTextInlineElements(), o = e.dom;
                            if (t) {
                                const t = e.getBody(), r = rb(e);
                                Bt.each(o.select("*[data-mce-fragment]"), (e => {
                                    if (w(n[e.nodeName.toLowerCase()]) && Jp(o, e)) for (let n = e.parentElement; w(n) && n !== t && !Qp(o, e, n); n = n.parentElement) if (r.compare(n, e)) {
                                        o.remove(e, !0);
                                        break
                                    }
                                }))
                            }
                        })(e, l), Tb(e, s.get("mce_marker")), b = e.getBody(), Bt.each(b.getElementsByTagName("*"), (e => {
                            e.removeAttribute("data-mce-fragment")
                        })), Nb(s, a.getStart(), e.schema), ((e, t, n) => {
                            const o = Rn(yn.fromDom(n), (e => _n(e, yn.fromDom(t))));
                            de(o, o.length - 2).filter(Yt).fold((() => Ra(e, t)), (t => Ra(e, t.dom)))
                        })(e.schema, e.getBody(), a.getStart()), t
                    }, Lb = e => e instanceof Ap, Ob = (e, t, n) => {
                        e.dom.setHTML(e.getBody(), t), !0 !== n && (e => {
                            ip(e) && Yu(e.getBody()).each((t => {
                                const n = t.getNode(), o = Qo(n) ? Yu(n).getOr(t) : t;
                                e.selection.setRng(o.toRange())
                            }))
                        })(e)
                    }, Bb = (e, t, n) => U.from(e.getBody()).map((o => Lb(t) ? ((e, t, n, o) => {
                        lb(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), n);
                        const r = Kp({validate: !1}, e.schema).serialize(n), a = Ir(Rr(yn.fromDom(t)) ? r : Bt.trim(r));
                        return Ob(e, a, o.no_selection), {content: n, html: a}
                    })(e, o, t, n) : ((e, t, n, o) => {
                        if (0 === (n = Ir(n)).length || /^\s+$/.test(n)) {
                            const r = '<br data-mce-bogus="1">';
                            "TABLE" === t.nodeName ? n = "<tr><td>" + r + "</td></tr>" : /^(UL|OL)$/.test(t.nodeName) && (n = "<li>" + r + "</li>");
                            const a = Jl(e);
                            return e.schema.isValidChild(t.nodeName.toLowerCase(), a.toLowerCase()) ? (n = r, n = e.dom.createHTML(a, Ql(e), n)) : n || (n = r), Ob(e, n, o.no_selection), {
                                content: n,
                                html: n
                            }
                        }
                        {
                            "raw" !== o.format && (n = Kp({validate: !1}, e.schema).serialize(e.parser.parse(n, {
                                isRootContent: !0,
                                insert: !0
                            })));
                            const r = Rr(yn.fromDom(t)) ? n : Bt.trim(n);
                            return Ob(e, r, o.no_selection), {content: r, html: r}
                        }
                    })(e, o, t, n))).getOr({content: t, html: Lb(n.content) ? "" : n.content}), Pb = e => _(e) ? e : M,
                    Ib = (e, t, n) => {
                        const o = t(e), r = Pb(n);
                        return o.orThunk((() => r(e) ? U.none() : ((e, t, n) => {
                            let o = e.dom;
                            const r = Pb(n);
                            for (; o.parentNode;) {
                                o = o.parentNode;
                                const e = yn.fromDom(o), n = t(e);
                                if (n.isSome()) return n;
                                if (r(e)) break
                            }
                            return U.none()
                        })(e, t, r)))
                    }, Mb = Fm, Fb = (e, t, n) => {
                        const o = e.formatter.get(n);
                        if (o) for (let n = 0; n < o.length; n++) {
                            const r = o[n];
                            if (Wm(r) && !1 === r.inherit && e.dom.is(t, r.selector)) return !0
                        }
                        return !1
                    }, Ub = (e, t, n, o, r) => {
                        const a = e.dom.getRoot();
                        if (t === a) return !1;
                        const s = e.dom.getParent(t, (t => !!Fb(e, t, n) || (t.parentNode === a || !!Hb(e, t, n, o, !0))));
                        return !!Hb(e, s, n, o, r)
                    },
                    qb = (e, t, n) => !(!Km(n) || !Mb(t, n.inline)) || (!(!Vm(n) || !Mb(t, n.block)) || !!Wm(n) && (Vo(t) && e.is(t, n.selector))),
                    jb = (e, t, n, o, r, a) => {
                        const s = n[o], i = "attributes" === o;
                        if (_(n.onmatch)) return n.onmatch(t, n, o);
                        if (s) if (Ne(s)) {
                            for (let n = 0; n < s.length; n++) if (i ? e.getAttrib(t, s[n]) : qm(e, t, s[n])) return !0
                        } else for (const o in s) if (ke(s, o)) {
                            const l = i ? e.getAttrib(t, o) : qm(e, t, o), d = Mm(s[o], a), c = E(l) || Je(l);
                            if (c && E(d)) continue;
                            if (r && c && !n.exact) return !1;
                            if ((!r || n.exact) && !Mb(l, Um(d, o))) return !1
                        }
                        return !0
                    }, Hb = (e, t, n, o, r) => {
                        const a = e.formatter.get(n), s = e.dom;
                        if (a && Vo(t)) for (let n = 0; n < a.length; n++) {
                            const i = a[n];
                            if (qb(e.dom, t, i) && jb(s, t, i, "attributes", r, o) && jb(s, t, i, "styles", r, o)) {
                                const n = i.classes;
                                if (n) for (let r = 0; r < n.length; r++) if (!e.dom.hasClass(t, Mm(n[r], o))) return;
                                return i
                            }
                        }
                    }, zb = (e, t, n, o, r) => {
                        if (o) return Ub(e, o, t, n, r);
                        if (o = e.selection.getNode(), Ub(e, o, t, n, r)) return !0;
                        const a = e.selection.getStart();
                        return !(a === o || !Ub(e, a, t, n, r))
                    }, $b = (e, t) => {
                        const n = t => _n(t, yn.fromDom(e.getBody()));
                        return U.from(e.selection.getStart(!0)).bind((o => Ib(yn.fromDom(o), (n => fe(t, (t => ((t, n) => Hb(e, t.dom, n) ? U.some(n) : U.none())(n, t)))), n))).getOrNull()
                    }, Vb = (e, t, n) => Q(n, ((n, o) => {
                        const r = ((e, t) => zm(e, t, (e => {
                            const t = e => _(e) || e.length > 1 && "%" === e.charAt(0);
                            return V(["styles", "attributes"], (n => Se(e, n).exists((e => {
                                const n = v(e) ? e : _e(e);
                                return V(n, t)
                            }))))
                        })))(e, o);
                        return e.formatter.matchNode(t, o, {}, r) ? n.concat([o]) : n
                    }), []), Wb = Br, Kb = e => {
                        if (e) {
                            const t = new Ho(e, e);
                            for (let e = t.current(); e; e = t.next()) if (tr(e)) return e
                        }
                        return null
                    }, Yb = e => {
                        const t = yn.fromTag("span");
                        return tn(t, {
                            id: Xu,
                            "data-mce-bogus": "1",
                            "data-mce-type": "format-caret"
                        }), e && bo(t, yn.fromText(Wb)), t
                    }, Gb = (e, t, n) => {
                        const o = e.dom, r = e.selection;
                        if (Gm(t)) sv(e, !1, yn.fromDom(t), n, !0); else {
                            const e = r.getRng(), n = o.getParent(t, o.isBlock), a = e.startContainer, s = e.startOffset,
                                i = e.endContainer, l = e.endOffset, d = (e => {
                                    const t = Kb(e);
                                    return t && t.data.charAt(0) === Wb && t.deleteData(0, 1), t
                                })(t);
                            o.remove(t, !0), a === d && s > 0 && e.setStart(d, s - 1), i === d && l > 0 && e.setEnd(d, l - 1), n && o.isEmpty(n) && Or(yn.fromDom(n)), r.setRng(e)
                        }
                    }, Xb = (e, t, n) => {
                        const o = e.dom, r = e.selection;
                        if (t) Gb(e, t, n); else if (!(t = Qu(e.getBody(), r.getStart()))) for (; t = o.get(Xu);) Gb(e, t, n)
                    }, Jb = (e, t) => (e.appendChild(t), t), Qb = (e, t) => {
                        var n;
                        const o = J(e, ((e, t) => Jb(e, t.cloneNode(!1))), t),
                            r = null !== (n = o.ownerDocument) && void 0 !== n ? n : document;
                        return Jb(o, r.createTextNode(Wb))
                    }, Zb = (e, t, n, o) => {
                        const r = e.dom, a = e.selection;
                        let s = !1;
                        const i = e.formatter.get(t);
                        if (!i) return;
                        const l = a.getRng(), d = l.startContainer, c = l.startOffset;
                        let u = d;
                        tr(d) && (c !== d.data.length && (s = !0), u = u.parentNode);
                        const m = [];
                        let f;
                        for (; u;) {
                            if (Hb(e, u, t, n, o)) {
                                f = u;
                                break
                            }
                            u.nextSibling && (s = !0), m.push(u), u = u.parentNode
                        }
                        if (f) if (s) {
                            const s = a.getBookmark();
                            l.collapse(!0);
                            let d = mf(r, l, i, !0);
                            d = ug(d), e.formatter.remove(t, n, d, o), a.moveToBookmark(s)
                        } else {
                            const s = Qu(e.getBody(), f), i = w(s) ? r.getParents(f.parentNode, F, s) : [], l = Yb(!1).dom;
                            ((e, t, n) => {
                                var o, r;
                                const a = e.dom, s = a.getParent(n, L(Om, e.schema));
                                s && a.isEmpty(s) ? null === (o = n.parentNode) || void 0 === o || o.replaceChild(t, n) : (Dr(yn.fromDom(n)), a.isEmpty(n) ? null === (r = n.parentNode) || void 0 === r || r.replaceChild(t, n) : a.insertAfter(t, n))
                            })(e, l, null != s ? s : f);
                            const d = ((e, t, n, o, r, a) => {
                                const s = e.formatter, i = e.dom,
                                    l = X(ge(s.get()), (e => e !== o && !ze(e, "removeformat"))), d = Vb(e, n, l);
                                if (X(d, (t => !$m(e, t, o))).length > 0) {
                                    const e = n.cloneNode(!1);
                                    return i.add(t, e), s.remove(o, r, e, a), i.remove(e), U.some(e)
                                }
                                return U.none()
                            })(e, l, f, t, n, o), c = Qb([...m, ...d.toArray(), ...i], l);
                            s && Gb(e, s, w(s)), a.setCursorLocation(c, 1), r.isEmpty(f) && r.remove(f)
                        }
                    }, ey = e => {
                        e.on("mouseup keydown", (t => {
                            var n;
                            ((e, t, n) => {
                                const o = e.selection, r = e.getBody();
                                Xb(e, null, n), 8 !== t && 46 !== t || !o.isCollapsed() || o.getStart().innerHTML !== Wb || Xb(e, Qu(r, o.getStart()), !0), 37 !== t && 39 !== t || Xb(e, Qu(r, o.getStart()), !0)
                            })(e, t.keyCode, (n = e.selection.getRng().endContainer, tr(n) && Ve(n.data, br)))
                        }))
                    }, ty = e => {
                        const t = Yb(!1), n = Qb(e, t.dom);
                        return {caretContainer: t, caretPosition: rl(n, 0)}
                    }, ny = (e, t) => {
                        const {caretContainer: n, caretPosition: o} = ty(t);
                        return po(yn.fromDom(e), n), wo(yn.fromDom(e)), o
                    }, oy = (e, t) => {
                        if (Ju(t.dom)) return !1;
                        const n = e.schema.getTextInlineElements();
                        return ke(n, $t(t)) && !Ju(t.dom) && !Jo(t.dom)
                    }, ry = {}, ay = Yo(["pre"]);
                ((e, t) => {
                    ry[e] || (ry[e] = []), ry[e].push(t)
                })("pre", (e => {
                    const t = e.selection.getRng();
                    if (!t.collapsed) {
                        const t = e.selection.getSelectedBlocks(), n = X(X(t, ay), (e => t => {
                            const n = t.previousSibling;
                            return ay(n) && $(e, n)
                        })(t));
                        K(n, (e => {
                            ((e, t) => {
                                const n = yn.fromDom(t), o = xn(n).dom;
                                wo(n), Co(yn.fromDom(e), [yn.fromTag("br", o), yn.fromTag("br", o), ...Pn(n)])
                            })(e.previousSibling, e)
                        }))
                    }
                }));
                const sy = ["fontWeight", "fontStyle", "color", "fontSize", "fontFamily"],
                    iy = e => ee(e, (e => Km(e) && "span" === e.inline && (e => p(e.styles) && V(ge(e.styles), (e => $(sy, e))))(e))),
                    ly = (e, t) => {
                        const n = e.get(t);
                        return v(n) ? iy(n) : U.none()
                    }, dy = (e, t) => Ku(t, rl.fromRangeStart(e)).isNone(),
                    cy = (e, t) => !1 === Wu(t, rl.fromRangeEnd(e)).exists((e => !ir(e.getNode()) || Wu(t, e).isSome())),
                    uy = e => t => gr(t) && e.isEditable(t), my = e => X((e => {
                        const t = e.getSelectedBlocks(), n = e.getRng();
                        if (e.isCollapsed()) return [];
                        if (1 === t.length) return dy(n, t[0]) && cy(n, t[0]) ? t : [];
                        {
                            const e = ce(t).filter((e => dy(n, e))).toArray(), o = ue(t).filter((e => cy(n, e))).toArray(),
                                r = t.slice(1, -1);
                            return e.concat(r).concat(o)
                        }
                    })(e), uy(e.dom)), fy = e => X(e.getSelectedBlocks(), uy(e.dom)), gy = Bt.each,
                    py = e => Vo(e) && !um(e) && !Ju(e) && !Jo(e), hy = (e, t) => {
                        for (let n = e; n; n = n[t]) {
                            if (tr(n) && Xe(n.data)) return e;
                            if (Vo(n) && !um(n)) return n
                        }
                        return e
                    }, vy = (e, t, n) => {
                        const o = rb(e), r = Wo(t) && e.dom.isEditable(t), a = Wo(n) && e.dom.isEditable(n);
                        if (r && a) {
                            const r = hy(t, "previousSibling"), a = hy(n, "nextSibling");
                            if (o.compare(r, a)) {
                                for (let e = r.nextSibling; e && e !== a;) {
                                    const t = e;
                                    e = e.nextSibling, r.appendChild(t)
                                }
                                return e.dom.remove(a), Bt.each(Bt.grep(a.childNodes), (e => {
                                    r.appendChild(e)
                                })), r
                            }
                        }
                        return n
                    }, by = (e, t, n, o) => {
                        var r;
                        if (o && !1 !== t.merge_siblings) {
                            const t = null !== (r = vy(e, Lm(o), o)) && void 0 !== r ? r : o;
                            vy(e, t, Lm(t, !0))
                        }
                    }, yy = (e, t, n) => {
                        gy(e.childNodes, (e => {
                            py(e) && (t(e) && n(e), e.hasChildNodes() && yy(e, t, n))
                        }))
                    }, Cy = (e, t) => n => !(!n || !qm(e, n, t)), Ey = (e, t, n) => o => {
                        e.setStyle(o, t, n), "" === o.getAttribute("style") && o.removeAttribute("style"), ((e, t) => {
                            "SPAN" === t.nodeName && 0 === e.getAttribs(t).length && e.remove(t, !0)
                        })(e, o)
                    }, wy = Rl([{keep: []}, {rename: ["name"]}, {removed: []}]), _y = /^(src|href|style)$/, Sy = Bt.each,
                    ky = Fm, xy = (e, t, n) => e.isChildOf(t, n) && t !== n && !e.isBlock(n), Ay = (e, t, n) => {
                        let o = t[n ? "startContainer" : "endContainer"], r = t[n ? "startOffset" : "endOffset"];
                        if (Vo(o)) {
                            const e = o.childNodes.length - 1;
                            !n && r && r--, o = o.childNodes[r > e ? e : r]
                        }
                        return tr(o) && n && r >= o.data.length && (o = new Ho(o, e.getBody()).next() || o), tr(o) && !n && 0 === r && (o = new Ho(o, e.getBody()).prev() || o), o
                    }, Ny = (e, t) => {
                        const n = t ? "firstChild" : "lastChild", o = e[n];
                        return (e => /^(TR|TH|TD)$/.test(e.nodeName))(e) && o ? "TR" === e.nodeName && o[n] || o : e
                    }, Ty = (e, t, n, o) => {
                        var r;
                        const a = e.create(n, o);
                        return null === (r = t.parentNode) || void 0 === r || r.insertBefore(a, t), a.appendChild(t), a
                    }, Ry = (e, t, n, o, r) => {
                        const a = yn.fromDom(t), s = yn.fromDom(e.create(o, r)), i = n ? Bn(a) : On(a);
                        return Co(s, i), n ? (po(a, s), vo(s, a)) : (ho(a, s), bo(s, a)), s.dom
                    }, Dy = (e, t, n) => {
                        const o = t.parentNode;
                        let r;
                        const a = e.dom, s = Jl(e);
                        Vm(n) && o === a.getRoot() && (n.list_block && ky(t, n.list_block) || K(me(t.childNodes), (t => {
                            Bm(e, s, t.nodeName.toLowerCase()) ? r ? r.appendChild(t) : (r = Ty(a, t, s), a.setAttribs(r, Ql(e))) : r = null
                        }))), (e => Wm(e) && Km(e) && Pt(Se(e, "mixed"), !0))(n) && !ky(n.inline, t) || a.remove(t, !0)
                    }, Ly = (e, t, n) => S(e) ? {name: t, value: null} : {name: e, value: Mm(t, n)}, Oy = (e, t) => {
                        "" === e.getAttrib(t, "style") && (t.removeAttribute("style"), t.removeAttribute("data-mce-style"))
                    }, By = (e, t, n, o, r) => {
                        let a = !1;
                        Sy(n.styles, ((s, i) => {
                            const {name: l, value: d} = Ly(i, s, o), c = Um(d, l);
                            (n.remove_similar || b(d) || !Vo(r) || ky(qm(e, r, l), c)) && e.setStyle(t, l, ""), a = !0
                        })), a && Oy(e, t)
                    }, Py = (e, t, n, o, r) => {
                        const a = e.dom, s = rb(e), i = e.schema;
                        if (Km(t) && Oa(i, t.inline) && Pa(i, o) && o.parentElement === e.getBody()) return Dy(e, o, t), wy.removed();
                        if (!t.ceFalseOverride && o && "false" === a.getContentEditableParent(o)) return wy.keep();
                        if (o && !qb(a, o, t) && !((e, t) => t.links && "A" === e.nodeName)(o, t)) return wy.keep();
                        const l = o, d = t.preserve_attributes;
                        if (Km(t) && "all" === t.remove && v(d)) {
                            const e = X(a.getAttribs(l), (e => $(d, e.name.toLowerCase())));
                            if (a.removeAllAttribs(l), K(e, (e => a.setAttrib(l, e.name, e.value))), e.length > 0) return wy.rename("span")
                        }
                        if ("all" !== t.remove) {
                            By(a, l, t, n, r), Sy(t.attributes, ((e, o) => {
                                const {name: s, value: i} = Ly(o, e, n);
                                if (t.remove_similar || b(i) || !Vo(r) || ky(a.getAttrib(r, s), i)) {
                                    if ("class" === s) {
                                        const e = a.getAttrib(l, s);
                                        if (e) {
                                            let t = "";
                                            if (K(e.split(/\s+/), (e => {
                                                /mce\-\w+/.test(e) && (t += (t ? " " : "") + e)
                                            })), t) return void a.setAttrib(l, s, t)
                                        }
                                    }
                                    if (_y.test(s) && l.removeAttribute("data-mce-" + s), "style" === s && Yo(["li"])(l) && "none" === a.getStyle(l, "list-style-type")) return l.removeAttribute(s), void a.setStyle(l, "list-style-type", "none");
                                    "class" === s && l.removeAttribute("className"), l.removeAttribute(s)
                                }
                            })), Sy(t.classes, (e => {
                                e = Mm(e, n), Vo(r) && !a.hasClass(r, e) || a.removeClass(l, e)
                            }));
                            const e = a.getAttribs(l);
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t].nodeName;
                                if (!s.isAttributeInternal(n)) return wy.keep()
                            }
                        }
                        return "none" !== t.remove ? (Dy(e, l, t), wy.removed()) : wy.keep()
                    },
                    Iy = (e, t, n, o) => Py(e, t, n, o, o).fold(T(o), (t => (e.dom.createFragment().appendChild(o), e.dom.rename(o, t))), T(null)),
                    My = (e, t, n, o, r) => {
                        const a = e.formatter.get(t), s = a[0], i = e.dom, l = e.selection, d = o => {
                            const i = ((e, t, n, o, r) => {
                                let a;
                                return t.parentNode && K(Hm(e.dom, t.parentNode).reverse(), (t => {
                                    if (!a && Vo(t) && "_start" !== t.id && "_end" !== t.id) {
                                        const s = Hb(e, t, n, o, r);
                                        s && !1 !== s.split && (a = t)
                                    }
                                })), a
                            })(e, o, t, n, r);
                            return ((e, t, n, o, r, a, s, i) => {
                                var l, d;
                                let c, u;
                                const m = e.dom;
                                if (n) {
                                    const f = n.parentNode;
                                    for (let n = o.parentNode; n && n !== f; n = n.parentNode) {
                                        let o = m.clone(n, !1);
                                        for (let n = 0; n < t.length && (o = Iy(e, t[n], i, o), null !== o); n++) ;
                                        o && (c && o.appendChild(c), u || (u = o), c = o)
                                    }
                                    !a || s.mixed && m.isBlock(n) || (o = null !== (l = m.split(n, o)) && void 0 !== l ? l : o), c && u && (null === (d = r.parentNode) || void 0 === d || d.insertBefore(c, r), u.appendChild(r), Km(s) && by(e, s, 0, c))
                                }
                                return o
                            })(e, a, i, o, o, !0, s, n)
                        }, c = t => V(a, (o => Uy(e, o, n, t, t))), u = t => {
                            const n = me(t.childNodes), o = c(t) || V(a, (e => qb(i, t, e))), r = t.parentNode;
                            if (!o && w(r) && Ym(s) && c(r), s.deep && n.length) for (let e = 0; e < n.length; e++) u(n[e]);
                            K(["underline", "line-through", "overline"], (n => {
                                Vo(t) && e.dom.getStyle(t, "text-decoration") === n && t.parentNode && jm(i, t.parentNode) === n && Uy(e, {
                                    deep: !1,
                                    exact: !0,
                                    inline: "span",
                                    styles: {textDecoration: n}
                                }, void 0, t)
                            }))
                        }, m = e => {
                            const t = i.get(e ? "_start" : "_end");
                            if (t) {
                                let n = t[e ? "firstChild" : "lastChild"];
                                return (e => um(e) && Vo(e) && ("_start" === e.id || "_end" === e.id))(n) && (n = n[e ? "firstChild" : "lastChild"]), tr(n) && 0 === n.data.length && (n = e ? t.previousSibling || t.nextSibling : t.nextSibling || t.previousSibling), i.remove(t, !0), n
                            }
                            return null
                        }, f = t => {
                            let n, o, r = mf(i, t, a, t.collapsed);
                            if (s.split) {
                                if (r = ug(r), n = Ay(e, r, !0), o = Ay(e, r), n !== o) {
                                    if (n = Ny(n, !0), o = Ny(o, !1), xy(i, n, o)) {
                                        const e = U.from(n.firstChild).getOr(n);
                                        return d(Ry(i, e, !0, "span", {
                                            id: "_start",
                                            "data-mce-type": "bookmark"
                                        })), void m(!0)
                                    }
                                    if (xy(i, o, n)) {
                                        const e = U.from(o.lastChild).getOr(o);
                                        return d(Ry(i, e, !1, "span", {
                                            id: "_end",
                                            "data-mce-type": "bookmark"
                                        })), void m(!1)
                                    }
                                    n = Ty(i, n, "span", {
                                        id: "_start",
                                        "data-mce-type": "bookmark"
                                    }), o = Ty(i, o, "span", {id: "_end", "data-mce-type": "bookmark"});
                                    const e = i.createRng();
                                    e.setStartAfter(n), e.setEndBefore(o), ff(i, e, (e => {
                                        K(e, (e => {
                                            um(e) || um(e.parentNode) || d(e)
                                        }))
                                    })), d(n), d(o), n = m(!0), o = m()
                                } else n = o = d(n);
                                r.startContainer = n.parentNode ? n.parentNode : n, r.startOffset = i.nodeIndex(n), r.endContainer = o.parentNode ? o.parentNode : o, r.endOffset = i.nodeIndex(o) + 1
                            }
                            ff(i, r, (e => {
                                K(e, u)
                            }))
                        };
                        if (o) {
                            if (Nm(o)) {
                                const e = i.createRng();
                                e.setStartBefore(o), e.setEndAfter(o), f(e)
                            } else f(o);
                            xf(e, t, o, n)
                        } else l.isCollapsed() && Km(s) && !ym(e).length ? Zb(e, t, n, r) : (Rm(e, (() => xm(e, f)), (o => Km(s) && zb(e, t, n, o))), e.nodeChanged()), ((e, t, n) => {
                            "removeformat" === t ? K(fy(e.selection), (t => {
                                K(sy, (n => e.dom.setStyle(t, n, ""))), Oy(e.dom, t)
                            })) : ly(e.formatter, t).each((t => {
                                K(fy(e.selection), (o => By(e.dom, o, t, n, null)))
                            }))
                        })(e, t, n), xf(e, t, o, n)
                    }, Fy = (e, t, n, o, r) => {
                        (o || e.selection.isEditable()) && My(e, t, n, o, r)
                    }, Uy = (e, t, n, o, r) => Py(e, t, n, o, r).fold(M, (t => (e.dom.rename(o, t), !0)), F), qy = Bt.each,
                    jy = (e, t, n, o) => {
                        qy(t, (t => {
                            Km(t) && qy(e.dom.select(t.inline, o), (o => {
                                py(o) && Uy(e, t, n, o, t.exact ? o : null)
                            })), ((e, t, n) => {
                                if (t.clear_child_styles) {
                                    const o = t.links ? "*:not(a)" : "*";
                                    gy(e.select(o, n), (n => {
                                        py(n) && e.isEditable(n) && gy(t.styles, ((t, o) => {
                                            e.setStyle(n, o, "")
                                        }))
                                    }))
                                }
                            })(e.dom, t, o)
                        }))
                    }, Hy = Bt.each, zy = (e, t, n, o) => {
                        if (Hy(n.styles, ((n, r) => {
                            e.setStyle(t, r, Mm(n, o))
                        })), n.styles) {
                            const n = e.getAttrib(t, "style");
                            n && e.setAttrib(t, "data-mce-style", n)
                        }
                    }, $y = (e, t, n, o) => {
                        const r = e.formatter.get(t), a = r[0], s = !o && e.selection.isCollapsed(), i = e.dom,
                            l = e.selection, d = (e, t = a) => {
                                _(t.onformat) && t.onformat(e, t, n, o), zy(i, e, t, n), Hy(t.attributes, ((t, o) => {
                                    i.setAttrib(e, o, Mm(t, n))
                                })), Hy(t.classes, (t => {
                                    const o = Mm(t, n);
                                    i.hasClass(e, o) || i.addClass(e, o)
                                }))
                            }, c = (e, t) => {
                                let n = !1;
                                return Hy(e, (e => !!Wm(e) && ("false" === i.getContentEditable(t) && !e.ceFalseOverride || (!(!w(e.collapsed) || e.collapsed === s) || (!(i.is(t, e.selector) && !Ju(t)) || (d(t, e), n = !0, !1)))))), n
                            }, u = e => {
                                if (g(e)) {
                                    const t = i.create(e);
                                    return d(t), t
                                }
                                return null
                            }, m = (o, s, i) => {
                                const l = [];
                                let m = !0;
                                const f = a.inline || a.block, g = u(f),
                                    p = o => (e => Vm(e) && !0 === e.wrapper)(a) && Hb(e, o, t, n), h = (t, n, o) => {
                                        const r = (e => Vm(e) && !0 !== e.wrapper)(a) && Om(e.schema, t) && Bm(e, n, f);
                                        return o && r
                                    };
                                ff(o, s, (t => {
                                    let n;
                                    const s = t => {
                                        let u = !1, v = m, b = !1;
                                        const y = t.parentNode, C = y.nodeName.toLowerCase(), E = o.getContentEditable(t);
                                        w(E) && (v = m, m = "true" === E, u = !0, b = Im(e, t));
                                        const _ = m && !u;
                                        if (ir(t) && !((e, t, n, o) => {
                                            if (Id(e) && Km(t) && n.parentNode) {
                                                const t = vs(e.schema), r = wv(yn.fromDom(n), (e => Ju(e.dom)));
                                                return xe(t, o) && ya(yn.fromDom(n.parentNode), !1) && !r
                                            }
                                            return !1
                                        })(e, a, t, C)) return n = null, void (Vm(a) && o.remove(t));
                                        if (p(t)) n = null; else {
                                            if (h(t, C, _)) {
                                                const e = o.rename(t, f);
                                                return d(e), l.push(e), void (n = null)
                                            }
                                            if (Wm(a)) {
                                                let e = c(r, t);
                                                if (!e && w(y) && Ym(a) && (e = c(r, y)), !Km(a) || e) return void (n = null)
                                            }
                                            w(g) && ((t, n, r, s) => {
                                                const l = t.nodeName.toLowerCase(), d = Bm(e, f, l) && Bm(e, n, f),
                                                    c = !i && tr(t) && Pr(t.data), u = Ju(t), m = !Km(a) || !o.isBlock(t);
                                                return (r || s) && d && !c && !u && m
                                            })(t, C, _, b) ? (n || (n = o.clone(g, !1), y.insertBefore(n, t), l.push(n)), b && u && (m = v), n.appendChild(t)) : (n = null, K(me(t.childNodes), s), u && (m = v), n = null)
                                        }
                                    };
                                    K(t, s)
                                })), !0 === a.links && K(l, (e => {
                                    const t = e => {
                                        "A" === e.nodeName && d(e, a), K(me(e.childNodes), t)
                                    };
                                    t(e)
                                })), K(l, (s => {
                                    const i = (e => {
                                        let t = 0;
                                        return K(e.childNodes, (e => {
                                            (e => w(e) && tr(e) && 0 === e.length)(e) || um(e) || t++
                                        })), t
                                    })(s);
                                    !(l.length > 1) && o.isBlock(s) || 0 !== i ? (Km(a) || Vm(a) && a.wrapper) && (a.exact || 1 !== i || (s = (e => {
                                        const t = ee(e.childNodes, Tm).filter((e => "false" !== o.getContentEditable(e) && qb(o, e, a)));
                                        return t.map((t => {
                                            const n = o.clone(t, !1);
                                            return d(n), o.replace(n, e, !0), o.remove(t, !0), n
                                        })).getOr(e)
                                    })(s)), jy(e, r, n, s), ((e, t, n, o, r) => {
                                        const a = r.parentNode;
                                        Hb(e, a, n, o) && Uy(e, t, o, r) || t.merge_with_parents && a && e.dom.getParent(a, (a => !!Hb(e, a, n, o) && (Uy(e, t, o, r), !0)))
                                    })(e, a, t, n, s), ((e, t, n, o) => {
                                        if (t.styles && t.styles.backgroundColor) {
                                            const r = Cy(e, "fontSize");
                                            yy(o, (t => r(t) && e.isEditable(t)), Ey(e, "backgroundColor", Mm(t.styles.backgroundColor, n)))
                                        }
                                    })(o, a, n, s), ((e, t, n, o) => {
                                        const r = t => {
                                            if (Wo(t) && Vo(t.parentNode) && e.isEditable(t)) {
                                                const n = jm(e, t.parentNode);
                                                e.getStyle(t, "color") && n ? e.setStyle(t, "text-decoration", n) : e.getStyle(t, "text-decoration") === n && e.setStyle(t, "text-decoration", null)
                                            }
                                        };
                                        t.styles && (t.styles.color || t.styles.textDecoration) && (Bt.walk(o, r, "childNodes"), r(o))
                                    })(o, a, 0, s), ((e, t, n, o) => {
                                        if (Km(t) && ("sub" === t.inline || "sup" === t.inline)) {
                                            const n = Cy(e, "fontSize");
                                            yy(o, (t => n(t) && e.isEditable(t)), Ey(e, "fontSize", ""));
                                            const r = X(e.select("sup" === t.inline ? "sub" : "sup", o), e.isEditable);
                                            e.remove(r, !0)
                                        }
                                    })(o, a, 0, s), by(e, a, 0, s)) : o.remove(s, !0)
                                }))
                            }, f = Nm(o) ? o : l.getNode();
                        if ("false" === i.getContentEditable(f) && !Im(e, f)) return c(r, o = f), void kf(e, t, o, n);
                        if (a) {
                            if (o) if (Nm(o)) {
                                if (!c(r, o)) {
                                    const e = i.createRng();
                                    e.setStartBefore(o), e.setEndAfter(o), m(i, mf(i, e, r), !0)
                                }
                            } else m(i, o, !0); else s && Km(a) && !ym(e).length ? ((e, t, n) => {
                                let o;
                                const r = e.selection, a = e.formatter.get(t);
                                if (!a) return;
                                const s = r.getRng();
                                let i = s.startOffset;
                                const l = s.startContainer.nodeValue;
                                o = Qu(e.getBody(), r.getStart());
                                const d = /[^\s\u00a0\u00ad\u200b\ufeff]/;
                                if (l && i > 0 && i < l.length && d.test(l.charAt(i)) && d.test(l.charAt(i - 1))) {
                                    const o = r.getBookmark();
                                    s.collapse(!0);
                                    let i = mf(e.dom, s, a);
                                    i = ug(i), e.formatter.apply(t, n, i), r.moveToBookmark(o)
                                } else {
                                    let a = o ? Kb(o) : null;
                                    o && (null == a ? void 0 : a.data) === Wb || (c = e.getDoc(), u = Yb(!0).dom, o = c.importNode(u, !0), a = o.firstChild, s.insertNode(o), i = 1), e.formatter.apply(t, n, o), r.setCursorLocation(a, i)
                                }
                                var c, u
                            })(e, t, n) : (l.setRng(vb(l.getRng())), Rm(e, (() => {
                                xm(e, ((e, t) => {
                                    const n = t ? e : mf(i, e, r);
                                    m(i, n, !1)
                                }))
                            }), F), e.nodeChanged()), ly(e.formatter, t).each((t => {
                                K(my(e.selection), (e => zy(i, e, t, n)))
                            }));
                            ((e, t) => {
                                ke(ry, e) && K(ry[e], (e => {
                                    e(t)
                                }))
                            })(t, e)
                        }
                        kf(e, t, o, n)
                    }, Vy = (e, t, n, o) => {
                        (o || e.selection.isEditable()) && $y(e, t, n, o)
                    }, Wy = e => ke(e, "vars"), Ky = e => e.selection.getStart(), Yy = (e, t, n, o, r) => Z(t, (t => {
                        const a = e.formatter.matchNode(t, n, null != r ? r : {}, o);
                        return !C(a)
                    }), (t => !!Fb(e, t, n) || !o && w(e.formatter.matchNode(t, n, r, !0)))), Gy = (e, t) => {
                        const n = null != t ? t : Ky(e);
                        return X(Hm(e.dom, n), (e => Vo(e) && !Jo(e)))
                    }, Xy = (e, t, n) => {
                        const o = Gy(e, t);
                        he(n, ((n, r) => {
                            const a = n => {
                                const a = Yy(e, o, r, n.similar, Wy(n) ? n.vars : void 0), s = a.isSome();
                                if (n.state.get() !== s) {
                                    n.state.set(s);
                                    const e = a.getOr(t);
                                    Wy(n) ? n.callback(s, {
                                        node: e,
                                        format: r,
                                        parents: o
                                    }) : K(n.callbacks, (t => t(s, {node: e, format: r, parents: o})))
                                }
                            };
                            K([n.withSimilar, n.withoutSimilar], a), K(n.withVars, a)
                        }))
                    }, Jy = (e, t, n, o, r, a) => (((e, t, n, o, r, a) => {
                        const s = t.get();
                        K(n.split(","), (t => {
                            const n = Se(s, t).getOrThunk((() => {
                                const e = {
                                    withSimilar: {state: Zs(!1), similar: !0, callbacks: []},
                                    withoutSimilar: {state: Zs(!1), similar: !1, callbacks: []},
                                    withVars: []
                                };
                                return s[t] = e, e
                            })), i = () => {
                                const n = Gy(e);
                                return Yy(e, n, t, r, a).isSome()
                            };
                            if (C(a)) {
                                const e = r ? n.withSimilar : n.withoutSimilar;
                                e.callbacks.push(o), 1 === e.callbacks.length && e.state.set(i())
                            } else n.withVars.push({state: Zs(i()), similar: r, vars: a, callback: o})
                        })), t.set(s)
                    })(e, t, n, o, r, a), {
                        unbind: () => ((e, t, n) => {
                            const o = e.get();
                            K(t.split(","), (e => Se(o, e).each((t => {
                                o[e] = {
                                    withSimilar: {
                                        ...t.withSimilar,
                                        callbacks: X(t.withSimilar.callbacks, (e => e !== n))
                                    },
                                    withoutSimilar: {
                                        ...t.withoutSimilar,
                                        callbacks: X(t.withoutSimilar.callbacks, (e => e !== n))
                                    },
                                    withVars: X(t.withVars, (e => e.callback !== n))
                                }
                            })))), e.set(o)
                        })(t, n, o)
                    }), Qy = Bt.explode, Zy = () => {
                        const e = {};
                        return {
                            addFilter: (t, n) => {
                                K(Qy(t), (t => {
                                    ke(e, t) || (e[t] = {name: t, callbacks: []}), e[t].callbacks.push(n)
                                }))
                            }, getFilters: () => _e(e), removeFilter: (t, n) => {
                                K(Qy(t), (t => {
                                    if (ke(e, t)) if (w(n)) {
                                        const o = e[t], r = X(o.callbacks, (e => e !== n));
                                        r.length > 0 ? o.callbacks = r : delete e[t]
                                    } else delete e[t]
                                }))
                            }
                        }
                    }, eC = (e, t, n) => {
                        e.addNodeFilter("font", (e => {
                            K(e, (e => {
                                const o = t.parse(e.attr("style")), r = e.attr("color"), a = e.attr("face"),
                                    s = e.attr("size");
                                r && (o.color = r), a && (o["font-family"] = a), s && Qe(s).each((e => {
                                    o["font-size"] = n[e - 1]
                                })), e.name = "span", e.attr("style", t.serialize(o)), ((e, t) => {
                                    K(t, (t => {
                                        e.attr(t, null)
                                    }))
                                })(e, ["color", "face", "size"])
                            }))
                        }))
                    }, tC = (e, t, n) => {
                        var o;
                        const r = Rs();
                        t.convert_fonts_to_spans && eC(e, r, Bt.explode(null !== (o = t.font_size_legacy_values) && void 0 !== o ? o : "")), ((e, t, n) => {
                            e.addNodeFilter("strike", (e => {
                                const o = "html4" !== t.type;
                                K(e, (e => {
                                    if (o) e.name = "s"; else {
                                        const t = n.parse(e.attr("style"));
                                        t["text-decoration"] = "line-through", e.name = "span", e.attr("style", n.serialize(t))
                                    }
                                }))
                            }))
                        })(e, n, r)
                    }, nC = (e, t, n) => {
                        t.addNodeFilter("br", ((t, o, r) => {
                            const a = Bt.extend({}, n.getBlockElements()), s = n.getNonEmptyElements(),
                                i = n.getWhitespaceElements();
                            a.body = 1;
                            const l = e => e.name in a || Ma(n, e);
                            for (let o = 0, d = t.length; o < d; o++) {
                                let d = t[o], c = d.parent;
                                if (c && l(c) && d === c.lastChild) {
                                    let t = d.prev;
                                    for (; t;) {
                                        const e = t.name;
                                        if ("span" !== e || "bookmark" !== t.attr("data-mce-type")) {
                                            "br" === e && (d = null);
                                            break
                                        }
                                        t = t.prev
                                    }
                                    if (d && (d.remove(), ub(n, s, i, c))) {
                                        const t = n.getElementRule(c.name);
                                        t && (t.removeEmpty ? c.remove() : t.paddEmpty && db(e, r, l, c))
                                    }
                                } else {
                                    let e = d;
                                    for (; c && c.firstChild === e && c.lastChild === e && (e = c, !a[c.name]);) c = c.parent;
                                    if (e === c) {
                                        const e = new Ap("#text", 3);
                                        e.value = br, d.replace(e)
                                    }
                                }
                            }
                        }))
                    }, oC = e => {
                        const [t, ...n] = e.split(","), o = n.join(","), r = /data:([^/]+\/[^;]+)(;.+)?/.exec(t);
                        if (r) {
                            const e = ";base64" === r[2], t = e ? (e => {
                                const t = /([a-z0-9+\/=\s]+)/i.exec(e);
                                return t ? t[1] : ""
                            })(o) : decodeURIComponent(o);
                            return U.some({type: r[1], data: t, base64Encoded: e})
                        }
                        return U.none()
                    }, rC = (e, t, n = !0) => {
                        let o = t;
                        if (n) try {
                            o = atob(t)
                        } catch (e) {
                            return U.none()
                        }
                        const r = new Uint8Array(o.length);
                        for (let e = 0; e < r.length; e++) r[e] = o.charCodeAt(e);
                        return U.some(new Blob([r], {type: e}))
                    }, aC = e => {
                        return $e(e, "blob:") ? (e => fetch(e).then((e => e.ok ? e.blob() : Promise.reject())).catch((() => Promise.reject({
                            message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
                            uriType: "blob"
                        }))))(e) : $e(e, "data:") ? (t = e, new Promise(((e, n) => {
                            oC(t).bind((({
                                             type: e,
                                             data: t,
                                             base64Encoded: n
                                         }) => rC(e, t, n))).fold((() => n("Invalid data URI")), e)
                        }))) : Promise.reject("Unknown URI format");
                        var t
                    }, sC = e => new Promise(((t, n) => {
                        const o = new FileReader;
                        o.onloadend = () => {
                            t(o.result)
                        }, o.onerror = () => {
                            var e;
                            n(null === (e = o.error) || void 0 === e ? void 0 : e.message)
                        }, o.readAsDataURL(e)
                    }));
                let iC = 0;
                const lC = (e, t, n) => oC(e).bind((({data: e, type: o, base64Encoded: r}) => {
                        if (t && !r) return U.none();
                        {
                            const t = r ? e : btoa(e);
                            return n(t, o)
                        }
                    })), dC = (e, t, n) => {
                        const o = e.create((r || "blobid") + iC++, t, n);
                        var r;
                        return e.add(o), o
                    },
                    cC = (e, t, n = !1) => lC(t, n, ((t, n) => U.from(e.getByData(t, n)).orThunk((() => rC(n, t).map((n => dC(e, n, t))))))),
                    uC = (e, t) => {
                        const {blob_cache: n} = t;
                        if (n) {
                            const t = e => {
                                const t = e.attr("src");
                                (e => e.attr("src") === Rt.transparentSrc || w(e.attr("data-mce-placeholder")))(e) || (e => w(e.attr("data-mce-bogus")))(e) || E(t) || cC(n, t, !0).each((t => {
                                    e.attr("src", t.blobUri())
                                }))
                            };
                            e.addAttributeFilter("src", (e => K(e, t)))
                        }
                    }, mC = (e, t) => $e(e, `${t}/`), fC = (e, t) => {
                        const n = e.schema;
                        t.remove_trailing_brs && nC(t, e, n), e.addAttributeFilter("href", (e => {
                            let n = e.length;
                            const o = e => {
                                const t = e ? Bt.trim(e) : "";
                                return /\b(noopener)\b/g.test(t) ? t : (e => e.split(" ").filter((e => e.length > 0)).concat(["noopener"]).sort().join(" "))(t)
                            };
                            if (!t.allow_unsafe_link_target) for (; n--;) {
                                const t = e[n];
                                "a" === t.name && "_blank" === t.attr("target") && t.attr("rel", o(t.attr("rel")))
                            }
                        })), t.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (e => {
                            let t, n, o, r, a = e.length;
                            for (; a--;) if (r = e[a], "a" === r.name && r.firstChild && !r.attr("href")) for (o = r.parent, t = r.lastChild; t && o;) n = t.prev, o.insert(t, r), t = n
                        })), t.fix_list_elements && e.addNodeFilter("ul,ol", (e => {
                            let t, n, o = e.length;
                            for (; o--;) if (t = e[o], n = t.parent, n && ("ul" === n.name || "ol" === n.name)) if (t.prev && "li" === t.prev.name) t.prev.append(t); else {
                                const e = new Ap("li", 1);
                                e.attr("style", "list-style-type: none"), t.wrap(e)
                            }
                        }));
                        const o = n.getValidClasses();
                        t.validate && o && e.addAttributeFilter("class", (e => {
                            var t;
                            let n = e.length;
                            for (; n--;) {
                                const r = e[n], a = null !== (t = r.attr("class")) && void 0 !== t ? t : "",
                                    s = Bt.explode(a, " ");
                                let i = "";
                                for (let e = 0; e < s.length; e++) {
                                    const t = s[e];
                                    let n = !1, a = o["*"];
                                    a && a[t] && (n = !0), a = o[r.name], !n && a && a[t] && (n = !0), n && (i && (i += " "), i += t)
                                }
                                i.length || (i = null), r.attr("class", i)
                            }
                        })), uC(e, t), t.convert_unsafe_embeds && e.addNodeFilter("object,embed", (e => K(e, (e => {
                            e.replace(((e, t, n, o, r) => {
                                let a;
                                a = C(e) ? "iframe" : mC(e, "image") ? "img" : mC(e, "video") ? "video" : mC(e, "audio") ? "audio" : "iframe";
                                const s = new Ap(a, 1);
                                return s.attr("audio" === a ? {src: t} : {
                                    src: t,
                                    width: n,
                                    height: o
                                }), "audio" !== a && "video" !== a || s.attr("controls", ""), "iframe" === a && r && s.attr("sandbox", ""), s
                            })(e.attr("type"), "object" === e.name ? e.attr("data") : e.attr("src"), e.attr("width"), e.attr("height"), t.sandbox_iframes))
                        })))), t.sandbox_iframes && e.addNodeFilter("iframe", (e => K(e, (e => e.attr("sandbox", "")))))
                    }, {
                        entries: gC,
                        setPrototypeOf: pC,
                        isFrozen: hC,
                        getPrototypeOf: vC,
                        getOwnPropertyDescriptor: bC
                    } = Object;
                let {freeze: yC, seal: CC, create: EC} = Object, {
                    apply: wC,
                    construct: _C
                } = "undefined" != typeof Reflect && Reflect;
                wC || (wC = function (e, t, n) {
                    return e.apply(t, n)
                }), yC || (yC = function (e) {
                    return e
                }), CC || (CC = function (e) {
                    return e
                }), _C || (_C = function (e, t) {
                    return new e(...t)
                });
                const SC = IC(Array.prototype.forEach), kC = IC(Array.prototype.pop), xC = IC(Array.prototype.push),
                    AC = IC(String.prototype.toLowerCase), NC = IC(String.prototype.toString),
                    TC = IC(String.prototype.match), RC = IC(String.prototype.replace),
                    DC = IC(String.prototype.indexOf), LC = IC(String.prototype.trim), OC = IC(RegExp.prototype.test),
                    BC = (PC = TypeError, function () {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        return _C(PC, t)
                    });
                var PC;

                function IC(e) {
                    return function (t) {
                        for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) o[r - 1] = arguments[r];
                        return wC(e, t, o)
                    }
                }

                function MC(e, t, n) {
                    var o;
                    n = null !== (o = n) && void 0 !== o ? o : AC, pC && pC(e, null);
                    let r = t.length;
                    for (; r--;) {
                        let o = t[r];
                        if ("string" == typeof o) {
                            const e = n(o);
                            e !== o && (hC(t) || (t[r] = e), o = e)
                        }
                        e[o] = !0
                    }
                    return e
                }

                function FC(e) {
                    const t = EC(null);
                    for (const [n, o] of gC(e)) t[n] = o;
                    return t
                }

                function UC(e, t) {
                    for (; null !== e;) {
                        const n = bC(e, t);
                        if (n) {
                            if (n.get) return IC(n.get);
                            if ("function" == typeof n.value) return IC(n.value)
                        }
                        e = vC(e)
                    }
                    return function (e) {
                        return console.warn("fallback value for", e), null
                    }
                }

                const qC = yC(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]),
                    jC = yC(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]),
                    HC = yC(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]),
                    zC = yC(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]),
                    $C = yC(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]),
                    VC = yC(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]),
                    WC = yC(["#text"]),
                    KC = yC(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]),
                    YC = yC(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]),
                    GC = yC(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]),
                    XC = yC(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]),
                    JC = CC(/\{\{[\w\W]*|[\w\W]*\}\}/gm), QC = CC(/<%[\w\W]*|[\w\W]*%>/gm), ZC = CC(/\${[\w\W]*}/gm),
                    eE = CC(/^data-[\-\w.\u00B7-\uFFFF]/), tE = CC(/^aria-[\-\w]+$/),
                    nE = CC(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),
                    oE = CC(/^(?:\w+script|data):/i),
                    rE = CC(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), aE = CC(/^html$/i);
                var sE = Object.freeze({
                    __proto__: null,
                    MUSTACHE_EXPR: JC,
                    ERB_EXPR: QC,
                    TMPLIT_EXPR: ZC,
                    DATA_ATTR: eE,
                    ARIA_ATTR: tE,
                    IS_ALLOWED_URI: nE,
                    IS_SCRIPT_OR_DATA: oE,
                    ATTR_WHITESPACE: rE,
                    DOCTYPE_NAME: aE
                });
                const iE = () => "undefined" == typeof window ? null : window;
                var lE = function e() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : iE();
                    const n = t => e(t);
                    if (n.version = "3.0.5", n.removed = [], !t || !t.document || 9 !== t.document.nodeType) return n.isSupported = !1, n;
                    const o = t.document, r = o.currentScript;
                    let {document: a} = t;
                    const {
                            DocumentFragment: s,
                            HTMLTemplateElement: i,
                            Node: l,
                            Element: d,
                            NodeFilter: c,
                            NamedNodeMap: u = t.NamedNodeMap || t.MozNamedAttrMap,
                            HTMLFormElement: m,
                            DOMParser: f,
                            trustedTypes: g
                        } = t, p = d.prototype, h = UC(p, "cloneNode"), v = UC(p, "nextSibling"), b = UC(p, "childNodes"),
                        y = UC(p, "parentNode");
                    if ("function" == typeof i) {
                        const e = a.createElement("template");
                        e.content && e.content.ownerDocument && (a = e.content.ownerDocument)
                    }
                    let C, E = "";
                    const {
                        implementation: w,
                        createNodeIterator: _,
                        createDocumentFragment: S,
                        getElementsByTagName: k
                    } = a, {importNode: x} = o;
                    let A = {};
                    n.isSupported = "function" == typeof gC && "function" == typeof y && w && void 0 !== w.createHTMLDocument;
                    const {
                        MUSTACHE_EXPR: N,
                        ERB_EXPR: T,
                        TMPLIT_EXPR: R,
                        DATA_ATTR: D,
                        ARIA_ATTR: L,
                        IS_SCRIPT_OR_DATA: O,
                        ATTR_WHITESPACE: B
                    } = sE;
                    let {IS_ALLOWED_URI: P} = sE, I = null;
                    const M = MC({}, [...qC, ...jC, ...HC, ...$C, ...WC]);
                    let F = null;
                    const U = MC({}, [...KC, ...YC, ...GC, ...XC]);
                    let q = Object.seal(Object.create(null, {
                            tagNameCheck: {
                                writable: !0,
                                configurable: !1,
                                enumerable: !0,
                                value: null
                            },
                            attributeNameCheck: {writable: !0, configurable: !1, enumerable: !0, value: null},
                            allowCustomizedBuiltInElements: {writable: !0, configurable: !1, enumerable: !0, value: !1}
                        })), j = null, H = null, z = !0, $ = !0, V = !1, W = !0, K = !1, Y = !1, G = !1, X = !1, J = !1,
                        Q = !1, Z = !1, ee = !0, te = !1, ne = !0, oe = !1, re = {}, ae = null;
                    const se = MC({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
                    let ie = null;
                    const le = MC({}, ["audio", "video", "img", "source", "image", "track"]);
                    let de = null;
                    const ce = MC({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]),
                        ue = "http://www.w3.org/1998/Math/MathML", me = "http://www.w3.org/2000/svg",
                        fe = "http://www.w3.org/1999/xhtml";
                    let ge = fe, pe = !1, he = null;
                    const ve = MC({}, [ue, me, fe], NC);
                    let be;
                    const ye = ["application/xhtml+xml", "text/html"];
                    let Ce, Ee = null;
                    const we = a.createElement("form"), _e = function (e) {
                            return e instanceof RegExp || e instanceof Function
                        }, Se = function (e) {
                            if (!Ee || Ee !== e) {
                                if (e && "object" == typeof e || (e = {}), e = FC(e), be = be = -1 === ye.indexOf(e.PARSER_MEDIA_TYPE) ? "text/html" : e.PARSER_MEDIA_TYPE, Ce = "application/xhtml+xml" === be ? NC : AC, I = "ALLOWED_TAGS" in e ? MC({}, e.ALLOWED_TAGS, Ce) : M, F = "ALLOWED_ATTR" in e ? MC({}, e.ALLOWED_ATTR, Ce) : U, he = "ALLOWED_NAMESPACES" in e ? MC({}, e.ALLOWED_NAMESPACES, NC) : ve, de = "ADD_URI_SAFE_ATTR" in e ? MC(FC(ce), e.ADD_URI_SAFE_ATTR, Ce) : ce, ie = "ADD_DATA_URI_TAGS" in e ? MC(FC(le), e.ADD_DATA_URI_TAGS, Ce) : le, ae = "FORBID_CONTENTS" in e ? MC({}, e.FORBID_CONTENTS, Ce) : se, j = "FORBID_TAGS" in e ? MC({}, e.FORBID_TAGS, Ce) : {}, H = "FORBID_ATTR" in e ? MC({}, e.FORBID_ATTR, Ce) : {}, re = "USE_PROFILES" in e && e.USE_PROFILES, z = !1 !== e.ALLOW_ARIA_ATTR, $ = !1 !== e.ALLOW_DATA_ATTR, V = e.ALLOW_UNKNOWN_PROTOCOLS || !1, W = !1 !== e.ALLOW_SELF_CLOSE_IN_ATTR, K = e.SAFE_FOR_TEMPLATES || !1, Y = e.WHOLE_DOCUMENT || !1, J = e.RETURN_DOM || !1, Q = e.RETURN_DOM_FRAGMENT || !1, Z = e.RETURN_TRUSTED_TYPE || !1, X = e.FORCE_BODY || !1, ee = !1 !== e.SANITIZE_DOM, te = e.SANITIZE_NAMED_PROPS || !1, ne = !1 !== e.KEEP_CONTENT, oe = e.IN_PLACE || !1, P = e.ALLOWED_URI_REGEXP || nE, ge = e.NAMESPACE || fe, q = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && _e(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (q.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && _e(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (q.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (q.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), K && ($ = !1), Q && (J = !0), re && (I = MC({}, [...WC]), F = [], !0 === re.html && (MC(I, qC), MC(F, KC)), !0 === re.svg && (MC(I, jC), MC(F, YC), MC(F, XC)), !0 === re.svgFilters && (MC(I, HC), MC(F, YC), MC(F, XC)), !0 === re.mathMl && (MC(I, $C), MC(F, GC), MC(F, XC))), e.ADD_TAGS && (I === M && (I = FC(I)), MC(I, e.ADD_TAGS, Ce)), e.ADD_ATTR && (F === U && (F = FC(F)), MC(F, e.ADD_ATTR, Ce)), e.ADD_URI_SAFE_ATTR && MC(de, e.ADD_URI_SAFE_ATTR, Ce), e.FORBID_CONTENTS && (ae === se && (ae = FC(ae)), MC(ae, e.FORBID_CONTENTS, Ce)), ne && (I["#text"] = !0), Y && MC(I, ["html", "head", "body"]), I.table && (MC(I, ["tbody"]), delete j.tbody), e.TRUSTED_TYPES_POLICY) {
                                    if ("function" != typeof e.TRUSTED_TYPES_POLICY.createHTML) throw BC('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
                                    if ("function" != typeof e.TRUSTED_TYPES_POLICY.createScriptURL) throw BC('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
                                    C = e.TRUSTED_TYPES_POLICY, E = C.createHTML("")
                                } else void 0 === C && (C = function (e, t) {
                                    if ("object" != typeof e || "function" != typeof e.createPolicy) return null;
                                    let n = null;
                                    const o = "data-tt-policy-suffix";
                                    t && t.hasAttribute(o) && (n = t.getAttribute(o));
                                    const r = "dompurify" + (n ? "#" + n : "");
                                    try {
                                        return e.createPolicy(r, {createHTML: e => e, createScriptURL: e => e})
                                    } catch (e) {
                                        return console.warn("TrustedTypes policy " + r + " could not be created."), null
                                    }
                                }(g, r)), null !== C && "string" == typeof E && (E = C.createHTML(""));
                                yC && yC(e), Ee = e
                            }
                        }, ke = MC({}, ["mi", "mo", "mn", "ms", "mtext"]),
                        xe = MC({}, ["foreignobject", "desc", "title", "annotation-xml"]),
                        Ae = MC({}, ["title", "style", "font", "a", "script"]), Ne = MC({}, jC);
                    MC(Ne, HC), MC(Ne, zC);
                    const Te = MC({}, $C);
                    MC(Te, VC);
                    const Re = function (e) {
                        xC(n.removed, {element: e});
                        try {
                            e.parentNode.removeChild(e)
                        } catch (t) {
                            e.remove()
                        }
                    }, De = function (e, t) {
                        try {
                            xC(n.removed, {attribute: t.getAttributeNode(e), from: t})
                        } catch (e) {
                            xC(n.removed, {attribute: null, from: t})
                        }
                        if (t.removeAttribute(e), "is" === e && !F[e]) if (J || Q) try {
                            Re(t)
                        } catch (e) {
                        } else try {
                            t.setAttribute(e, "")
                        } catch (e) {
                        }
                    }, Le = function (e) {
                        let t, n;
                        if (X) e = "<remove></remove>" + e; else {
                            const t = TC(e, /^[\r\n\t ]+/);
                            n = t && t[0]
                        }
                        "application/xhtml+xml" === be && ge === fe && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
                        const o = C ? C.createHTML(e) : e;
                        if (ge === fe) try {
                            t = (new f).parseFromString(o, be)
                        } catch (e) {
                        }
                        if (!t || !t.documentElement) {
                            t = w.createDocument(ge, "template", null);
                            try {
                                t.documentElement.innerHTML = pe ? E : o
                            } catch (e) {
                            }
                        }
                        const r = t.body || t.documentElement;
                        return e && n && r.insertBefore(a.createTextNode(n), r.childNodes[0] || null), ge === fe ? k.call(t, Y ? "html" : "body")[0] : Y ? t.documentElement : r
                    }, Oe = function (e) {
                        return _.call(e.ownerDocument || e, e, c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT, null, !1)
                    }, Be = function (e) {
                        return "object" == typeof l ? e instanceof l : e && "object" == typeof e && "number" == typeof e.nodeType && "string" == typeof e.nodeName
                    }, Pe = function (e, t, o) {
                        A[e] && SC(A[e], (e => {
                            e.call(n, t, o, Ee)
                        }))
                    }, Ie = function (e) {
                        let t;
                        if (Pe("beforeSanitizeElements", e, null), (o = e) instanceof m && ("string" != typeof o.nodeName || "string" != typeof o.textContent || "function" != typeof o.removeChild || !(o.attributes instanceof u) || "function" != typeof o.removeAttribute || "function" != typeof o.setAttribute || "string" != typeof o.namespaceURI || "function" != typeof o.insertBefore || "function" != typeof o.hasChildNodes)) return Re(e), !0;
                        var o;
                        const r = Ce(e.nodeName);
                        if (Pe("uponSanitizeElement", e, {
                            tagName: r,
                            allowedTags: I
                        }), e.hasChildNodes() && !Be(e.firstElementChild) && (!Be(e.content) || !Be(e.content.firstElementChild)) && OC(/<[/\w]/g, e.innerHTML) && OC(/<[/\w]/g, e.textContent)) return Re(e), !0;
                        if (!I[r] || j[r]) {
                            if (!j[r] && Fe(r)) {
                                if (q.tagNameCheck instanceof RegExp && OC(q.tagNameCheck, r)) return !1;
                                if (q.tagNameCheck instanceof Function && q.tagNameCheck(r)) return !1
                            }
                            if (ne && !ae[r]) {
                                const t = y(e) || e.parentNode, n = b(e) || e.childNodes;
                                if (n && t) {
                                    for (let o = n.length - 1; o >= 0; --o) t.insertBefore(h(n[o], !0), v(e))
                                }
                            }
                            return Re(e), !0
                        }
                        return e instanceof d && !function (e) {
                            let t = y(e);
                            t && t.tagName || (t = {namespaceURI: ge, tagName: "template"});
                            const n = AC(e.tagName), o = AC(t.tagName);
                            return !!he[e.namespaceURI] && (e.namespaceURI === me ? t.namespaceURI === fe ? "svg" === n : t.namespaceURI === ue ? "svg" === n && ("annotation-xml" === o || ke[o]) : Boolean(Ne[n]) : e.namespaceURI === ue ? t.namespaceURI === fe ? "math" === n : t.namespaceURI === me ? "math" === n && xe[o] : Boolean(Te[n]) : e.namespaceURI === fe ? !(t.namespaceURI === me && !xe[o]) && !(t.namespaceURI === ue && !ke[o]) && !Te[n] && (Ae[n] || !Ne[n]) : !("application/xhtml+xml" !== be || !he[e.namespaceURI]))
                        }(e) ? (Re(e), !0) : "noscript" !== r && "noembed" !== r && "noframes" !== r || !OC(/<\/no(script|embed|frames)/i, e.innerHTML) ? (K && 3 === e.nodeType && (t = e.textContent, t = RC(t, N, " "), t = RC(t, T, " "), t = RC(t, R, " "), e.textContent !== t && (xC(n.removed, {element: e.cloneNode()}), e.textContent = t)), Pe("afterSanitizeElements", e, null), !1) : (Re(e), !0)
                    }, Me = function (e, t, n) {
                        if (ee && ("id" === t || "name" === t) && (n in a || n in we)) return !1;
                        if ($ && !H[t] && OC(D, t)) ; else if (z && OC(L, t)) ; else if (!F[t] || H[t]) {
                            if (!(Fe(e) && (q.tagNameCheck instanceof RegExp && OC(q.tagNameCheck, e) || q.tagNameCheck instanceof Function && q.tagNameCheck(e)) && (q.attributeNameCheck instanceof RegExp && OC(q.attributeNameCheck, t) || q.attributeNameCheck instanceof Function && q.attributeNameCheck(t)) || "is" === t && q.allowCustomizedBuiltInElements && (q.tagNameCheck instanceof RegExp && OC(q.tagNameCheck, n) || q.tagNameCheck instanceof Function && q.tagNameCheck(n)))) return !1
                        } else if (de[t]) ; else if (OC(P, RC(n, B, ""))) ; else if ("src" !== t && "xlink:href" !== t && "href" !== t || "script" === e || 0 !== DC(n, "data:") || !ie[e]) {
                            if (V && !OC(O, RC(n, B, ""))) ; else if (n) return !1
                        } else ;
                        return !0
                    }, Fe = function (e) {
                        return e.indexOf("-") > 0
                    }, Ue = function (e) {
                        let t, n, o, r;
                        Pe("beforeSanitizeAttributes", e, null);
                        const {attributes: a} = e;
                        if (!a) return;
                        const s = {attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: F};
                        for (r = a.length; r--;) {
                            t = a[r];
                            const {name: i, namespaceURI: l} = t;
                            n = "value" === i ? t.value : LC(t.value);
                            const d = n;
                            if (o = Ce(i), s.attrName = o, s.attrValue = n, s.keepAttr = !0, s.forceKeepAttr = void 0, Pe("uponSanitizeAttribute", e, s), n = s.attrValue, s.forceKeepAttr) continue;
                            if (!s.keepAttr) {
                                De(i, e);
                                continue
                            }
                            if (!W && OC(/\/>/i, n)) {
                                De(i, e);
                                continue
                            }
                            K && (n = RC(n, N, " "), n = RC(n, T, " "), n = RC(n, R, " "));
                            const c = Ce(e.nodeName);
                            if (Me(c, o, n)) {
                                if (!te || "id" !== o && "name" !== o || (De(i, e), n = "user-content-" + n), C && "object" == typeof g && "function" == typeof g.getAttributeType) if (l) ; else switch (g.getAttributeType(c, o)) {
                                    case"TrustedHTML":
                                        n = C.createHTML(n);
                                        break;
                                    case"TrustedScriptURL":
                                        n = C.createScriptURL(n)
                                }
                                if (n !== d) try {
                                    l ? e.setAttributeNS(l, i, n) : e.setAttribute(i, n)
                                } catch (t) {
                                    De(i, e)
                                }
                            } else De(i, e)
                        }
                        Pe("afterSanitizeAttributes", e, null)
                    }, qe = function e(t) {
                        let n;
                        const o = Oe(t);
                        for (Pe("beforeSanitizeShadowDOM", t, null); n = o.nextNode();) Pe("uponSanitizeShadowNode", n, null), Ie(n) || (n.content instanceof s && e(n.content), Ue(n));
                        Pe("afterSanitizeShadowDOM", t, null)
                    };
                    return n.sanitize = function (e) {
                        let t, r, a, i, d = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (pe = !e, pe && (e = "\x3c!--\x3e"), "string" != typeof e && !Be(e)) {
                            if ("function" != typeof e.toString) throw BC("toString is not a function");
                            if ("string" != typeof (e = e.toString())) throw BC("dirty is not a string, aborting")
                        }
                        if (!n.isSupported) return e;
                        if (G || Se(d), n.removed = [], "string" == typeof e && (oe = !1), oe) {
                            if (e.nodeName) {
                                const t = Ce(e.nodeName);
                                if (!I[t] || j[t]) throw BC("root node is forbidden and cannot be sanitized in-place")
                            }
                        } else if (e instanceof l) t = Le("\x3c!----\x3e"), r = t.ownerDocument.importNode(e, !0), 1 === r.nodeType && "BODY" === r.nodeName || "HTML" === r.nodeName ? t = r : t.appendChild(r); else {
                            if (!J && !K && !Y && -1 === e.indexOf("<")) return C && Z ? C.createHTML(e) : e;
                            if (t = Le(e), !t) return J ? null : Z ? E : ""
                        }
                        t && X && Re(t.firstChild);
                        const c = Oe(oe ? e : t);
                        for (; a = c.nextNode();) Ie(a) || (a.content instanceof s && qe(a.content), Ue(a));
                        if (oe) return e;
                        if (J) {
                            if (Q) for (i = S.call(t.ownerDocument); t.firstChild;) i.appendChild(t.firstChild); else i = t;
                            return (F.shadowroot || F.shadowrootmode) && (i = x.call(o, i, !0)), i
                        }
                        let u = Y ? t.outerHTML : t.innerHTML;
                        return Y && I["!doctype"] && t.ownerDocument && t.ownerDocument.doctype && t.ownerDocument.doctype.name && OC(aE, t.ownerDocument.doctype.name) && (u = "<!DOCTYPE " + t.ownerDocument.doctype.name + ">\n" + u), K && (u = RC(u, N, " "), u = RC(u, T, " "), u = RC(u, R, " ")), C && Z ? C.createHTML(u) : u
                    }, n.setConfig = function (e) {
                        Se(e), G = !0
                    }, n.clearConfig = function () {
                        Ee = null, G = !1
                    }, n.isValidAttribute = function (e, t, n) {
                        Ee || Se({});
                        const o = Ce(e), r = Ce(t);
                        return Me(o, r, n)
                    }, n.addHook = function (e, t) {
                        "function" == typeof t && (A[e] = A[e] || [], xC(A[e], t))
                    }, n.removeHook = function (e) {
                        if (A[e]) return kC(A[e])
                    }, n.removeHooks = function (e) {
                        A[e] && (A[e] = [])
                    }, n.removeAllHooks = function () {
                        A = {}
                    }, n
                }();
                const dE = Bt.each, cE = Bt.trim,
                    uE = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                    mE = {ftp: 21, http: 80, https: 443, mailto: 25}, fE = ["img", "video"], gE = (e, t, n) => {
                        const o = (e => {
                            try {
                                return decodeURIComponent(e)
                            } catch (t) {
                                return unescape(e)
                            }
                        })(t).replace(/\s/g, "");
                        return !e.allow_script_urls && (!!/((java|vb)script|mhtml):/i.test(o) || !e.allow_html_data_urls && (/^data:image\//i.test(o) ? ((e, t) => w(e) ? !e : !w(t) || !$(fE, t))(e.allow_svg_data_urls, n) && /^data:image\/svg\+xml/i.test(o) : /^data:/i.test(o)))
                    };

                class pE {
                    static parseDataUri(e) {
                        let t;
                        const n = decodeURIComponent(e).split(","), o = /data:([^;]+)/.exec(n[0]);
                        return o && (t = o[1]), {type: t, data: n[1]}
                    }

                    static isDomSafe(e, t, n = {}) {
                        if (n.allow_script_urls) return !0;
                        {
                            const o = is.decode(e).replace(/[\s\u0000-\u001F]+/g, "");
                            return !gE(n, o, t)
                        }
                    }

                    static getDocumentBaseUrl(e) {
                        var t;
                        let n;
                        return n = 0 !== e.protocol.indexOf("http") && "file:" !== e.protocol ? null !== (t = e.href) && void 0 !== t ? t : "" : e.protocol + "//" + e.host + e.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(n) || (n += "/")), n
                    }

                    constructor(e, t = {}) {
                        this.path = "", this.directory = "", e = cE(e), this.settings = t;
                        const n = t.base_uri, o = this;
                        if (/^([\w\-]+):([^\/]{2})/i.test(e) || /^\s*#/.test(e)) return void (o.source = e);
                        const r = 0 === e.indexOf("//");
                        if (0 !== e.indexOf("/") || r || (e = (n && n.protocol || "http") + "://mce_host" + e), !/^[\w\-]*:?\/\//.test(e)) {
                            const t = n ? n.path : new pE(document.location.href).directory;
                            if ("" === (null == n ? void 0 : n.protocol)) e = "//mce_host" + o.toAbsPath(t, e); else {
                                const r = /([^#?]*)([#?]?.*)/.exec(e);
                                r && (e = (n && n.protocol || "http") + "://mce_host" + o.toAbsPath(t, r[1]) + r[2])
                            }
                        }
                        e = e.replace(/@@/g, "(mce_at)");
                        const a = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(e);
                        a && dE(uE, ((e, t) => {
                            let n = a[t];
                            n && (n = n.replace(/\(mce_at\)/g, "@@")), o[e] = n
                        })), n && (o.protocol || (o.protocol = n.protocol), o.userInfo || (o.userInfo = n.userInfo), o.port || "mce_host" !== o.host || (o.port = n.port), o.host && "mce_host" !== o.host || (o.host = n.host), o.source = ""), r && (o.protocol = "")
                    }

                    setPath(e) {
                        const t = /^(.*?)\/?(\w+)?$/.exec(e);
                        t && (this.path = t[0], this.directory = t[1], this.file = t[2]), this.source = "", this.getURI()
                    }

                    toRelative(e) {
                        if ("./" === e) return e;
                        const t = new pE(e, {base_uri: this});
                        if ("mce_host" !== t.host && this.host !== t.host && t.host || this.port !== t.port || this.protocol !== t.protocol && "" !== t.protocol) return t.getURI();
                        const n = this.getURI(), o = t.getURI();
                        if (n === o || "/" === n.charAt(n.length - 1) && n.substr(0, n.length - 1) === o) return n;
                        let r = this.toRelPath(this.path, t.path);
                        return t.query && (r += "?" + t.query), t.anchor && (r += "#" + t.anchor), r
                    }

                    toAbsolute(e, t) {
                        const n = new pE(e, {base_uri: this});
                        return n.getURI(t && this.isSameOrigin(n))
                    }

                    isSameOrigin(e) {
                        if (this.host == e.host && this.protocol == e.protocol) {
                            if (this.port == e.port) return !0;
                            const t = this.protocol ? mE[this.protocol] : null;
                            if (t && (this.port || t) == (e.port || t)) return !0
                        }
                        return !1
                    }

                    toRelPath(e, t) {
                        let n, o, r = 0, a = "";
                        const s = e.substring(0, e.lastIndexOf("/")).split("/"), i = t.split("/");
                        if (s.length >= i.length) for (n = 0, o = s.length; n < o; n++) if (n >= i.length || s[n] !== i[n]) {
                            r = n + 1;
                            break
                        }
                        if (s.length < i.length) for (n = 0, o = i.length; n < o; n++) if (n >= s.length || s[n] !== i[n]) {
                            r = n + 1;
                            break
                        }
                        if (1 === r) return t;
                        for (n = 0, o = s.length - (r - 1); n < o; n++) a += "../";
                        for (n = r - 1, o = i.length; n < o; n++) a += n !== r - 1 ? "/" + i[n] : i[n];
                        return a
                    }

                    toAbsPath(e, t) {
                        let n = 0;
                        const o = /\/$/.test(t) ? "/" : "", r = e.split("/"), a = t.split("/"), s = [];
                        dE(r, (e => {
                            e && s.push(e)
                        }));
                        const i = [];
                        for (let e = a.length - 1; e >= 0; e--) 0 !== a[e].length && "." !== a[e] && (".." !== a[e] ? n > 0 ? n-- : i.push(a[e]) : n++);
                        const l = s.length - n;
                        let d;
                        return d = l <= 0 ? ae(i).join("/") : s.slice(0, l).join("/") + "/" + ae(i).join("/"), 0 !== d.indexOf("/") && (d = "/" + d), o && d.lastIndexOf("/") !== d.length - 1 && (d += o), d
                    }

                    getURI(e = !1) {
                        let t;
                        return this.source && !e || (t = "", e || (this.protocol ? t += this.protocol + "://" : t += "//", this.userInfo && (t += this.userInfo + "@"), this.host && (t += this.host), this.port && (t += ":" + this.port)), this.path && (t += this.path), this.query && (t += "?" + this.query), this.anchor && (t += "#" + this.anchor), this.source = t), this.source
                    }
                }

                const hE = Bt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"),
                    vE = "data-mce-type";
                let bE = 0;
                const yE = (e, t, n, o, r) => {
                        var a, s, i, l;
                        const d = t.validate, c = n.getSpecialElements();
                        8 === e.nodeType && !t.allow_conditional_comments && /^\[if/i.test(null !== (a = e.nodeValue) && void 0 !== a ? a : "") && (e.nodeValue = " " + e.nodeValue);
                        const u = null !== (s = null == r ? void 0 : r.tagName) && void 0 !== s ? s : e.nodeName.toLowerCase();
                        if ("html" !== o && n.isValid(o)) return void (w(r) && (r.allowedTags[u] = !0));
                        if (1 !== e.nodeType || "body" === u) return;
                        const m = yn.fromDom(e), f = rn(m, vE), p = nn(m, "data-mce-bogus");
                        if (!f && g(p)) return void ("all" === p ? wo(m) : _o(m));
                        const h = n.getElementRule(u);
                        if (!d || h) {
                            if (w(r) && (r.allowedTags[u] = !0), d && h && !f) {
                                if (K(null !== (i = h.attributesForced) && void 0 !== i ? i : [], (e => {
                                    en(m, e.name, "{$uid}" === e.value ? "mce_" + bE++ : e.value)
                                })), K(null !== (l = h.attributesDefault) && void 0 !== l ? l : [], (e => {
                                    rn(m, e.name) || en(m, e.name, "{$uid}" === e.value ? "mce_" + bE++ : e.value)
                                })), h.attributesRequired && !V(h.attributesRequired, (e => rn(m, e)))) return void _o(m);
                                if (h.removeEmptyAttrs && (e => {
                                    const t = e.dom.attributes;
                                    return null == t || 0 === t.length
                                })(m)) return void _o(m);
                                h.outputName && h.outputName !== u && xi(m, h.outputName)
                            }
                        } else ke(c, u) ? wo(m) : _o(m)
                    },
                    CE = (e, t, n, o, r, a) => "html" !== n && !Ca(o) || !(r in hE && gE(e, a, o)) && (!e.validate || t.isValid(o, r) || $e(r, "data-") || $e(r, "aria-")),
                    EE = (e, t) => e.hasAttribute(vE) && ("id" === t || "class" === t || "style" === t),
                    wE = (e, t) => e in t.getBoolAttrs(), _E = (e, t, n, o) => {
                        const {attributes: r} = e;
                        for (let a = r.length - 1; a >= 0; a--) {
                            const s = r[a], i = s.name, l = s.value;
                            CE(t, n, o, e.tagName.toLowerCase(), i, l) || EE(e, i) ? wE(i, n) && e.setAttribute(i, i) : e.removeAttribute(i)
                        }
                    }, SE = (e, t, n) => {
                        const o = lE();
                        return o.addHook("uponSanitizeElement", ((o, r) => {
                            yE(o, e, t, n.track(o), r)
                        })), o.addHook("uponSanitizeAttribute", ((o, r) => {
                            ((e, t, n, o, r) => {
                                const a = e.tagName.toLowerCase(), {attrName: s, attrValue: i} = r;
                                r.keepAttr = CE(t, n, o, a, s, i), r.keepAttr ? (r.allowedAttributes[s] = !0, wE(s, n) && (r.attrValue = s), t.allow_svg_data_urls && $e(i, "data:image/svg+xml") && (r.forceKeepAttr = !0)) : EE(e, s) && (r.forceKeepAttr = !0)
                            })(o, e, t, n.current(), r)
                        })), o
                    }, kE = e => {
                        const t = ["type", "href", "role", "arcrole", "title", "show", "actuate", "label", "from", "to"].map((e => `xlink:${e}`)),
                            n = {IN_PLACE: !0, USE_PROFILES: {html: !0, svg: !0, svgFilters: !0}, ALLOWED_ATTR: t};
                        return lE().sanitize(e, n), e.innerHTML
                    }, xE = (e, t) => {
                        const n = (() => {
                            let e = [];
                            const t = () => e[e.length - 1];
                            return {
                                track: n => {
                                    Ea(n) && e.push(n);
                                    let o = t();
                                    return o && !o.contains(n) && (e.pop(), o = t()), wa(o)
                                }, current: () => wa(t()), reset: () => {
                                    e = []
                                }
                            }
                        })();
                        if (e.sanitize) {
                            const o = SE(e, t, n), r = (t, r) => {
                                o.sanitize(t, ((e, t) => {
                                    const n = {
                                        IN_PLACE: !0,
                                        ALLOW_UNKNOWN_PROTOCOLS: !0,
                                        ALLOWED_TAGS: ["#comment", "#cdata-section", "body"],
                                        ALLOWED_ATTR: []
                                    };
                                    return n.PARSER_MEDIA_TYPE = t, e.allow_script_urls ? n.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (n.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), n
                                })(e, r)), o.removed = [], n.reset()
                            };
                            return {sanitizeHtmlElement: r, sanitizeNamespaceElement: kE}
                        }
                        return {
                            sanitizeHtmlElement: (o, r) => {
                                const a = document.createNodeIterator(o, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
                                let s;
                                for (; s = a.nextNode();) {
                                    const o = n.track(s);
                                    yE(s, e, t, o), Vo(s) && _E(s, e, t, o)
                                }
                                n.reset()
                            }, sanitizeNamespaceElement: x
                        }
                    }, AE = Bt.makeMap, NE = Bt.extend, TE = (e, t, n, o) => {
                        const r = e.name, a = r in n && "title" !== r && "textarea" !== r && "noscript" !== r,
                            s = t.childNodes;
                        for (let t = 0, r = s.length; t < r; t++) {
                            const r = s[t], i = new Ap(r.nodeName.toLowerCase(), r.nodeType);
                            if (Vo(r)) {
                                const e = r.attributes;
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    i.attr(n.name, n.value)
                                }
                                Ca(i.name) && (o(r), i.value = r.innerHTML)
                            } else tr(r) ? (i.value = r.data, a && (i.raw = !0)) : (rr(r) || nr(r) || or(r)) && (i.value = r.data);
                            Ca(i.name) || TE(i, r, n, o), e.append(i)
                        }
                    }, RE = (e, t, n, o) => {
                        const r = n.validate, a = t.getNonEmptyElements(), s = t.getWhitespaceElements(),
                            i = NE(AE("script,style,head,html,body,title,meta,param"), t.getBlockElements()), l = vs(t),
                            d = /[ \t\r\n]+/g, c = /^[ \t\r\n]+/, u = /[ \t\r\n]+$/, m = e => {
                                let t = e.parent;
                                for (; w(t);) {
                                    if (t.name in s) return !0;
                                    t = t.parent
                                }
                                return !1
                            }, f = n => n.name in i || Ma(t, n) || Ca(n.name) && n.parent === e, g = (t, n) => {
                                const r = n ? t.prev : t.next;
                                return !w(r) && !E(t.parent) && (f(t.parent) && (t.parent !== e || !0 === o.isRootContent))
                            };
                        return [e => {
                            var t;
                            if (3 === e.type && !m(e)) {
                                let n = null !== (t = e.value) && void 0 !== t ? t : "";
                                n = n.replace(d, " "), (((e, t) => w(e) && (t(e) || "br" === e.name))(e.prev, f) || g(e, !0)) && (n = n.replace(c, "")), 0 === n.length ? e.remove() : e.value = n
                            }
                        }, e => {
                            var i;
                            if (1 === e.type) {
                                const i = t.getElementRule(e.name);
                                if (r && i) {
                                    const r = ub(t, a, s, e);
                                    i.paddInEmptyBlock && r && (e => {
                                        let n = e;
                                        for (; w(n);) {
                                            if (n.name in l) return ub(t, a, s, n);
                                            n = n.parent
                                        }
                                        return !1
                                    })(e) ? db(n, o, f, e) : i.removeEmpty && r ? f(e) ? e.remove() : e.unwrap() : i.paddEmpty && (r || (e => {
                                        var t;
                                        return cb(e, "#text") && (null === (t = null == e ? void 0 : e.firstChild) || void 0 === t ? void 0 : t.value) === br
                                    })(e)) && db(n, o, f, e)
                                }
                            } else if (3 === e.type && !m(e)) {
                                let t = null !== (i = e.value) && void 0 !== i ? i : "";
                                (e.next && f(e.next) || g(e, !1)) && (t = t.replace(u, "")), 0 === t.length ? e.remove() : e.value = t
                            }
                        }]
                    }, DE = (e = {}, t = ys()) => {
                        const n = Zy(), o = Zy(), r = {validate: !0, root_name: "body", sanitize: !0, ...e},
                            a = new DOMParser, s = xE(r, t), i = n.addFilter, l = n.getFilters, d = n.removeFilter,
                            c = o.addFilter, u = o.getFilters, m = o.removeFilter, f = (e, n) => {
                                const o = g(n.attr(vE)), r = 1 === n.type && !ke(e, n.name) && !Ma(t, n) && !Ca(n.name);
                                return 3 === n.type || r && !o
                            }, p = {
                                schema: t,
                                addAttributeFilter: c,
                                getAttributeFilters: u,
                                removeAttributeFilter: m,
                                addNodeFilter: i,
                                getNodeFilters: l,
                                removeNodeFilter: d,
                                parse: (e, n = {}) => {
                                    var o;
                                    const i = r.validate, d = null !== (o = n.context) && void 0 !== o ? o : r.root_name,
                                        c = ((e, n, o = "html") => {
                                            const r = "xhtml" === o ? "application/xhtml+xml" : "text/html",
                                                i = ke(t.getSpecialElements(), n.toLowerCase()),
                                                l = i ? `<${n}>${e}</${n}>` : e,
                                                d = "xhtml" === o ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${l}</body></html>` : `<body>${l}</body>`,
                                                c = a.parseFromString(d, r).body;
                                            return s.sanitizeHtmlElement(c, r), i ? c.firstChild : c
                                        })(e, d, n.format);
                                    Ra(t, c);
                                    const m = new Ap(d, 11);
                                    TE(m, c, t.getSpecialElements(), s.sanitizeNamespaceElement), c.innerHTML = "";
                                    const [g, p] = RE(m, t, r, n), h = [], v = i ? e => ((e, n) => {
                                        pb(t, e) && n.push(e)
                                    })(e, h) : x, b = {nodes: {}, attributes: {}}, y = e => sb(l(), u(), e, b);
                                    if (((e, t, n) => {
                                        const o = [];
                                        for (let n = e, r = n; n; r = n, n = n.walk()) {
                                            const a = n;
                                            K(t, (e => e(a))), E(a.parent) && a !== e ? n = r : o.push(a)
                                        }
                                        for (let e = o.length - 1; e >= 0; e--) {
                                            const t = o[e];
                                            K(n, (e => e(t)))
                                        }
                                    })(m, [g, y], [p, v]), h.reverse(), i && h.length > 0) if (n.context) {
                                        const {pass: e, fail: o} = G(h, (e => e.parent === m));
                                        gb(o, t, m, y), n.invalid = e.length > 0
                                    } else gb(h, t, m, y);
                                    const C = ((e, t) => {
                                        var n;
                                        const o = null !== (n = t.forced_root_block) && void 0 !== n ? n : e.forced_root_block;
                                        return !1 === o ? "" : !0 === o ? "p" : o
                                    })(r, n);
                                    return C && ("body" === m.name || n.isRootContent) && ((e, n) => {
                                        const o = NE(AE("script,style,head,html,body,title,meta,param"), t.getBlockElements()),
                                            a = /^[ \t\r\n]+/, s = /[ \t\r\n]+$/;
                                        let i = e.firstChild, l = null;
                                        const d = e => {
                                            var t, n;
                                            e && (i = e.firstChild, i && 3 === i.type && (i.value = null === (t = i.value) || void 0 === t ? void 0 : t.replace(a, "")), i = e.lastChild, i && 3 === i.type && (i.value = null === (n = i.value) || void 0 === n ? void 0 : n.replace(s, "")))
                                        };
                                        if (t.isValidChild(e.name, n.toLowerCase())) {
                                            for (; i;) {
                                                const t = i.next;
                                                f(o, i) ? (l || (l = new Ap(n, 1), l.attr(r.forced_root_block_attrs), e.insert(l, i)), l.append(i)) : (d(l), l = null), i = t
                                            }
                                            d(l)
                                        }
                                    })(m, C), n.invalid || ib(b, n), m
                                }
                            };
                        return fC(p, r), ((e, t, n) => {
                            t.inline_styles && tC(e, t, n)
                        })(p, r, t), p
                    }, LE = (e, t, n) => {
                        const o = (e => Lb(e) ? Kp({validate: !1}).serialize(e) : e)(e), r = t(o);
                        if (r.isDefaultPrevented()) return r;
                        if (Lb(e)) {
                            if (r.content !== o) {
                                const t = DE({
                                    validate: !1,
                                    forced_root_block: !1, ...n
                                }).parse(r.content, {context: e.name});
                                return {...r, content: t}
                            }
                            return {...r, content: e}
                        }
                        return r
                    }, OE = (e, t) => {
                        if (t.no_events) return Tl.value(t);
                        {
                            const n = ((e, t) => e.dispatch("BeforeGetContent", t))(e, t);
                            return n.isDefaultPrevented() ? Tl.error(Nf(e, {content: "", ...n}).content) : Tl.value(n)
                        }
                    }, BE = (e, t, n) => {
                        if (n.no_events) return t;
                        {
                            const o = LE(t, (t => Nf(e, {...n, content: t})), {sanitize: Ac(e), sandbox_iframes: Bc(e)});
                            return o.content
                        }
                    }, PE = (e, t) => {
                        if (t.no_events) return Tl.value(t);
                        {
                            const n = LE(t.content, (n => ((e, t) => e.dispatch("BeforeSetContent", t))(e, {
                                ...t,
                                content: n
                            })), {sanitize: Ac(e), sandbox_iframes: Bc(e)});
                            return n.isDefaultPrevented() ? (Af(e, n), Tl.error(void 0)) : Tl.value(n)
                        }
                    }, IE = (e, t, n) => {
                        n.no_events || Af(e, {...n, content: t})
                    }, ME = (e, t, n) => ({element: e, width: t, rows: n}), FE = (e, t) => ({element: e, cells: t}),
                    UE = (e, t) => ({x: e, y: t}), qE = (e, t) => on(e, t).bind(Qe).getOr(1), jE = (e, t, n) => {
                        const o = e.rows;
                        return !!(o[n] ? o[n].cells : [])[t]
                    }, HE = e => Q(e, ((e, t) => t.cells.length > e ? t.cells.length : e), 0), zE = (e, t) => {
                        const n = e.rows;
                        for (let e = 0; e < n.length; e++) {
                            const o = n[e].cells;
                            for (let n = 0; n < o.length; n++) if (_n(o[n], t)) return U.some(UE(n, e))
                        }
                        return U.none()
                    }, $E = (e, t, n, o, r) => {
                        const a = [], s = e.rows;
                        for (let e = n; e <= r; e++) {
                            const n = s[e].cells, r = t < o ? n.slice(t, o + 1) : n.slice(o, t + 1);
                            a.push(FE(s[e].element, r))
                        }
                        return a
                    }, VE = e => {
                        const t = ME(Si(e), 0, []);
                        return K(qo(e, "tr"), ((e, n) => {
                            K(qo(e, "td,th"), ((o, r) => {
                                ((e, t, n, o, r) => {
                                    const a = qE(r, "rowspan"), s = qE(r, "colspan"), i = e.rows;
                                    for (let e = n; e < n + a; e++) {
                                        i[e] || (i[e] = FE(ki(o), []));
                                        for (let o = t; o < t + s; o++) i[e].cells[o] = e === n && o === t ? r : Si(r)
                                    }
                                })(t, ((e, t, n) => {
                                    for (; jE(e, t, n);) t++;
                                    return t
                                })(t, r, n), n, e, o)
                            }))
                        })), ME(t.element, HE(t.rows), t.rows)
                    }, WE = e => ((e, t) => {
                        const n = Si(e.element), o = yn.fromTag("tbody");
                        return Co(o, t), bo(n, o), n
                    })(e, (e => W(e.rows, (e => {
                        const t = W(e.cells, (e => {
                            const t = ki(e);
                            return an(t, "colspan"), an(t, "rowspan"), t
                        })), n = Si(e.element);
                        return Co(n, t), n
                    })))(e)), KE = (e, t, n) => zE(e, t).bind((t => zE(e, n).map((n => ((e, t, n) => {
                        const o = t.x, r = t.y, a = n.x, s = n.y, i = r < s ? $E(e, o, r, a, s) : $E(e, o, s, a, r);
                        return ME(e.element, HE(i), i)
                    })(e, t, n))))),
                    YE = (e, t) => ee(e, (e => "li" === $t(e) && _m(e, t))).fold(T([]), (t => (e => ee(e, (e => "ul" === $t(e) || "ol" === $t(e))))(e).map((e => {
                        const t = yn.fromTag($t(e)), n = Ee(fo(e), ((e, t) => $e(t, "list-style")));
                        return lo(t, n), [yn.fromTag("li"), t]
                    })).getOr([]))), GE = (e, t, n) => {
                        const o = yn.fromDom(t.commonAncestorContainer), r = ph(o, e), a = X(r, (e => n.isWrapper($t(e)))),
                            s = YE(r, t),
                            i = a.concat(s.length ? s : (e => Ar(e) ? Nn(e).filter(xr).fold(T([]), (t => [e, t])) : xr(e) ? [e] : [])(o));
                        return W(i, Si)
                    }, XE = () => Qf([]), JE = (e, t, n) => ((e, t) => {
                        const n = Q(t, ((e, t) => (bo(t, e), t)), e);
                        return t.length > 0 ? Qf([n]) : n
                    })(yn.fromDom(t.cloneContents()), GE(e, t, n)),
                    QE = (e, t) => ((e, t) => eo(t, "table", L(_n, e)))(e, t[0]).bind((e => {
                        const n = t[0], o = t[t.length - 1], r = VE(e);
                        return KE(r, n, o).map((e => Qf([WE(e)])))
                    })).getOrThunk(XE), ZE = (e, t, n) => {
                        const o = bm(t, e);
                        return o.length > 0 ? QE(e, o) : ((e, t, n) => t.length > 0 && t[0].collapsed ? XE() : JE(e, t[0], n))(e, t, n)
                    }, ew = (e, t) => t >= 0 && t < e.length && gm(e.charAt(t)), tw = e => Ir(e.innerText), nw = (e, t) => {
                        if ("text" === t.format) return (e => U.from(e.selection.getRng()).map((t => {
                            var n;
                            const o = U.from(e.dom.getParent(t.commonAncestorContainer, e.dom.isBlock)), r = e.getBody(),
                                a = (e => e.map((e => e.nodeName)).getOr("div").toLowerCase())(o),
                                s = yn.fromDom(t.cloneContents());
                            jp(s), Hp(s);
                            const i = e.dom.add(r, a, {
                                "data-mce-bogus": "all",
                                style: "overflow: hidden; opacity: 0;"
                            }, s.dom), l = tw(i), d = Ir(null !== (n = i.textContent) && void 0 !== n ? n : "");
                            if (e.dom.remove(i), ew(d, 0) || ew(d, d.length - 1)) {
                                const e = o.getOr(r), t = tw(e), n = t.indexOf(l);
                                return -1 === n ? l : (ew(t, n - 1) ? " " : "") + l + (ew(t, n + l.length) ? " " : "")
                            }
                            return l
                        })).getOr(""))(e);
                        {
                            const n = ((e, t) => {
                                const n = e.selection.getRng(), o = e.dom.create("body"), r = e.selection.getSel(),
                                    a = hp(e, hm(r)),
                                    s = t.contextual ? ZE(yn.fromDom(e.getBody()), a, e.schema).dom : n.cloneContents();
                                return s && o.appendChild(s), e.selection.serializer.serialize(o, t)
                            })(e, t);
                            return "tree" === t.format ? n : e.selection.isCollapsed() ? "" : n
                        }
                    },
                    ow = e => Vo(e) ? e.outerHTML : tr(e) ? is.encodeRaw(e.data, !1) : rr(e) ? "\x3c!--" + e.data + "--\x3e" : "",
                    rw = (e, t, n) => {
                        const o = (e => {
                            let t;
                            const n = document.createElement("div"), o = document.createDocumentFragment();
                            for (e && (n.innerHTML = e); t = n.firstChild;) o.appendChild(t);
                            return o
                        })(t);
                        if (e.hasChildNodes() && n < e.childNodes.length) {
                            const t = e.childNodes[n];
                            e.insertBefore(o, t)
                        } else e.appendChild(o)
                    }, aw = (e, t) => (((e, t) => {
                        let n = 0;
                        K(e, (e => {
                            0 === e[0] ? n++ : 1 === e[0] ? (rw(t, e[1], n), n++) : 2 === e[0] && ((e, t) => {
                                if (e.hasChildNodes() && t < e.childNodes.length) {
                                    const n = e.childNodes[t];
                                    e.removeChild(n)
                                }
                            })(t, n)
                        }))
                    })(((e, t) => {
                        const n = e.length + t.length + 2, o = new Array(n), r = new Array(n), a = (n, o, r, s, l) => {
                            const d = i(n, o, r, s);
                            if (null === d || d.start === o && d.diag === o - s || d.end === n && d.diag === n - r) {
                                let a = n, i = r;
                                for (; a < o || i < s;) a < o && i < s && e[a] === t[i] ? (l.push([0, e[a]]), ++a, ++i) : o - n > s - r ? (l.push([2, e[a]]), ++a) : (l.push([1, t[i]]), ++i)
                            } else {
                                a(n, d.start, r, d.start - d.diag, l);
                                for (let t = d.start; t < d.end; ++t) l.push([0, e[t]]);
                                a(d.end, o, d.end - d.diag, s, l)
                            }
                        }, s = (n, o, r, a) => {
                            let s = n;
                            for (; s - o < a && s < r && e[s] === t[s - o];) ++s;
                            return ((e, t, n) => ({start: e, end: t, diag: n}))(n, s, o)
                        }, i = (n, a, i, l) => {
                            const d = a - n, c = l - i;
                            if (0 === d || 0 === c) return null;
                            const u = d - c, m = c + d, f = (m % 2 == 0 ? m : m + 1) / 2;
                            let g, p, h, v, b;
                            for (o[1 + f] = n, r[1 + f] = a + 1, g = 0; g <= f; ++g) {
                                for (p = -g; p <= g; p += 2) {
                                    for (h = p + f, p === -g || p !== g && o[h - 1] < o[h + 1] ? o[h] = o[h + 1] : o[h] = o[h - 1] + 1, v = o[h], b = v - n + i - p; v < a && b < l && e[v] === t[b];) o[h] = ++v, ++b;
                                    if (u % 2 != 0 && u - g <= p && p <= u + g && r[h - u] <= o[h]) return s(r[h - u], p + n - i, a, l)
                                }
                                for (p = u - g; p <= u + g; p += 2) {
                                    for (h = p + f - u, p === u - g || p !== u + g && r[h + 1] <= r[h - 1] ? r[h] = r[h + 1] - 1 : r[h] = r[h - 1], v = r[h] - 1, b = v - n + i - p; v >= n && b >= i && e[v] === t[b];) r[h] = v--, b--;
                                    if (u % 2 == 0 && -g <= p && p <= g && r[h] <= o[h + u]) return s(r[h], p + n - i, a, l)
                                }
                            }
                            return null
                        }, l = [];
                        return a(0, e.length, 0, t.length, l), l
                    })(W(me(t.childNodes), ow), e), t), t),
                    sw = Ie((() => document.implementation.createHTMLDocument("undo"))), iw = e => {
                        const t = e.serializer.getTempAttrs(), n = qp(e.getBody(), t);
                        return (e => null !== e.querySelector("iframe"))(n) ? (o = ((e, t) => X(W(me(e.childNodes), t ? A(Ir, ow) : ow), (e => e.length > 0)))(n, !0), {
                            type: "fragmented",
                            fragments: o,
                            content: "",
                            bookmark: null,
                            beforeBookmark: null
                        }) : {
                            type: "complete",
                            fragments: null,
                            content: Ir(n.innerHTML),
                            bookmark: null,
                            beforeBookmark: null
                        };
                        var o
                    }, lw = (e, t, n) => {
                        const o = n ? t.beforeBookmark : t.bookmark;
                        "fragmented" === t.type ? aw(t.fragments, e.getBody()) : e.setContent(t.content, {
                            format: "raw",
                            no_selection: !w(o) || !em(o) || !o.isFakeCaret
                        }), o && (e.selection.moveToBookmark(o), e.selection.scrollIntoView())
                    }, dw = e => "fragmented" === e.type ? e.fragments.join("") : e.content, cw = e => {
                        const t = yn.fromTag("body", sw());
                        return xo(t, dw(e)), K(qo(t, "*[data-mce-bogus]"), _o), ko(t)
                    },
                    uw = (e, t) => !(!e || !t) && (!!((e, t) => dw(e) === dw(t))(e, t) || ((e, t) => cw(e) === cw(t))(e, t)),
                    mw = e => 0 === e.get(), fw = (e, t, n) => {
                        mw(n) && (e.typing = t)
                    }, gw = (e, t) => {
                        e.typing && (fw(e, !1, t), e.add())
                    }, pw = e => ({
                        init: {bindEvents: x},
                        undoManager: {
                            beforeChange: (t, n) => ((e, t, n) => {
                                mw(t) && n.set(xl(e.selection))
                            })(e, t, n),
                            add: (t, n, o, r, a, s) => ((e, t, n, o, r, a, s) => {
                                const i = iw(e), l = Bt.extend(a || {}, i);
                                if (!mw(o) || e.removed) return null;
                                const d = t.data[n.get()];
                                if (e.dispatch("BeforeAddUndo", {
                                    level: l,
                                    lastLevel: d,
                                    originalEvent: s
                                }).isDefaultPrevented()) return null;
                                if (d && uw(d, l)) return null;
                                t.data[n.get()] && r.get().each((e => {
                                    t.data[n.get()].beforeBookmark = e
                                }));
                                const c = $d(e);
                                if (c && t.data.length > c) {
                                    for (let e = 0; e < t.data.length - 1; e++) t.data[e] = t.data[e + 1];
                                    t.data.length--, n.set(t.data.length)
                                }
                                l.bookmark = xl(e.selection), n.get() < t.data.length - 1 && (t.data.length = n.get() + 1), t.data.push(l), n.set(t.data.length - 1);
                                const u = {level: l, lastLevel: d, originalEvent: s};
                                return n.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", u), e.dispatch("change", u)) : e.dispatch("AddUndo", u), l
                            })(e, t, n, o, r, a, s),
                            undo: (t, n, o) => ((e, t, n, o) => {
                                let r;
                                return t.typing && (t.add(), t.typing = !1, fw(t, !1, n)), o.get() > 0 && (o.set(o.get() - 1), r = t.data[o.get()], lw(e, r, !0), e.setDirty(!0), e.dispatch("Undo", {level: r})), r
                            })(e, t, n, o),
                            redo: (t, n) => ((e, t, n) => {
                                let o;
                                return t.get() < n.length - 1 && (t.set(t.get() + 1), o = n[t.get()], lw(e, o, !1), e.setDirty(!0), e.dispatch("Redo", {level: o})), o
                            })(e, t, n),
                            clear: (t, n) => ((e, t, n) => {
                                t.data = [], n.set(0), t.typing = !1, e.dispatch("ClearUndos")
                            })(e, t, n),
                            reset: e => (e => {
                                e.clear(), e.add()
                            })(e),
                            hasUndo: (t, n) => ((e, t, n) => n.get() > 0 || t.typing && t.data[0] && !uw(iw(e), t.data[0]))(e, t, n),
                            hasRedo: (e, t) => ((e, t) => t.get() < e.data.length - 1 && !e.typing)(e, t),
                            transact: (e, t, n) => ((e, t, n) => (gw(e, t), e.beforeChange(), e.ignore(n), e.add()))(e, t, n),
                            ignore: (e, t) => ((e, t) => {
                                try {
                                    e.set(e.get() + 1), t()
                                } finally {
                                    e.set(e.get() - 1)
                                }
                            })(e, t),
                            extra: (t, n, o, r) => ((e, t, n, o, r) => {
                                if (t.transact(o)) {
                                    const o = t.data[n.get()].bookmark, a = t.data[n.get() - 1];
                                    lw(e, a, !0), t.transact(r) && (t.data[n.get() - 1].beforeBookmark = o)
                                }
                            })(e, t, n, o, r)
                        },
                        formatter: {
                            match: (t, n, o, r) => zb(e, t, n, o, r),
                            matchAll: (t, n) => ((e, t, n) => {
                                const o = [], r = {}, a = e.selection.getStart();
                                return e.dom.getParent(a, (a => {
                                    for (let s = 0; s < t.length; s++) {
                                        const i = t[s];
                                        !r[i] && Hb(e, a, i, n) && (r[i] = !0, o.push(i))
                                    }
                                }), e.dom.getRoot()), o
                            })(e, t, n),
                            matchNode: (t, n, o, r) => Hb(e, t, n, o, r),
                            canApply: t => ((e, t) => {
                                const n = e.formatter.get(t), o = e.dom;
                                if (n && e.selection.isEditable()) {
                                    const t = e.selection.getStart(), r = Hm(o, t);
                                    for (let e = n.length - 1; e >= 0; e--) {
                                        const t = n[e];
                                        if (!Wm(t)) return !0;
                                        for (let e = r.length - 1; e >= 0; e--) if (o.is(r[e], t.selector)) return !0
                                    }
                                }
                                return !1
                            })(e, t),
                            closest: t => $b(e, t),
                            apply: (t, n, o) => Vy(e, t, n, o),
                            remove: (t, n, o, r) => Fy(e, t, n, o, r),
                            toggle: (t, n, o) => ((e, t, n, o) => {
                                const r = e.formatter.get(t);
                                r && (!zb(e, t, n, o) || "toggle" in r[0] && !r[0].toggle ? Vy(e, t, n, o) : Fy(e, t, n, o))
                            })(e, t, n, o),
                            formatChanged: (t, n, o, r, a) => Jy(e, t, n, o, r, a)
                        },
                        editor: {
                            getContent: t => ((e, t) => U.from(e.getBody()).fold(T("tree" === t.format ? new Ap("body", 11) : ""), (n => $p(e, t, n))))(e, t),
                            setContent: (t, n) => Bb(e, t, n),
                            insertContent: (t, n) => Db(e, t, n),
                            addVisual: t => ((e, t) => {
                                const n = e.dom, o = w(t) ? t : e.getBody();
                                K(n.select("table,a", o), (t => {
                                    switch (t.nodeName) {
                                        case"TABLE":
                                            const o = Zd(e), r = n.getAttrib(t, "border");
                                            r && "0" !== r || !e.hasVisual ? n.removeClass(t, o) : n.addClass(t, o);
                                            break;
                                        case"A":
                                            if (!n.getAttrib(t, "href")) {
                                                const o = n.getAttrib(t, "name") || t.id, r = ec(e);
                                                o && e.hasVisual ? n.addClass(t, r) : n.removeClass(t, r)
                                            }
                                    }
                                })), e.dispatch("VisualAid", {element: t, hasVisual: e.hasVisual})
                            })(e, t)
                        },
                        selection: {
                            getContent: (t, n) => ((e, t, n = {}) => {
                                const o = ((e, t) => ({...e, format: t, get: !0, selection: !0, getInner: !0}))(n, t);
                                return OE(e, o).fold(R, (t => {
                                    const n = nw(e, t);
                                    return BE(e, n, t)
                                }))
                            })(e, t, n)
                        },
                        autocompleter: {
                            addDecoration: t => Ep(e, t), removeDecoration: () => ((e, t) => wp(t).each((t => {
                                const n = e.selection.getBookmark();
                                _o(t), e.selection.moveToBookmark(n)
                            })))(e, yn.fromDom(e.getBody()))
                        },
                        raw: {getModel: () => U.none()}
                    }), hw = e => ke(e.plugins, "rtc"), vw = e => {
                        const t = e;
                        return (e => Se(e.plugins, "rtc").bind((e => U.from(e.setup))))(e).fold((() => (t.rtcInstance = pw(e), U.none())), (e => (t.rtcInstance = (() => {
                            const e = T(null), t = T("");
                            return {
                                init: {bindEvents: x},
                                undoManager: {
                                    beforeChange: x,
                                    add: e,
                                    undo: e,
                                    redo: e,
                                    clear: x,
                                    reset: x,
                                    hasUndo: M,
                                    hasRedo: M,
                                    transact: e,
                                    ignore: x,
                                    extra: x
                                },
                                formatter: {
                                    match: M,
                                    matchAll: T([]),
                                    matchNode: T(void 0),
                                    canApply: M,
                                    closest: t,
                                    apply: x,
                                    remove: x,
                                    toggle: x,
                                    formatChanged: T({unbind: x})
                                },
                                editor: {
                                    getContent: t,
                                    setContent: T({content: "", html: ""}),
                                    insertContent: T(""),
                                    addVisual: x
                                },
                                selection: {getContent: t},
                                autocompleter: {addDecoration: x, removeDecoration: x},
                                raw: {getModel: T(U.none())}
                            }
                        })(), U.some((() => e().then((e => (t.rtcInstance = (e => {
                            const t = e => p(e) ? e : {}, {
                                init: n,
                                undoManager: o,
                                formatter: r,
                                editor: a,
                                selection: s,
                                autocompleter: i,
                                raw: l
                            } = e;
                            return {
                                init: {bindEvents: n.bindEvents},
                                undoManager: {
                                    beforeChange: o.beforeChange,
                                    add: o.add,
                                    undo: o.undo,
                                    redo: o.redo,
                                    clear: o.clear,
                                    reset: o.reset,
                                    hasUndo: o.hasUndo,
                                    hasRedo: o.hasRedo,
                                    transact: (e, t, n) => o.transact(n),
                                    ignore: (e, t) => o.ignore(t),
                                    extra: (e, t, n, r) => o.extra(n, r)
                                },
                                formatter: {
                                    match: (e, n, o, a) => r.match(e, t(n), a),
                                    matchAll: r.matchAll,
                                    matchNode: r.matchNode,
                                    canApply: e => r.canApply(e),
                                    closest: e => r.closest(e),
                                    apply: (e, n, o) => r.apply(e, t(n)),
                                    remove: (e, n, o, a) => r.remove(e, t(n)),
                                    toggle: (e, n, o) => r.toggle(e, t(n)),
                                    formatChanged: (e, t, n, o, a) => r.formatChanged(t, n, o, a)
                                },
                                editor: {
                                    getContent: e => a.getContent(e),
                                    setContent: (e, t) => ({content: a.setContent(e, t), html: ""}),
                                    insertContent: (e, t) => (a.insertContent(e), ""),
                                    addVisual: a.addVisual
                                },
                                selection: {getContent: (e, t) => s.getContent(t)},
                                autocompleter: {addDecoration: i.addDecoration, removeDecoration: i.removeDecoration},
                                raw: {getModel: () => U.some(l.getRawModel())}
                            }
                        })(e), e.rtc.isRemote))))))))
                    }, bw = e => e.rtcInstance ? e.rtcInstance : pw(e), yw = e => {
                        const t = e.rtcInstance;
                        if (t) return t;
                        throw new Error("Failed to get RTC instance not yet initialized.")
                    }, Cw = e => yw(e).init.bindEvents(),
                    Ew = (e, t = {}) => ((e, t, n) => yw(e).selection.getContent(t, n))(e, t.format ? t.format : "html", t),
                    ww = e => 0 === e.dom.length ? (wo(e), U.none()) : U.some(e), _w = (e, t, n, o, r) => {
                        e.bind((e => ((o ? Gh : Yh)(e.dom, o ? e.dom.length : 0, r), t.filter(Gt).map((t => ((e, t, n, o, r) => {
                            const a = e.dom, s = t.dom, i = o ? a.length : s.length;
                            o ? (Xh(a, s, r, !1, !o), n.setStart(s, i)) : (Xh(s, a, r, !1, !o), n.setEnd(s, i))
                        })(e, t, n, o, r)))))).orThunk((() => {
                            const e = ((e, t) => e.filter((e => wf.isBookmarkNode(e.dom))).bind(t ? Ln : Dn))(t, o).or(t).filter(Gt);
                            return e.map((e => ((e, t, n) => {
                                Nn(e).each((o => {
                                    const r = e.dom;
                                    t && Fh(o, rl(r, 0), n) ? Yh(r, 0, n) : !t && Uh(o, rl(r, r.length), n) && Gh(r, r.length, n)
                                }))
                            })(e, o, r)))
                        }))
                    }, Sw = (e, t, n = {}) => {
                        const o = ((e, t) => ({format: "html", ...e, set: !0, selection: !0, content: t}))(n, t);
                        PE(e, o).each((t => {
                            const n = ((e, t) => {
                                if ("raw" !== t.format) {
                                    const n = e.selection.getRng(),
                                        o = e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock),
                                        r = o ? {context: o.nodeName.toLowerCase()} : {},
                                        a = e.parser.parse(t.content, {forced_root_block: !1, ...r, ...t});
                                    return Kp({validate: !1}, e.schema).serialize(a)
                                }
                                return t.content
                            })(e, t), o = e.selection.getRng();
                            ((e, t, n) => {
                                const o = U.from(t.firstChild).map(yn.fromDom), r = U.from(t.lastChild).map(yn.fromDom);
                                e.deleteContents(), e.insertNode(t);
                                const a = o.bind(Dn).filter(Gt).bind(ww), s = r.bind(Ln).filter(Gt).bind(ww);
                                _w(a, o, e, !0, n), _w(s, r, e, !1, n), e.collapse(!1)
                            })(o, o.createContextualFragment(n), e.schema), e.selection.setRng(o), Bg(e, o), IE(e, n, t)
                        }))
                    }, kw = (e, t, n) => {
                        if (ke(e, t)) {
                            const o = X(e[t], (e => e !== n));
                            0 === o.length ? delete e[t] : e[t] = o
                        }
                    };
                var xw = (e, t) => {
                    let n, o;
                    const r = (t, n) => ee(n, (n => e.is(n, t))), a = t => e.getParents(t, void 0, e.getRoot());
                    return {
                        selectorChangedWithUnbind: (e, s) => (n || (n = {}, o = {}, t.on("NodeChange", (e => {
                            const t = e.element, s = a(t), i = {};
                            he(n, ((e, t) => {
                                r(t, s).each((n => {
                                    o[t] || (K(e, (e => {
                                        e(!0, {node: n, selector: t, parents: s})
                                    })), o[t] = e), i[t] = e
                                }))
                            })), he(o, ((e, n) => {
                                i[n] || (delete o[n], K(e, (e => {
                                    e(!1, {node: t, selector: n, parents: s})
                                })))
                            }))
                        }))), n[e] || (n[e] = []), n[e].push(s), r(e, a(t.selection.getStart())).each((() => {
                            o[e] = n[e]
                        })), {
                            unbind: () => {
                                kw(n, e, s), kw(o, e, s)
                            }
                        })
                    }
                };
                const Aw = e => !(!e || !e.ownerDocument) && Sn(yn.fromDom(e.ownerDocument), yn.fromDom(e)),
                    Nw = (e, t, n, o) => {
                        let r, a;
                        const {selectorChangedWithUnbind: s} = xw(e, o), i = (e, t) => Sw(o, e, t), l = e => {
                            const t = c();
                            t.collapse(!!e), u(t)
                        }, d = () => t.getSelection ? t.getSelection() : t.document.selection, c = () => {
                            let n;
                            const s = (e, t, n) => {
                                try {
                                    return t.compareBoundaryPoints(e, n)
                                } catch (e) {
                                    return -1
                                }
                            }, i = t.document;
                            if (w(o.bookmark) && !ip(o)) {
                                const e = Wg(o);
                                if (e.isSome()) return e.map((e => hp(o, [e])[0])).getOr(i.createRange())
                            }
                            try {
                                const e = d();
                                e && !$o(e.anchorNode) && (n = e.rangeCount > 0 ? e.getRangeAt(0) : i.createRange(), n = hp(o, [n])[0])
                            } catch (e) {
                            }
                            if (n || (n = i.createRange()), ar(n.startContainer) && n.collapsed) {
                                const t = e.getRoot();
                                n.setStart(t, 0), n.setEnd(t, 0)
                            }
                            return r && a && (0 === s(n.START_TO_START, n, r) && 0 === s(n.END_TO_END, n, r) ? n = a : (r = null, a = null)), n
                        }, u = (e, t) => {
                            if (!(e => !!e && Aw(e.startContainer) && Aw(e.endContainer))(e)) return;
                            const n = d();
                            if (e = o.dispatch("SetSelectionRange", {range: e, forward: t}).range, n) {
                                a = e;
                                try {
                                    n.removeAllRanges(), n.addRange(e)
                                } catch (e) {
                                }
                                !1 === t && n.extend && (n.collapse(e.endContainer, e.endOffset), n.extend(e.startContainer, e.startOffset)), r = n.rangeCount > 0 ? n.getRangeAt(0) : null
                            }
                            if (!e.collapsed && e.startContainer === e.endContainer && (null == n ? void 0 : n.setBaseAndExtent) && e.endOffset - e.startOffset < 2 && e.startContainer.hasChildNodes()) {
                                const t = e.startContainer.childNodes[e.startOffset];
                                t && "IMG" === t.nodeName && (n.setBaseAndExtent(e.startContainer, e.startOffset, e.endContainer, e.endOffset), n.anchorNode === e.startContainer && n.focusNode === e.endContainer || n.setBaseAndExtent(t, 0, t, 1))
                            }
                            o.dispatch("AfterSetSelectionRange", {range: e, forward: t})
                        }, m = () => {
                            const t = d(), n = null == t ? void 0 : t.anchorNode, o = null == t ? void 0 : t.focusNode;
                            if (!t || !n || !o || $o(n) || $o(o)) return !0;
                            const r = e.createRng(), a = e.createRng();
                            try {
                                r.setStart(n, t.anchorOffset), r.collapse(!0), a.setStart(o, t.focusOffset), a.collapse(!0)
                            } catch (e) {
                                return !0
                            }
                            return r.compareBoundaryPoints(r.START_TO_START, a) <= 0
                        }, f = {
                            dom: e,
                            win: t,
                            serializer: n,
                            editor: o,
                            expand: (t = {type: "word"}) => u(mg(e).expand(c(), t)),
                            collapse: l,
                            setCursorLocation: (t, n) => {
                                const r = e.createRng();
                                w(t) && w(n) ? (r.setStart(t, n), r.setEnd(t, n), u(r), l(!1)) : (Sm(e, r, o.getBody(), !0), u(r))
                            },
                            getContent: e => Ew(o, e),
                            setContent: i,
                            getBookmark: (e, t) => g.getBookmark(e, t),
                            moveToBookmark: e => g.moveToBookmark(e),
                            select: (t, n) => (((e, t, n) => U.from(t).bind((t => U.from(t.parentNode).map((o => {
                                const r = e.nodeIndex(t), a = e.createRng();
                                return a.setStart(o, r), a.setEnd(o, r + 1), n && (Sm(e, a, t, !0), Sm(e, a, t, !1)), a
                            })))))(e, t, n).each(u), t),
                            isCollapsed: () => {
                                const e = c(), t = d();
                                return !(!e || e.item) && (e.compareEndPoints ? 0 === e.compareEndPoints("StartToEnd", e) : !t || e.collapsed)
                            },
                            isEditable: () => {
                                const t = c(), n = o.getBody().querySelectorAll('[data-mce-selected="1"]');
                                return n.length > 0 ? re(n, (t => e.isEditable(t.parentElement))) : up(e, t)
                            },
                            isForward: m,
                            setNode: t => (i(e.getOuterHTML(t)), t),
                            getNode: () => ((e, t) => {
                                if (!t) return e;
                                let n = t.startContainer, o = t.endContainer;
                                const r = t.startOffset, a = t.endOffset;
                                let s = t.commonAncestorContainer;
                                t.collapsed || (n === o && a - r < 2 && n.hasChildNodes() && (s = n.childNodes[r]), tr(n) && tr(o) && (n = n.length === r ? pp(n.nextSibling, !0) : n.parentNode, o = 0 === a ? pp(o.previousSibling, !1) : o.parentNode, n && n === o && (s = n)));
                                const i = tr(s) ? s.parentNode : s;
                                return Wo(i) ? i : e
                            })(o.getBody(), c()),
                            getSel: d,
                            setRng: u,
                            getRng: c,
                            getStart: e => fp(o.getBody(), c(), e),
                            getEnd: e => gp(o.getBody(), c(), e),
                            getSelectedBlocks: (t, n) => ((e, t, n, o) => {
                                const r = [], a = e.getRoot(), s = e.getParent(n || fp(a, t, t.collapsed), e.isBlock),
                                    i = e.getParent(o || gp(a, t, t.collapsed), e.isBlock);
                                if (s && s !== a && r.push(s), s && i && s !== i) {
                                    let t;
                                    const n = new Ho(s, a);
                                    for (; (t = n.next()) && t !== i;) e.isBlock(t) && r.push(t)
                                }
                                return i && s !== i && i !== a && r.push(i), r
                            })(e, c(), t, n),
                            normalize: () => {
                                const t = c(), n = d();
                                if (!(hm(n).length > 1) && km(o)) {
                                    const n = dg(e, t);
                                    return n.each((e => {
                                        u(e, m())
                                    })), n.getOr(t)
                                }
                                return t
                            },
                            selectorChanged: (e, t) => (s(e, t), f),
                            selectorChangedWithUnbind: s,
                            getScrollContainer: () => {
                                let t, n = e.getRoot();
                                for (; n && "BODY" !== n.nodeName;) {
                                    if (n.scrollHeight > n.clientHeight) {
                                        t = n;
                                        break
                                    }
                                    n = n.parentNode
                                }
                                return t
                            },
                            scrollIntoView: (e, t) => {
                                w(e) ? ((e, t, n) => {
                                    (e.inline ? Dg : Og)(e, t, n)
                                })(o, e, t) : Bg(o, c(), t)
                            },
                            placeCaretAt: (e, t) => u(tg(e, t, o.getDoc())),
                            getBoundingClientRect: () => {
                                const e = c();
                                return e.collapsed ? rl.fromRangeStart(e).getClientRects()[0] : e.getBoundingClientRect()
                            },
                            destroy: () => {
                                t = r = a = null, p.destroy()
                            }
                        }, g = wf(f), p = Pf(f, o);
                        return f.bookmarkManager = g, f.controlSelection = p, f
                    },
                    Tw = (e, t, n) => ((e, t) => w(e) && e.hasEventListeners("PreProcess") && !t.no_events)(e, n) ? ((e, t, n) => {
                        let o;
                        const r = e.dom;
                        let a = t.cloneNode(!0);
                        const s = document.implementation;
                        if (s.createHTMLDocument) {
                            const e = s.createHTMLDocument("");
                            Bt.each("BODY" === a.nodeName ? a.childNodes : [a], (t => {
                                e.body.appendChild(e.importNode(t, !0))
                            })), a = "BODY" !== a.nodeName ? e.body.firstChild : e.body, o = r.doc, r.doc = e
                        }
                        return ((e, t) => {
                            e.dispatch("PreProcess", t)
                        })(e, {...n, node: a}), o && (r.doc = o), a
                    })(e, t, n) : t, Rw = (e, t, n) => {
                        -1 === Bt.inArray(t, n) && (e.addAttributeFilter(n, ((e, t) => {
                            let n = e.length;
                            for (; n--;) e[n].attr(t, null)
                        })), t.push(n))
                    }, Dw = (e, t, n, o, r) => {
                        const a = ((e, t, n) => Kp(e, t).serialize(n))(t, n, o);
                        return ((e, t, n) => {
                            if (!t.no_events && e) {
                                const o = ((e, t) => e.dispatch("PostProcess", t))(e, {...t, content: n});
                                return o.content
                            }
                            return n
                        })(e, r, a)
                    }, Lw = (e, t) => {
                        const n = ["data-mce-selected"],
                            o = {entity_encoding: "named", remove_trailing_brs: !0, pad_empty_with_br: !1, ...e},
                            r = t && t.dom ? t.dom : Xs.DOM, a = t && t.schema ? t.schema : ys(o), s = DE(o, a);
                        ((e, t, n) => {
                            e.addAttributeFilter("data-mce-tabindex", ((e, t) => {
                                let n = e.length;
                                for (; n--;) {
                                    const o = e[n];
                                    o.attr("tabindex", o.attr("data-mce-tabindex")), o.attr(t, null)
                                }
                            })), e.addAttributeFilter("src,href,style", ((e, o) => {
                                const r = "data-mce-" + o, a = t.url_converter, s = t.url_converter_scope;
                                let i = e.length;
                                for (; i--;) {
                                    const t = e[i];
                                    let l = t.attr(r);
                                    void 0 !== l ? (t.attr(o, l.length > 0 ? l : null), t.attr(r, null)) : (l = t.attr(o), "style" === o ? l = n.serializeStyle(n.parseStyle(l), t.name) : a && (l = a.call(s, l, o, t.name)), t.attr(o, l.length > 0 ? l : null))
                                }
                            })), e.addAttributeFilter("class", (e => {
                                let t = e.length;
                                for (; t--;) {
                                    const n = e[t];
                                    let o = n.attr("class");
                                    o && (o = o.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), n.attr("class", o.length > 0 ? o : null))
                                }
                            })), e.addAttributeFilter("data-mce-type", ((e, t, n) => {
                                let o = e.length;
                                for (; o--;) {
                                    const t = e[o];
                                    if ("bookmark" === t.attr("data-mce-type") && !n.cleanup) {
                                        const e = U.from(t.firstChild).exists((e => {
                                            var t;
                                            return !Pr(null !== (t = e.value) && void 0 !== t ? t : "")
                                        }));
                                        e ? t.unwrap() : t.remove()
                                    }
                                }
                            })), e.addNodeFilter("script,style", ((e, n) => {
                                var o;
                                const r = e => e.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
                                let a = e.length;
                                for (; a--;) {
                                    const s = e[a], i = s.firstChild,
                                        l = null !== (o = null == i ? void 0 : i.value) && void 0 !== o ? o : "";
                                    if ("script" === n) {
                                        const e = s.attr("type");
                                        e && s.attr("type", "mce-no/type" === e ? null : e.replace(/^mce\-/, "")), "xhtml" === t.element_format && i && l.length > 0 && (i.value = "// <![CDATA[\n" + r(l) + "\n// ]]>")
                                    } else "xhtml" === t.element_format && i && l.length > 0 && (i.value = "\x3c!--\n" + r(l) + "\n--\x3e")
                                }
                            })), e.addNodeFilter("#comment", (e => {
                                let o = e.length;
                                for (; o--;) {
                                    const r = e[o], a = r.value;
                                    t.preserve_cdata && 0 === (null == a ? void 0 : a.indexOf("[CDATA[")) ? (r.name = "#cdata", r.type = 4, r.value = n.decode(a.replace(/^\[CDATA\[|\]\]$/g, ""))) : 0 === (null == a ? void 0 : a.indexOf("mce:protected ")) && (r.name = "#text", r.type = 3, r.raw = !0, r.value = unescape(a).substr(14))
                                }
                            })), e.addNodeFilter("xml:namespace,input", ((e, t) => {
                                let n = e.length;
                                for (; n--;) {
                                    const o = e[n];
                                    7 === o.type ? o.remove() : 1 === o.type && ("input" !== t || o.attr("type") || o.attr("type", "text"))
                                }
                            })), e.addAttributeFilter("data-mce-type", (t => {
                                K(t, (t => {
                                    "format-caret" === t.attr("data-mce-type") && (t.isEmpty(e.schema.getNonEmptyElements()) ? t.remove() : t.unwrap())
                                }))
                            })), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", ((e, t) => {
                                let n = e.length;
                                for (; n--;) e[n].attr(t, null)
                            })), t.remove_trailing_brs && nC(t, e, e.schema)
                        })(s, o, r);
                        return {
                            schema: a,
                            addNodeFilter: s.addNodeFilter,
                            addAttributeFilter: s.addAttributeFilter,
                            serialize: (e, n = {}) => {
                                const i = {format: "html", ...n}, l = Tw(t, e, i), d = ((e, t, n) => {
                                    const o = Ir(n.getInner ? t.innerHTML : e.getOuterHTML(t));
                                    return n.selection || Rr(yn.fromDom(t)) ? o : Bt.trim(o)
                                })(r, l, i), c = ((e, t, n) => {
                                    const o = n.selection ? {forced_root_block: !1, ...n} : n, r = e.parse(t, o);
                                    return (e => {
                                        const t = e => "br" === (null == e ? void 0 : e.name), n = e.lastChild;
                                        if (t(n)) {
                                            const e = n.prev;
                                            t(e) && (n.remove(), e.remove())
                                        }
                                    })(r), r
                                })(s, d, i);
                                return "tree" === i.format ? c : Dw(t, o, a, c, i)
                            },
                            addRules: a.addValidElements,
                            setRules: a.setValidElements,
                            addTempAttr: L(Rw, s, n),
                            getTempAttrs: T(n),
                            getNodeFilters: s.getNodeFilters,
                            getAttributeFilters: s.getAttributeFilters,
                            removeNodeFilter: s.removeNodeFilter,
                            removeAttributeFilter: s.removeAttributeFilter
                        }
                    }, Ow = (e, t) => {
                        const n = Lw(e, t);
                        return {
                            schema: n.schema,
                            addNodeFilter: n.addNodeFilter,
                            addAttributeFilter: n.addAttributeFilter,
                            serialize: n.serialize,
                            addRules: n.addRules,
                            setRules: n.setRules,
                            addTempAttr: n.addTempAttr,
                            getTempAttrs: n.getTempAttrs,
                            getNodeFilters: n.getNodeFilters,
                            getAttributeFilters: n.getAttributeFilters,
                            removeNodeFilter: n.removeNodeFilter,
                            removeAttributeFilter: n.removeAttributeFilter
                        }
                    }, Bw = (e, t = {}) => {
                        const n = ((e, t) => ({...e, format: t, get: !0, getInner: !0}))(t, t.format ? t.format : "html");
                        return OE(e, n).fold(R, (t => {
                            const n = ((e, t) => bw(e).editor.getContent(t))(e, t);
                            return BE(e, n, t)
                        }))
                    }, Pw = (e, t, n = {}) => {
                        const o = ((e, t) => ({format: "html", ...e, set: !0, content: t}))(n, t);
                        return PE(e, o).map((t => {
                            const n = ((e, t, n) => bw(e).editor.setContent(t, n))(e, t.content, t);
                            return IE(e, n.html, t), n.content
                        })).getOr(t)
                    },
                    Iw = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","),
                    Mw = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","),
                    Fw = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","),
                    Uw = [{name: "template", replacedWith: "Advanced Template"}, {name: "rtc"}], qw = (e, t) => {
                        const n = X(t, (t => ke(e, t)));
                        return le(n)
                    }, jw = e => {
                        const t = qw(e, Iw), n = e.forced_root_block;
                        return !1 !== n && "" !== n || t.push("forced_root_block (false only)"), le(t)
                    }, Hw = e => qw(e, Mw), zw = (e, t) => {
                        const n = Bt.makeMap(e.plugins, " "), o = X(t, (e => ke(n, e)));
                        return le(o)
                    }, $w = e => zw(e, Fw), Vw = e => zw(e, Uw.map((e => e.name))),
                    Ww = e => ee(Uw, (t => t.name === e)).fold((() => e), (t => t.replacedWith ? `${e}, replaced by ${t.replacedWith}` : e)),
                    Kw = (e, t) => {
                        ((e, t) => {
                            const n = jw(e), o = $w(t), r = o.length > 0, a = n.length > 0, s = "mobile" === t.theme;
                            if (r || a || s) {
                                const e = "\n- ", t = s ? `\n\nThemes:${e}mobile` : "",
                                    i = r ? `\n\nPlugins:${e}${o.join(e)}` : "",
                                    l = a ? `\n\nOptions:${e}${n.join(e)}` : "";
                                console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + t + i + l)
                            }
                        })(e, t), ((e, t) => {
                            const n = Hw(e), o = Vw(t), r = o.length > 0, a = n.length > 0;
                            if (r || a) {
                                const e = "\n- ", t = r ? `\n\nPlugins:${e}${o.map(Ww).join(e)}` : "",
                                    s = a ? `\n\nOptions:${e}${n.join(e)}` : "";
                                console.warn("The following deprecated features are currently enabled but will be removed soon." + t + s)
                            }
                        })(e, t)
                    }, Yw = Xs.DOM, Gw = e => U.from(e).each((e => e.destroy())), Xw = e => {
                        if (!e.removed) {
                            const {_selectionOverrides: t, editorUpload: n} = e, o = e.getBody(), r = e.getElement();
                            o && e.save({is_removing: !0}), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && w(null == r ? void 0 : r.nextSibling) && Yw.remove(r.nextSibling), (e => {
                                e.dispatch("remove")
                            })(e), e.editorManager.remove(e), !e.inline && o && (e => {
                                Yw.setStyle(e.id, "display", e.orgDisplay)
                            })(e), (e => {
                                e.dispatch("detach")
                            })(e), Yw.remove(e.getContainer()), Gw(t), Gw(n), e.destroy()
                        }
                    }, Jw = (e, t) => {
                        const {selection: n, dom: o} = e;
                        e.destroyed || (t || e.removed ? (t || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), Gw(n), Gw(o)), (e => {
                            const t = e.formElement;
                            t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, delete t._mceOldSubmit), Yw.unbind(t, "submit reset", e.formEventDelegate))
                        })(e), (e => {
                            const t = e;
                            t.contentAreaContainer = t.formElement = t.container = t.editorContainer = null, t.bodyElement = t.contentDocument = t.contentWindow = null, t.iframeElement = t.targetElm = null;
                            const n = e.selection;
                            if (n) {
                                const e = n.dom;
                                t.selection = n.win = n.dom = e.doc = null
                            }
                        })(e), e.destroyed = !0) : e.remove())
                    }, Qw = (() => {
                        const e = {};
                        return {
                            add: (t, n) => {
                                e[t] = n
                            }, get: t => e[t] ? e[t] : {icons: {}}, has: t => ke(e, t)
                        }
                    })(), Zw = ri.ModelManager, e_ = (e, t) => t.dom[e], t_ = (e, t) => parseInt(co(t, e), 10),
                    n_ = L(e_, "clientWidth"), o_ = L(e_, "clientHeight"), r_ = L(t_, "margin-top"),
                    a_ = L(t_, "margin-left"), s_ = (e, t, n) => {
                        const o = yn.fromDom(e.getBody()),
                            r = e.inline ? o : (a = o, yn.fromDom(xn(a).dom.documentElement));
                        var a;
                        const s = ((e, t, n, o) => {
                            const r = (e => e.dom.getBoundingClientRect())(t);
                            return {
                                x: n - (e ? r.left + t.dom.clientLeft + a_(t) : 0),
                                y: o - (e ? r.top + t.dom.clientTop + r_(t) : 0)
                            }
                        })(e.inline, r, t, n);
                        return ((e, t, n) => {
                            const o = n_(e), r = o_(e);
                            return t >= 0 && n >= 0 && t <= o && n <= r
                        })(r, s.x, s.y)
                    }, i_ = e => {
                        const t = e.inline ? e.getBody() : e.getContentAreaContainer();
                        return (n = t, U.from(n).map(yn.fromDom)).map(Yn).getOr(!1);
                        var n
                    };
                const l_ = e => {
                    const t = [], n = () => {
                            const t = e.theme;
                            return t && t.getNotificationManagerImpl ? t.getNotificationManagerImpl() : (() => {
                                const e = () => {
                                    throw new Error("Theme did not provide a NotificationManager implementation.")
                                };
                                return {open: e, close: e, getArgs: e}
                            })()
                        }, o = () => U.from(t[0]), r = () => {
                            K(t, (e => {
                                e.reposition()
                            }))
                        }, a = e => {
                            te(t, (t => t === e)).each((e => {
                                t.splice(e, 1)
                            }))
                        },
                        s = (s, i = !0) => e.removed || !i_(e) ? {} : (i && e.dispatch("BeforeOpenNotification", {notification: s}), ee(t, (e => {
                            return t = n().getArgs(e), o = s, !(t.type !== o.type || t.text !== o.text || t.progressBar || t.timeout || o.progressBar || o.timeout);
                            var t, o
                        })).getOrThunk((() => {
                            e.editorManager.setActive(e);
                            const i = n().open(s, (() => {
                                a(i), r(), lp(e) && o().fold((() => e.focus()), (e => Pg(yn.fromDom(e.getEl()))))
                            }));
                            return (e => {
                                t.push(e)
                            })(i), r(), e.dispatch("OpenNotification", {notification: {...i}}), i
                        }))), i = T(t);
                    return (e => {
                        e.on("SkinLoaded", (() => {
                            const t = Nd(e);
                            t && s({text: t, type: "warning", timeout: 0}, !1), r()
                        })), e.on("show ResizeEditor ResizeWindow NodeChange", (() => {
                            requestAnimationFrame(r)
                        })), e.on("remove", (() => {
                            K(t.slice(), (e => {
                                n().close(e)
                            }))
                        }))
                    })(e), {
                        open: s, close: () => {
                            o().each((e => {
                                n().close(e), a(e), r()
                            }))
                        }, getNotifications: i
                    }
                }, d_ = ri.PluginManager, c_ = ri.ThemeManager;
                const u_ = e => {
                        let t = [];
                        const n = () => {
                            const t = e.theme;
                            return t && t.getWindowManagerImpl ? t.getWindowManagerImpl() : (() => {
                                const e = () => {
                                    throw new Error("Theme did not provide a WindowManager implementation.")
                                };
                                return {open: e, openUrl: e, alert: e, confirm: e, close: e}
                            })()
                        }, o = (e, t) => (...n) => t ? t.apply(e, n) : void 0, r = n => {
                            t.push(n), (t => {
                                e.dispatch("OpenWindow", {dialog: t})
                            })(n)
                        }, a = n => {
                            (t => {
                                e.dispatch("CloseWindow", {dialog: t})
                            })(n), t = X(t, (e => e !== n)), 0 === t.length && e.focus()
                        }, s = t => {
                            e.editorManager.setActive(e), Vg(e), e.ui.show();
                            const n = t();
                            return r(n), n
                        };
                        return e.on("remove", (() => {
                            K(t, (e => {
                                n().close(e)
                            }))
                        })), {
                            open: (e, t) => s((() => n().open(e, t, a))),
                            openUrl: e => s((() => n().openUrl(e, a))),
                            alert: (e, t, r) => {
                                const a = n();
                                a.alert(e, o(r || a, t))
                            },
                            confirm: (e, t, r) => {
                                const a = n();
                                a.confirm(e, o(r || a, t))
                            },
                            close: () => {
                                U.from(t[t.length - 1]).each((e => {
                                    n().close(e), a(e)
                                }))
                            }
                        }
                    }, m_ = (e, t) => {
                        e.notificationManager.open({type: "error", text: t})
                    }, f_ = (e, t) => {
                        e._skinLoaded ? m_(e, t) : e.on("SkinLoaded", (() => {
                            m_(e, t)
                        }))
                    }, g_ = (e, t, n) => {
                        Sf(e, t, {message: n}), console.error(n)
                    }, p_ = (e, t, n) => n ? `Failed to load ${e}: ${n} from url ${t}` : `Failed to load ${e} url: ${t}`,
                    h_ = (e, ...t) => {
                        const n = window.console;
                        n && (n.error ? n.error(e, ...t) : n.log(e, ...t))
                    }, v_ = e => "content/" + e + "/content.css", b_ = (e, t) => {
                        const n = e.editorManager.baseURL + "/skins/content", o = `content${e.editorManager.suffix}.css`;
                        return W(t, (t => (e => tinymce.Resource.has(v_(e)))(t) ? t : (e => /^[a-z0-9\-]+$/i.test(e))(t) && !e.inline ? `${n}/${t}/${o}` : e.documentBaseURI.toAbsolute(t)))
                    }, y_ = e => {
                        e.contentCSS = e.contentCSS.concat((e => b_(e, yd(e)))(e), (e => b_(e, Ed(e)))(e))
                    }, C_ = (e, t) => {
                        const n = {};
                        return {
                            findAll: (o, r = F) => {
                                const a = X((e => e ? me(e.getElementsByTagName("img")) : [])(o), (t => {
                                    const n = t.src;
                                    return !t.hasAttribute("data-mce-bogus") && (!t.hasAttribute("data-mce-placeholder") && (!(!n || n === Rt.transparentSrc) && ($e(n, "blob:") ? !e.isUploaded(n) && r(t) : !!$e(n, "data:") && r(t))))
                                })), s = W(a, (e => {
                                    const o = e.src;
                                    if (ke(n, o)) return n[o].then((t => g(t) ? t : {image: e, blobInfo: t.blobInfo}));
                                    {
                                        const r = ((e, t) => {
                                            const n = () => Promise.reject("Invalid data URI");
                                            if ($e(t, "blob:")) {
                                                const o = e.getByUri(t);
                                                return w(o) ? Promise.resolve(o) : aC(t).then((t => sC(t).then((o => lC(o, !1, (n => U.some(dC(e, t, n)))).getOrThunk(n)))))
                                            }
                                            return $e(t, "data:") ? cC(e, t).fold(n, (e => Promise.resolve(e))) : Promise.reject("Unknown image data format")
                                        })(t, o).then((t => (delete n[o], {
                                            image: e,
                                            blobInfo: t
                                        }))).catch((e => (delete n[o], e)));
                                        return n[o] = r, r
                                    }
                                }));
                                return Promise.all(s)
                            }
                        }
                    }, E_ = () => {
                        let e = {};
                        const t = (e, t) => ({status: e, resultUri: t}), n = t => t in e;
                        return {
                            hasBlobUri: n,
                            getResultUri: t => {
                                const n = e[t];
                                return n ? n.resultUri : null
                            },
                            isPending: t => !!n(t) && 1 === e[t].status,
                            isUploaded: t => !!n(t) && 2 === e[t].status,
                            markPending: n => {
                                e[n] = t(1, null)
                            },
                            markUploaded: (n, o) => {
                                e[n] = t(2, o)
                            },
                            removeFailed: t => {
                                delete e[t]
                            },
                            destroy: () => {
                                e = {}
                            }
                        }
                    };
                let w_ = 0;
                const __ = e => e + w_++ + (() => {
                        const e = () => Math.round(4294967295 * Math.random()).toString(36);
                        return "s" + (new Date).getTime().toString(36) + e() + e() + e()
                    })(), S_ = (e, t) => {
                        const n = {}, o = (e, n) => new Promise(((o, r) => {
                                const a = new XMLHttpRequest;
                                a.open("POST", t.url), a.withCredentials = t.credentials, a.upload.onprogress = e => {
                                    n(e.loaded / e.total * 100)
                                }, a.onerror = () => {
                                    r("Image upload failed due to a XHR Transport error. Code: " + a.status)
                                }, a.onload = () => {
                                    if (a.status < 200 || a.status >= 300) return void r("HTTP Error: " + a.status);
                                    const e = JSON.parse(a.responseText);
                                    var n, s;
                                    e && g(e.location) ? o((n = t.basePath, s = e.location, n ? n.replace(/\/$/, "") + "/" + s.replace(/^\//, "") : s)) : r("Invalid JSON: " + a.responseText)
                                };
                                const s = new FormData;
                                s.append("file", e.blob(), e.filename()), a.send(s)
                            })), r = _(t.handler) ? t.handler : o, a = (e, t) => ({url: t, blobInfo: e, status: !0}),
                            s = (e, t) => ({url: "", blobInfo: e, status: !1, error: t}), i = (e, t) => {
                                Bt.each(n[e], (e => {
                                    e(t)
                                })), delete n[e]
                            },
                            l = (t, o) => (t = Bt.grep(t, (t => !e.isUploaded(t.blobUri()))), Promise.all(Bt.map(t, (t => e.isPending(t.blobUri()) ? (e => {
                                const t = e.blobUri();
                                return new Promise((e => {
                                    n[t] = n[t] || [], n[t].push(e)
                                }))
                            })(t) : ((t, n, o) => (e.markPending(t.blobUri()), new Promise((r => {
                                let l, d;
                                try {
                                    const c = () => {
                                        l && (l.close(), d = x)
                                    }, u = n => {
                                        c(), e.markUploaded(t.blobUri(), n), i(t.blobUri(), a(t, n)), r(a(t, n))
                                    }, m = n => {
                                        c(), e.removeFailed(t.blobUri()), i(t.blobUri(), s(t, n)), r(s(t, n))
                                    };
                                    d = e => {
                                        e < 0 || e > 100 || U.from(l).orThunk((() => U.from(o).map(P))).each((t => {
                                            l = t, t.progressBar.value(e)
                                        }))
                                    }, n(t, d).then(u, (e => {
                                        m(g(e) ? {message: e} : e)
                                    }))
                                } catch (e) {
                                    r(s(t, e))
                                }
                            }))))(t, r, o)))));
                        return {
                            upload: (e, n) => t.url || r !== o ? l(e, n) : new Promise((e => {
                                e([])
                            }))
                        }
                    }, k_ = e => () => e.notificationManager.open({
                        text: e.translate("Image uploading..."),
                        type: "info",
                        timeout: -1,
                        progressBar: !0
                    }), x_ = (e, t) => S_(t, {url: dd(e), basePath: cd(e), credentials: ud(e), handler: md(e)}),
                    A_ = e => t => {
                        ((e, t) => e.dom.isEmpty(t.dom) && w(e.schema.getTextBlockElements()[$t(t)]))(e, t) && bo(t, yn.fromHtml('<br data-mce-bogus="1" />'))
                    }, N_ = e => {
                        const t = (() => {
                            let e = [];
                            const t = e => {
                                if (!e.blob || !e.base64) throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
                                const t = e.id || __("blobid"), n = e.name || t, o = e.blob;
                                return {
                                    id: T(t),
                                    name: T(n),
                                    filename: T(e.filename || n + "." + (r = o.type, {
                                        "image/jpeg": "jpg",
                                        "image/jpg": "jpg",
                                        "image/gif": "gif",
                                        "image/png": "png",
                                        "image/apng": "apng",
                                        "image/avif": "avif",
                                        "image/svg+xml": "svg",
                                        "image/webp": "webp",
                                        "image/bmp": "bmp",
                                        "image/tiff": "tiff"
                                    }[r.toLowerCase()] || "dat")),
                                    blob: T(o),
                                    base64: T(e.base64),
                                    blobUri: T(e.blobUri || URL.createObjectURL(o)),
                                    uri: T(e.uri)
                                };
                                var r
                            }, n = t => ee(e, t).getOrUndefined(), o = e => n((t => t.id() === e));
                            return {
                                create: (e, n, o, r, a) => {
                                    if (g(e)) return t({id: e, name: r, filename: a, blob: n, base64: o});
                                    if (p(e)) return t(e);
                                    throw new Error("Unknown input type")
                                },
                                add: t => {
                                    o(t.id()) || e.push(t)
                                },
                                get: o,
                                getByUri: e => n((t => t.blobUri() === e)),
                                getByData: (e, t) => n((n => n.base64() === e && n.blob().type === t)),
                                findFirst: n,
                                removeByUri: t => {
                                    e = X(e, (e => e.blobUri() !== t || (URL.revokeObjectURL(e.blobUri()), !1)))
                                },
                                destroy: () => {
                                    K(e, (e => {
                                        URL.revokeObjectURL(e.blobUri())
                                    })), e = []
                                }
                            }
                        })();
                        let n, o;
                        const r = E_(), a = [], s = t => n => e.selection ? t(n) : [], i = (e, t, n) => {
                                let o = 0;
                                do {
                                    o = e.indexOf(t, o), -1 !== o && (e = e.substring(0, o) + n + e.substr(o + t.length), o += n.length - t.length + 1)
                                } while (-1 !== o);
                                return e
                            }, l = (e, t, n) => {
                                const o = `src="${n}"${n === Rt.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
                                return e = i(e, `src="${t}"`, o), e = i(e, 'data-mce-src="' + t + '"', 'data-mce-src="' + n + '"')
                            }, d = (t, n) => {
                                K(e.undoManager.data, (e => {
                                    "fragmented" === e.type ? e.fragments = W(e.fragments, (e => l(e, t, n))) : e.content = l(e.content, t, n)
                                }))
                            }, c = () => (n || (n = x_(e, r)), f().then(s((o => {
                                const r = W(o, (e => e.blobInfo));
                                return n.upload(r, k_(e)).then(s((n => {
                                    const r = [];
                                    let a = !1;
                                    const s = W(n, ((n, s) => {
                                        const {blobInfo: i, image: l} = o[s];
                                        let c = !1;
                                        return n.status && sd(e) ? (n.url && !ze(l.src, n.url) && (a = !0), t.removeByUri(l.src), hw(e) || ((t, n) => {
                                            const o = e.convertURL(n, "src");
                                            var r;
                                            d(t.src, n), tn(yn.fromDom(t), {
                                                src: ad(e) ? (r = n, r + (-1 === r.indexOf("?") ? "?" : "&") + (new Date).getTime()) : n,
                                                "data-mce-src": o
                                            })
                                        })(l, n.url)) : n.error && (n.error.remove && (d(l.src, Rt.transparentSrc), r.push(l), c = !0), ((e, t) => {
                                            f_(e, oi.translate(["Failed to upload image: {0}", t]))
                                        })(e, n.error.message)), {
                                            element: l,
                                            status: n.status,
                                            uploadUri: n.url,
                                            blobInfo: i,
                                            removed: c
                                        }
                                    }));
                                    return r.length > 0 && !hw(e) ? e.undoManager.transact((() => {
                                        K(So(r), (n => {
                                            const o = Nn(n);
                                            wo(n), o.each(A_(e)), t.removeByUri(n.dom.src)
                                        }))
                                    })) : a && e.undoManager.dispatchChange(), s
                                })))
                            })))), u = () => rd(e) ? c() : Promise.resolve([]), m = e => re(a, (t => t(e))),
                            f = () => (o || (o = C_(r, t)), o.findAll(e.getBody(), m).then(s((t => {
                                const n = X(t, (t => g(t) ? (f_(e, t), !1) : "blob" !== t.uriType));
                                return hw(e) || K(n, (e => {
                                    d(e.image.src, e.blobInfo.blobUri()), e.image.src = e.blobInfo.blobUri(), e.image.removeAttribute("data-mce-src")
                                })), n
                            })))), h = n => n.replace(/src="(blob:[^"]+)"/g, ((n, o) => {
                                const a = r.getResultUri(o);
                                if (a) return 'src="' + a + '"';
                                let s = t.getByUri(o);
                                if (s || (s = Q(e.editorManager.get(), ((e, t) => e || t.editorUpload && t.editorUpload.blobCache.getByUri(o)), void 0)), s) {
                                    return 'src="data:' + s.blob().type + ";base64," + s.base64() + '"'
                                }
                                return n
                            }));
                        return e.on("SetContent", (() => {
                            rd(e) ? u() : f()
                        })), e.on("RawSaveContent", (e => {
                            e.content = h(e.content)
                        })), e.on("GetContent", (e => {
                            e.source_view || "raw" === e.format || "tree" === e.format || (e.content = h(e.content))
                        })), e.on("PostRender", (() => {
                            e.parser.addNodeFilter("img", (e => {
                                K(e, (e => {
                                    const n = e.attr("src");
                                    if (!n || t.getByUri(n)) return;
                                    const o = r.getResultUri(n);
                                    o && e.attr("src", o)
                                }))
                            }))
                        })), {
                            blobCache: t, addFilter: e => {
                                a.push(e)
                            }, uploadImages: c, uploadImagesAuto: u, scanForImages: f, destroy: () => {
                                t.destroy(), r.destroy(), o = n = null
                            }
                        }
                    }, T_ = {remove_similar: !0, inherit: !1}, R_ = {selector: "td,th", ...T_}, D_ = {
                        tablecellbackgroundcolor: {styles: {backgroundColor: "%value"}, ...R_},
                        tablecellverticalalign: {styles: {"vertical-align": "%value"}, ...R_},
                        tablecellbordercolor: {styles: {borderColor: "%value"}, ...R_},
                        tablecellclass: {classes: ["%value"], ...R_},
                        tableclass: {selector: "table", classes: ["%value"], ...T_},
                        tablecellborderstyle: {styles: {borderStyle: "%value"}, ...R_},
                        tablecellborderwidth: {styles: {borderWidth: "%value"}, ...R_}
                    }, L_ = T(D_), O_ = e => {
                        const t = {}, n = (e, o) => {
                            e && (g(e) ? (v(o) || (o = [o]), K(o, (e => {
                                C(e.deep) && (e.deep = !Wm(e)), C(e.split) && (e.split = !Wm(e) || Km(e)), C(e.remove) && Wm(e) && !Km(e) && (e.remove = "none"), Wm(e) && Km(e) && (e.mixed = !0, e.block_expand = !0), g(e.classes) && (e.classes = e.classes.split(/\s+/))
                            })), t[e] = o) : he(e, ((e, t) => {
                                n(t, e)
                            })))
                        };
                        return n((e => {
                            const t = e.dom, n = e.schema.type, o = {
                                valigntop: [{selector: "td,th", styles: {verticalAlign: "top"}}],
                                valignmiddle: [{selector: "td,th", styles: {verticalAlign: "middle"}}],
                                valignbottom: [{selector: "td,th", styles: {verticalAlign: "bottom"}}],
                                alignleft: [{
                                    selector: "figure.image",
                                    collapsed: !1,
                                    classes: "align-left",
                                    ceFalseOverride: !0,
                                    preview: "font-family font-size"
                                }, {
                                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                    styles: {textAlign: "left"},
                                    inherit: !1,
                                    preview: !1
                                }, {
                                    selector: "img,audio,video",
                                    collapsed: !1,
                                    styles: {float: "left"},
                                    preview: "font-family font-size"
                                }, {
                                    selector: "table",
                                    collapsed: !1,
                                    styles: {marginLeft: "0px", marginRight: "auto"},
                                    onformat: e => {
                                        t.setStyle(e, "float", null)
                                    },
                                    preview: "font-family font-size"
                                }, {
                                    selector: ".mce-preview-object,[data-ephox-embed-iri]",
                                    ceFalseOverride: !0,
                                    styles: {float: "left"}
                                }],
                                aligncenter: [{
                                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                    styles: {textAlign: "center"},
                                    inherit: !1,
                                    preview: "font-family font-size"
                                }, {
                                    selector: "figure.image",
                                    collapsed: !1,
                                    classes: "align-center",
                                    ceFalseOverride: !0,
                                    preview: "font-family font-size"
                                }, {
                                    selector: "img,audio,video",
                                    collapsed: !1,
                                    styles: {display: "block", marginLeft: "auto", marginRight: "auto"},
                                    preview: !1
                                }, {
                                    selector: "table",
                                    collapsed: !1,
                                    styles: {marginLeft: "auto", marginRight: "auto"},
                                    preview: "font-family font-size"
                                }, {
                                    selector: ".mce-preview-object",
                                    ceFalseOverride: !0,
                                    styles: {display: "table", marginLeft: "auto", marginRight: "auto"},
                                    preview: !1
                                }, {
                                    selector: "[data-ephox-embed-iri]",
                                    ceFalseOverride: !0,
                                    styles: {marginLeft: "auto", marginRight: "auto"},
                                    preview: !1
                                }],
                                alignright: [{
                                    selector: "figure.image",
                                    collapsed: !1,
                                    classes: "align-right",
                                    ceFalseOverride: !0,
                                    preview: "font-family font-size"
                                }, {
                                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                    styles: {textAlign: "right"},
                                    inherit: !1,
                                    preview: "font-family font-size"
                                }, {
                                    selector: "img,audio,video",
                                    collapsed: !1,
                                    styles: {float: "right"},
                                    preview: "font-family font-size"
                                }, {
                                    selector: "table",
                                    collapsed: !1,
                                    styles: {marginRight: "0px", marginLeft: "auto"},
                                    onformat: e => {
                                        t.setStyle(e, "float", null)
                                    },
                                    preview: "font-family font-size"
                                }, {
                                    selector: ".mce-preview-object,[data-ephox-embed-iri]",
                                    ceFalseOverride: !0,
                                    styles: {float: "right"},
                                    preview: !1
                                }],
                                alignjustify: [{
                                    selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                                    styles: {textAlign: "justify"},
                                    inherit: !1,
                                    preview: "font-family font-size"
                                }],
                                bold: [{
                                    inline: "strong",
                                    remove: "all",
                                    preserve_attributes: ["class", "style"]
                                }, {inline: "span", styles: {fontWeight: "bold"}}, {
                                    inline: "b",
                                    remove: "all",
                                    preserve_attributes: ["class", "style"]
                                }],
                                italic: [{
                                    inline: "em",
                                    remove: "all",
                                    preserve_attributes: ["class", "style"]
                                }, {inline: "span", styles: {fontStyle: "italic"}}, {
                                    inline: "i",
                                    remove: "all",
                                    preserve_attributes: ["class", "style"]
                                }],
                                underline: [{
                                    inline: "span",
                                    styles: {textDecoration: "underline"},
                                    exact: !0
                                }, {inline: "u", remove: "all", preserve_attributes: ["class", "style"]}],
                                strikethrough: (() => {
                                    const e = {inline: "span", styles: {textDecoration: "line-through"}, exact: !0},
                                        t = {inline: "strike", remove: "all", preserve_attributes: ["class", "style"]},
                                        o = {inline: "s", remove: "all", preserve_attributes: ["class", "style"]};
                                    return "html4" !== n ? [o, e, t] : [e, o, t]
                                })(),
                                forecolor: {
                                    inline: "span",
                                    styles: {color: "%value"},
                                    links: !0,
                                    remove_similar: !0,
                                    clear_child_styles: !0
                                },
                                hilitecolor: {
                                    inline: "span",
                                    styles: {backgroundColor: "%value"},
                                    links: !0,
                                    remove_similar: !0,
                                    clear_child_styles: !0
                                },
                                fontname: {
                                    inline: "span",
                                    toggle: !1,
                                    styles: {fontFamily: "%value"},
                                    clear_child_styles: !0
                                },
                                fontsize: {
                                    inline: "span",
                                    toggle: !1,
                                    styles: {fontSize: "%value"},
                                    clear_child_styles: !0
                                },
                                lineheight: {selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div", styles: {lineHeight: "%value"}},
                                fontsize_class: {inline: "span", attributes: {class: "%value"}},
                                blockquote: {block: "blockquote", wrapper: !0, remove: "all"},
                                subscript: {inline: "sub"},
                                superscript: {inline: "sup"},
                                code: {inline: "code"},
                                link: {
                                    inline: "a",
                                    selector: "a",
                                    remove: "all",
                                    split: !0,
                                    deep: !0,
                                    onmatch: (e, t, n) => Vo(e) && e.hasAttribute("href"),
                                    onformat: (e, n, o) => {
                                        Bt.each(o, ((n, o) => {
                                            t.setAttrib(e, o, n)
                                        }))
                                    }
                                },
                                lang: {
                                    inline: "span",
                                    clear_child_styles: !0,
                                    remove_similar: !0,
                                    attributes: {
                                        lang: "%value", "data-mce-lang": e => {
                                            var t;
                                            return null !== (t = null == e ? void 0 : e.customValue) && void 0 !== t ? t : null
                                        }
                                    }
                                },
                                removeformat: [{
                                    selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
                                    remove: "all",
                                    split: !0,
                                    expand: !1,
                                    block_expand: !0,
                                    deep: !0
                                }, {
                                    selector: "span",
                                    attributes: ["style", "class"],
                                    remove: "empty",
                                    split: !0,
                                    expand: !1,
                                    deep: !0
                                }, {selector: "*", attributes: ["style", "class"], split: !1, expand: !1, deep: !0}]
                            };
                            return Bt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (e => {
                                o[e] = {block: e, remove: "all"}
                            })), o
                        })(e)), n(L_()), n(Bd(e)), {
                            get: e => w(e) ? t[e] : t,
                            has: e => ke(t, e),
                            register: n,
                            unregister: e => (e && t[e] && delete t[e], t)
                        }
                    }, B_ = Bt.each, P_ = Xs.DOM, I_ = e => w(e) && p(e), M_ = (e, t) => {
                        const n = t && t.schema || ys({}), o = e => {
                            const t = g(e) ? {name: e, classes: [], attrs: {}} : e, n = P_.create(t.name);
                            return ((e, t) => {
                                t.classes.length > 0 && P_.addClass(e, t.classes.join(" ")), P_.setAttribs(e, t.attrs)
                            })(n, t), n
                        }, r = (e, t, a) => {
                            let s;
                            const i = t[0], l = I_(i) ? i.name : void 0, d = ((e, t) => {
                                const o = n.getElementRule(e.nodeName.toLowerCase()),
                                    r = null == o ? void 0 : o.parentsRequired;
                                return !(!r || !r.length) && (t && $(r, t) ? t : r[0])
                            })(e, l);
                            if (d) l === d ? (s = i, t = t.slice(1)) : s = d; else if (i) s = i, t = t.slice(1); else if (!a) return e;
                            const c = s ? o(s) : P_.create("div");
                            c.appendChild(e), a && Bt.each(a, (t => {
                                const n = o(t);
                                c.insertBefore(n, e)
                            }));
                            const u = I_(s) ? s.siblings : void 0;
                            return r(c, t, u)
                        }, a = P_.create("div");
                        if (e.length > 0) {
                            const t = e[0], n = o(t), s = I_(t) ? t.siblings : void 0;
                            a.appendChild(r(n, e.slice(1), s))
                        }
                        return a
                    }, F_ = e => {
                        let t = "div";
                        const n = {name: t, classes: [], attrs: {}, selector: e = Bt.trim(e)};
                        return "*" !== e && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ((e, t, o, r, a) => {
                            switch (t) {
                                case"#":
                                    n.attrs.id = o;
                                    break;
                                case".":
                                    n.classes.push(o);
                                    break;
                                case":":
                                    -1 !== Bt.inArray("checked disabled enabled read-only required".split(" "), o) && (n.attrs[o] = o)
                            }
                            if ("[" === r) {
                                const e = a.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                                e && (n.attrs[e[1]] = e[2])
                            }
                            return ""
                        }))), n.name = t || "div", n
                    }, U_ = (e, t) => {
                        let n = "", o = Pd(e);
                        if ("" === o) return "";
                        const r = e => g(e) ? e.replace(/%(\w+)/g, "") : "",
                            a = (t, n) => P_.getStyle(null != n ? n : e.getBody(), t, !0);
                        if (g(t)) {
                            const n = e.formatter.get(t);
                            if (!n) return "";
                            t = n[0]
                        }
                        if ("preview" in t) {
                            const e = t.preview;
                            if (!1 === e) return "";
                            o = e || o
                        }
                        let s, i = t.block || t.inline || "span";
                        const l = (d = t.selector, g(d) ? (d = (d = d.split(/\s*,\s*/)[0]).replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Bt.map(d.split(/(?:>|\s+(?![^\[\]]+\]))/), (e => {
                            const t = Bt.map(e.split(/(?:~\+|~|\+)/), F_), n = t.pop();
                            return t.length && (n.siblings = t), n
                        })).reverse()) : []);
                        var d;
                        l.length > 0 ? (l[0].name || (l[0].name = i), i = t.selector, s = M_(l, e)) : s = M_([i], e);
                        const c = P_.select(i, s)[0] || s.firstChild;
                        B_(t.styles, ((e, t) => {
                            const n = r(e);
                            n && P_.setStyle(c, t, n)
                        })), B_(t.attributes, ((e, t) => {
                            const n = r(e);
                            n && P_.setAttrib(c, t, n)
                        })), B_(t.classes, (e => {
                            const t = r(e);
                            P_.hasClass(c, t) || P_.addClass(c, t)
                        })), e.dispatch("PreviewFormats"), P_.setStyles(s, {
                            position: "absolute",
                            left: -65535
                        }), e.getBody().appendChild(s);
                        const u = a("fontSize"), m = /px$/.test(u) ? parseInt(u, 10) : 0;
                        return B_(o.split(" "), (e => {
                            let t = a(e, c);
                            if (!("background-color" === e && /transparent|rgba\s*\([^)]+,\s*0\)/.test(t) && (t = a(e), "#ffffff" === Ts(t).toLowerCase()) || "color" === e && "#000000" === Ts(t).toLowerCase())) {
                                if ("font-size" === e && /em|%$/.test(t)) {
                                    if (0 === m) return;
                                    t = parseFloat(t) / (/%$/.test(t) ? 100 : 1) * m + "px"
                                }
                                "border" === e && t && (n += "padding:0 2px;"), n += e + ":" + t + ";"
                            }
                        })), e.dispatch("AfterPreviewFormats"), P_.remove(s), n
                    }, q_ = e => {
                        const t = O_(e), n = Zs({});
                        return (e => {
                            e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
                            for (let t = 1; t <= 6; t++) e.addShortcut("access+" + t, "", ["FormatBlock", !1, "h" + t]);
                            e.addShortcut("access+7", "", ["FormatBlock", !1, "p"]), e.addShortcut("access+8", "", ["FormatBlock", !1, "div"]), e.addShortcut("access+9", "", ["FormatBlock", !1, "address"])
                        })(e), ey(e), hw(e) || ((e, t) => {
                            e.set({}), t.on("NodeChange", (n => {
                                Xy(t, n.element, e.get())
                            })), t.on("FormatApply FormatRemove", (n => {
                                const o = U.from(n.node).map((e => Nm(e) ? e : e.startContainer)).bind((e => Vo(e) ? U.some(e) : U.from(e.parentElement))).getOrThunk((() => Ky(t)));
                                Xy(t, o, e.get())
                            }))
                        })(n, e), {
                            get: t.get,
                            has: t.has,
                            register: t.register,
                            unregister: t.unregister,
                            apply: (t, n, o) => {
                                ((e, t, n, o) => {
                                    yw(e).formatter.apply(t, n, o)
                                })(e, t, n, o)
                            },
                            remove: (t, n, o, r) => {
                                ((e, t, n, o, r) => {
                                    yw(e).formatter.remove(t, n, o, r)
                                })(e, t, n, o, r)
                            },
                            toggle: (t, n, o) => {
                                ((e, t, n, o) => {
                                    yw(e).formatter.toggle(t, n, o)
                                })(e, t, n, o)
                            },
                            match: (t, n, o, r) => ((e, t, n, o, r) => yw(e).formatter.match(t, n, o, r))(e, t, n, o, r),
                            closest: t => ((e, t) => yw(e).formatter.closest(t))(e, t),
                            matchAll: (t, n) => ((e, t, n) => yw(e).formatter.matchAll(t, n))(e, t, n),
                            matchNode: (t, n, o, r) => ((e, t, n, o, r) => yw(e).formatter.matchNode(t, n, o, r))(e, t, n, o, r),
                            canApply: t => ((e, t) => yw(e).formatter.canApply(t))(e, t),
                            formatChanged: (t, o, r, a) => ((e, t, n, o, r, a) => yw(e).formatter.formatChanged(t, n, o, r, a))(e, n, t, o, r, a),
                            getCssText: L(U_, e)
                        }
                    }, j_ = e => {
                        switch (e.toLowerCase()) {
                            case"undo":
                            case"redo":
                            case"mcefocus":
                                return !0;
                            default:
                                return !1
                        }
                    }, H_ = e => {
                        const t = si(), n = Zs(0), o = Zs(0), r = {
                            data: [],
                            typing: !1,
                            beforeChange: () => {
                                ((e, t, n) => {
                                    yw(e).undoManager.beforeChange(t, n)
                                })(e, n, t)
                            },
                            add: (a, s) => ((e, t, n, o, r, a, s) => yw(e).undoManager.add(t, n, o, r, a, s))(e, r, o, n, t, a, s),
                            dispatchChange: () => {
                                e.setDirty(!0);
                                const t = iw(e);
                                t.bookmark = xl(e.selection), e.dispatch("change", {
                                    level: t,
                                    lastLevel: de(r.data, o.get()).getOrUndefined()
                                })
                            },
                            undo: () => ((e, t, n, o) => yw(e).undoManager.undo(t, n, o))(e, r, n, o),
                            redo: () => ((e, t, n) => yw(e).undoManager.redo(t, n))(e, o, r.data),
                            clear: () => {
                                ((e, t, n) => {
                                    yw(e).undoManager.clear(t, n)
                                })(e, r, o)
                            },
                            reset: () => {
                                ((e, t) => {
                                    yw(e).undoManager.reset(t)
                                })(e, r)
                            },
                            hasUndo: () => ((e, t, n) => yw(e).undoManager.hasUndo(t, n))(e, r, o),
                            hasRedo: () => ((e, t, n) => yw(e).undoManager.hasRedo(t, n))(e, r, o),
                            transact: t => ((e, t, n, o) => yw(e).undoManager.transact(t, n, o))(e, r, n, t),
                            ignore: t => {
                                ((e, t, n) => {
                                    yw(e).undoManager.ignore(t, n)
                                })(e, n, t)
                            },
                            extra: (t, n) => {
                                ((e, t, n, o, r) => {
                                    yw(e).undoManager.extra(t, n, o, r)
                                })(e, r, o, t, n)
                            }
                        };
                        return hw(e) || ((e, t, n) => {
                            const o = Zs(!1), r = e => {
                                fw(t, !1, n), t.add({}, e)
                            };
                            e.on("init", (() => {
                                t.add()
                            })), e.on("BeforeExecCommand", (e => {
                                const o = e.command;
                                j_(o) || (gw(t, n), t.beforeChange())
                            })), e.on("ExecCommand", (e => {
                                const t = e.command;
                                j_(t) || r(e)
                            })), e.on("ObjectResizeStart cut", (() => {
                                t.beforeChange()
                            })), e.on("SaveContent ObjectResized blur", r), e.on("dragend", r), e.on("keyup", (n => {
                                const a = n.keyCode;
                                if (n.isDefaultPrevented()) return;
                                const s = Rt.os.isMacOS() && "Meta" === n.key;
                                (a >= 33 && a <= 36 || a >= 37 && a <= 40 || 45 === a || n.ctrlKey || s) && (r(), e.nodeChanged()), 46 !== a && 8 !== a || e.nodeChanged(), o.get() && t.typing && !uw(iw(e), t.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), o.set(!1), e.nodeChanged())
                            })), e.on("keydown", (e => {
                                const a = e.keyCode;
                                if (e.isDefaultPrevented()) return;
                                if (a >= 33 && a <= 36 || a >= 37 && a <= 40 || 45 === a) return void (t.typing && r(e));
                                const s = e.ctrlKey && !e.altKey || e.metaKey;
                                if ((a < 16 || a > 20) && 224 !== a && 91 !== a && !t.typing && !s) return t.beforeChange(), fw(t, !0, n), t.add({}, e), void o.set(!0);
                                (Rt.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey) && t.beforeChange()
                            })), e.on("mousedown", (e => {
                                t.typing && r(e)
                            })), e.on("input", (e => {
                                e.inputType && ((e => "insertReplacementText" === e.inputType)(e) || (e => "insertText" === e.inputType && null === e.data)(e) || (e => "insertFromPaste" === e.inputType || "insertFromDrop" === e.inputType)(e)) && r(e)
                            })), e.on("AddUndo Undo Redo ClearUndos", (t => {
                                t.isDefaultPrevented() || e.nodeChanged()
                            }))
                        })(e, r, n), (e => {
                            e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo")
                        })(e), r
                    },
                    z_ = [9, 27, Rf.HOME, Rf.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, Rf.DOWN, Rf.UP, Rf.LEFT, Rf.RIGHT].concat(Rt.browser.isFirefox() ? [224] : []),
                    $_ = "data-mce-placeholder", V_ = e => "keydown" === e.type || "keyup" === e.type, W_ = e => {
                        const t = e.keyCode;
                        return t === Rf.BACKSPACE || t === Rf.DELETE
                    }, K_ = e => {
                        var t;
                        const n = e.dom, o = Jl(e), r = null !== (t = xd(e)) && void 0 !== t ? t : "", a = (t, s) => {
                            if ((e => {
                                if (V_(e)) {
                                    const t = e.keyCode;
                                    return !W_(e) && (Rf.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || $(z_, t))
                                }
                                return !1
                            })(t)) return;
                            const i = e.getBody(),
                                l = !(e => V_(e) && !(W_(e) || "keyup" === e.type && 229 === e.keyCode))(t) && ((e, t, n) => {
                                    if (ya(yn.fromDom(t), !1)) {
                                        const o = t.firstElementChild;
                                        return !o || !e.getStyle(t.firstElementChild, "padding-left") && !e.getStyle(t.firstElementChild, "padding-right") && n === o.nodeName.toLowerCase()
                                    }
                                    return !1
                                })(n, i, o);
                            ("" !== n.getAttrib(i, $_) !== l || s) && (n.setAttrib(i, $_, l ? r : null), n.setAttrib(i, "aria-placeholder", l ? r : null), ((e, t) => {
                                e.dispatch("PlaceholderToggle", {state: t})
                            })(e, l), e.on(l ? "keydown" : "keyup", a), e.off(l ? "keyup" : "keydown", a))
                        };
                        Xe(r) && e.on("init", (t => {
                            a(t, !0), e.on("change SetContent ExecCommand", a), e.on("paste", (t => Yg.setEditorTimeout(e, (() => a(t)))))
                        }))
                    }, Y_ = (e, t) => ({from: e, to: t}), G_ = (e, t) => {
                        const n = yn.fromDom(e), o = yn.fromDom(t.container());
                        return vv(n, o).map((e => ((e, t) => ({block: e, position: t}))(e, t)))
                    }, X_ = (e, t) => Jn(t, (e => Tr(e) || dr(e.dom)), (t => _n(t, e))).filter(Yt).getOr(e),
                    J_ = (e, t, n) => {
                        const o = G_(e, rl.fromRangeStart(n)),
                            r = o.bind((n => Hu(t, e, n.position).bind((n => G_(e, n).map((n => ((e, t, n) => ir(n.position.getNode()) && !ya(n.block) ? Vu(!1, n.block.dom).bind((o => o.isEqual(n.position) ? Hu(t, e, o).bind((t => G_(e, t))) : U.some(n))).getOr(n) : n)(e, t, n)))))));
                        return Mt(o, r, Y_).filter((t => (e => !_n(e.from.block, e.to.block))(t) && ((e, t) => {
                            const n = yn.fromDom(e);
                            return _n(X_(n, t.from.block), X_(n, t.to.block))
                        })(e, t) && (e => !1 === cr(e.from.block.dom) && !1 === cr(e.to.block.dom))(t) && (e => {
                            const t = e => kr(e) || La(e.dom);
                            return t(e.from.block) && t(e.to.block)
                        })(t)))
                    }, Q_ = (e, t) => {
                        const n = ((e, t) => {
                            const n = Pn(e);
                            return te(n, (e => t.isBlock($t(e)))).fold(T(n), (e => n.slice(0, e)))
                        })(e, t);
                        return K(n, wo), n
                    }, Z_ = (e, t) => {
                        const n = ph(t, e);
                        return ee(n.reverse(), (e => ya(e))).each(wo)
                    }, eS = (e, t, n, o, r) => {
                        if (ya(n)) return Or(n), Yu(n.dom);
                        0 === X(On(r), (e => !ya(e))).length && ya(t) && po(r, yn.fromTag("br"));
                        const a = Ku(n.dom, rl.before(r.dom));
                        return K(Q_(t, o), (e => {
                            po(r, e)
                        })), Z_(e, t), a
                    }, tS = (e, t, n, o) => {
                        if (ya(n)) {
                            if (ya(t)) {
                                const e = e => {
                                    const t = (e, n) => Mn(e).fold((() => n), (e => ((e, t) => e.isInline($t(t)))(o, e) ? t(e, n.concat(Si(e))) : n));
                                    return t(e, [])
                                }, r = J(e(n), ((e, t) => (yo(e, t), t)), Lr());
                                Eo(t), bo(t, r)
                            }
                            return wo(n), Yu(t.dom)
                        }
                        const r = Gu(n.dom);
                        return K(Q_(t, o), (e => {
                            bo(n, e)
                        })), Z_(e, t), r
                    }, nS = (e, t) => Sn(t, e) ? ((e, t) => {
                        const n = ph(t, e);
                        return U.from(n[n.length - 1])
                    })(t, e) : U.none(), oS = (e, t) => {
                        Vu(e, t.dom).bind((e => U.from(e.getNode()))).map(yn.fromDom).filter(Sr).each(wo)
                    }, rS = (e, t, n, o) => (oS(!0, t), oS(!1, n), nS(t, n).fold(L(tS, e, t, n, o), L(eS, e, t, n, o))),
                    aS = (e, t, n, o, r) => t ? rS(e, o, n, r) : rS(e, n, o, r), sS = (e, t) => {
                        const n = yn.fromDom(e.getBody()),
                            o = ((e, t, n) => n.collapsed ? J_(e, t, n) : U.none())(n.dom, t, e.selection.getRng()).map((o => () => {
                                aS(n, t, o.from.block, o.to.block, e.schema).each((t => {
                                    e.selection.setRng(t.toRange())
                                }))
                            }));
                        return o
                    }, iS = (e, t) => {
                        const n = yn.fromDom(t), o = L(_n, e);
                        return Xn(n, Tr, o).isSome()
                    }, lS = (e, t) => {
                        const n = Ku(e.dom, rl.fromRangeStart(t)).isNone(), o = Wu(e.dom, rl.fromRangeEnd(t)).isNone();
                        return !((e, t) => iS(e, t.startContainer) || iS(e, t.endContainer))(e, t) && n && o
                    }, dS = e => {
                        const t = yn.fromDom(e.getBody()), n = e.selection.getRng();
                        return lS(t, n) ? (e => U.some((() => {
                            e.setContent(""), e.selection.setCursorLocation()
                        })))(e) : ((e, t, n) => {
                            const o = t.getRng();
                            return Mt(vv(e, yn.fromDom(o.startContainer)), vv(e, yn.fromDom(o.endContainer)), ((r, a) => _n(r, a) ? U.none() : U.some((() => {
                                o.deleteContents(), aS(e, !0, r, a, n).each((e => {
                                    t.setRng(e.toRange())
                                }))
                            })))).getOr(U.none())
                        })(t, e.selection, e.schema)
                    }, cS = (e, t) => e.selection.isCollapsed() ? U.none() : dS(e),
                    uS = (e, t, n, o, r) => U.from(t._selectionOverrides.showCaret(e, n, o, r)),
                    mS = (e, t) => e.dispatch("BeforeObjectSelected", {target: t}).isDefaultPrevented() ? U.none() : U.some((e => {
                        const t = e.ownerDocument.createRange();
                        return t.selectNode(e), t
                    })(t)), fS = (e, t, n) => t.collapsed ? ((e, t, n) => {
                        const o = Cu(1, e.getBody(), t), r = rl.fromRangeStart(o), a = r.getNode();
                        if (Jc(a)) return uS(1, e, a, !r.isAtEnd(), !1);
                        const s = r.getNode(!0);
                        if (Jc(s)) return uS(1, e, s, !1, !1);
                        const i = tb(e.dom.getRoot(), r.getNode());
                        return Jc(i) ? uS(1, e, i, !1, n) : U.none()
                    })(e, t, n).getOr(t) : t, gS = e => mh(e) || lh(e), pS = e => fh(e) || dh(e),
                    hS = (e, t, n, o, r, a) => {
                        uS(o, e, a.getNode(!r), r, !0).each((n => {
                            if (t.collapsed) {
                                const e = t.cloneRange();
                                r ? e.setEnd(n.startContainer, n.startOffset) : e.setStart(n.endContainer, n.endOffset), e.deleteContents()
                            } else t.deleteContents();
                            e.selection.setRng(n)
                        })), ((e, t) => {
                            tr(t) && 0 === t.data.length && e.remove(t)
                        })(e.dom, n)
                    }, vS = (e, t) => ((e, t) => {
                        const n = e.selection.getRng();
                        if (!tr(n.commonAncestorContainer)) return U.none();
                        const o = t ? xu.Forwards : xu.Backwards, r = Mu(e.getBody()), a = L(Su, t ? r.next : r.prev),
                            s = t ? gS : pS, i = wu(o, e.getBody(), n), l = a(i), d = l ? uv(t, l) : l;
                        if (!d || !ku(i, d)) return U.none();
                        if (s(d)) return U.some((() => hS(e, n, i.getNode(), o, t, d)));
                        const c = a(d);
                        return c && s(c) && ku(d, c) ? U.some((() => hS(e, n, i.getNode(), o, t, c))) : U.none()
                    })(e, t), bS = (e, t) => {
                        const n = e.getBody();
                        return t ? Yu(n).filter(mh) : Gu(n).filter(fh)
                    }, yS = e => {
                        const t = e.selection.getRng();
                        return !t.collapsed && (bS(e, !0).exists((e => e.isEqual(rl.fromRangeStart(t)))) || bS(e, !1).exists((e => e.isEqual(rl.fromRangeEnd(t)))))
                    }, CS = Rl([{remove: ["element"]}, {moveToElement: ["element"]}, {moveToPosition: ["position"]}]),
                    ES = (e, t, n, o) => {
                        const r = o.getNode(!t);
                        return vv(yn.fromDom(e), yn.fromDom(n.getNode())).map((e => ya(e) ? CS.remove(e.dom) : CS.moveToElement(r))).orThunk((() => U.some(CS.moveToElement(r))))
                    }, wS = (e, t, n, o) => Hu(t, e, n).bind((r => {
                        return a = r.getNode(), w(a) && (Tr(yn.fromDom(a)) || Ar(yn.fromDom(a))) || ((e, t, n, o, r) => {
                            const a = t => r.isInline(t.nodeName.toLowerCase()) && !fu(n, o, e);
                            return Eu(!t, n).fold((() => Eu(t, o).fold(M, a)), a)
                        })(e, t, n, r, o) ? U.none() : t && cr(r.getNode()) || !t && cr(r.getNode(!0)) ? ES(e, t, n, r) : t && fh(n) || !t && mh(n) ? U.some(CS.moveToPosition(r)) : U.none();
                        var a
                    })), _S = (e, t, n, o) => ((e, t) => {
                        const n = t.getNode(!e), o = e ? "after" : "before";
                        return Vo(n) && n.getAttribute("data-mce-caret") === o
                    })(t, n) ? ((e, t) => E(t) ? U.none() : e && cr(t.nextSibling) ? U.some(CS.moveToElement(t.nextSibling)) : !e && cr(t.previousSibling) ? U.some(CS.moveToElement(t.previousSibling)) : U.none())(t, n.getNode(!t)).orThunk((() => wS(e, t, n, o))) : wS(e, t, n, o).bind((t => ((e, t, n) => n.fold((e => U.some(CS.remove(e))), (e => U.some(CS.moveToElement(e))), (n => fu(t, n, e) ? U.none() : U.some(CS.moveToPosition(n)))))(e, n, t))),
                    SS = (e, t) => U.from(tb(e.getBody(), t)), kS = (e, t) => {
                        const n = e.selection.getNode();
                        return SS(e, n).filter(cr).fold((() => ((e, t, n, o) => {
                            const r = Cu(t ? 1 : -1, e, n), a = rl.fromRangeStart(r), s = yn.fromDom(e);
                            return !t && fh(a) ? U.some(CS.remove(a.getNode(!0))) : t && mh(a) ? U.some(CS.remove(a.getNode())) : !t && mh(a) && Ah(s, a, o) ? Nh(s, a, o).map((e => CS.remove(e.getNode()))) : t && fh(a) && xh(s, a, o) ? Th(s, a, o).map((e => CS.remove(e.getNode()))) : _S(e, t, a, o)
                        })(e.getBody(), t, e.selection.getRng(), e.schema).map((n => () => n.fold(((e, t) => n => (e._selectionOverrides.hideFakeCaret(), sv(e, t, yn.fromDom(n)), !0))(e, t), ((e, t) => n => {
                            const o = t ? rl.before(n) : rl.after(n);
                            return e.selection.setRng(o.toRange()), !0
                        })(e, t), (e => t => (e.selection.setRng(t.toRange()), !0))(e))))), (() => U.some(x)))
                    }, xS = (e, t) => {
                        const n = e.selection.getNode();
                        if (cr(n) && !ur(n)) {
                            return SS(e, n.parentNode).filter(cr).fold((() => U.some((() => {
                                var n;
                                n = yn.fromDom(e.getBody()), K(qo(n, ".mce-offscreen-selection"), wo), sv(e, t, yn.fromDom(e.selection.getNode())), bv(e)
                            }))), (() => U.some(x)))
                        }
                        return yS(e) ? U.some((() => {
                            Ev(e, e.selection.getRng(), yn.fromDom(e.getBody()))
                        })) : U.none()
                    }, AS = e => {
                        const t = e.dom, n = e.selection, o = tb(e.getBody(), n.getNode());
                        if (dr(o) && t.isBlock(o) && t.isEmpty(o)) {
                            const e = t.create("br", {"data-mce-bogus": "1"});
                            t.setHTML(o, ""), o.appendChild(e), n.setRng(rl.before(e).toRange())
                        }
                        return !0
                    }, NS = (e, t) => e.selection.isCollapsed() ? kS(e, t) : xS(e, t),
                    TS = (e, t) => e.selection.isCollapsed() ? ((e, t) => {
                        const n = rl.fromRangeStart(e.selection.getRng());
                        return Hu(t, e.getBody(), n).filter((e => t ? sh(e) : ih(e))).bind((e => gu(t ? 0 : -1, e))).map((t => () => e.selection.select(t)))
                    })(e, t) : U.none(), RS = tr, DS = e => RS(e) && e.data[0] === Br,
                    LS = e => RS(e) && e.data[e.data.length - 1] === Br, OS = e => {
                        var t;
                        return (null !== (t = e.ownerDocument) && void 0 !== t ? t : document).createTextNode(Br)
                    }, BS = (e, t) => e ? (e => {
                        var t;
                        if (RS(e.previousSibling)) return LS(e.previousSibling) || e.previousSibling.appendData(Br), e.previousSibling;
                        if (RS(e)) return DS(e) || e.insertData(0, Br), e;
                        {
                            const n = OS(e);
                            return null === (t = e.parentNode) || void 0 === t || t.insertBefore(n, e), n
                        }
                    })(t) : (e => {
                        var t, n;
                        if (RS(e.nextSibling)) return DS(e.nextSibling) || e.nextSibling.insertData(0, Br), e.nextSibling;
                        if (RS(e)) return LS(e) || e.appendData(Br), e;
                        {
                            const o = OS(e);
                            return e.nextSibling ? null === (t = e.parentNode) || void 0 === t || t.insertBefore(o, e.nextSibling) : null === (n = e.parentNode) || void 0 === n || n.appendChild(o), o
                        }
                    })(t), PS = L(BS, !0), IS = L(BS, !1),
                    MS = (e, t) => tr(e.container()) ? BS(t, e.container()) : BS(t, e.getNode()), FS = (e, t) => {
                        const n = t.get();
                        return n && e.container() === n && qr(n)
                    }, US = (e, t) => t.fold((t => {
                        $c(e.get());
                        const n = PS(t);
                        return e.set(n), U.some(rl(n, n.length - 1))
                    }), (t => Yu(t).map((t => {
                        if (FS(t, e)) {
                            const t = e.get();
                            return rl(t, 1)
                        }
                        {
                            $c(e.get());
                            const n = MS(t, !0);
                            return e.set(n), rl(n, 1)
                        }
                    }))), (t => Gu(t).map((t => {
                        if (FS(t, e)) {
                            const t = e.get();
                            return rl(t, t.length - 1)
                        }
                        {
                            $c(e.get());
                            const n = MS(t, !1);
                            return e.set(n), rl(n, n.length - 1)
                        }
                    }))), (t => {
                        $c(e.get());
                        const n = IS(t);
                        return e.set(n), U.some(rl(n, 1))
                    })), qS = (e, t) => {
                        for (let n = 0; n < e.length; n++) {
                            const o = e[n].apply(null, t);
                            if (o.isSome()) return o
                        }
                        return U.none()
                    }, jS = Rl([{before: ["element"]}, {start: ["element"]}, {end: ["element"]}, {after: ["element"]}]),
                    HS = (e, t) => {
                        const n = mu(t, e);
                        return n || e
                    }, zS = (e, t, n) => {
                        const o = mv(n), r = HS(t, o.container());
                        return cv(e, r, o).fold((() => Wu(r, o).bind(L(cv, e, r)).map((e => jS.before(e)))), U.none)
                    }, $S = (e, t) => null === Qu(e, t), VS = (e, t, n) => cv(e, t, n).filter(L($S, t)), WS = (e, t, n) => {
                        const o = fv(n);
                        return VS(e, t, o).bind((e => Ku(e, o).isNone() ? U.some(jS.start(e)) : U.none()))
                    }, KS = (e, t, n) => {
                        const o = mv(n);
                        return VS(e, t, o).bind((e => Wu(e, o).isNone() ? U.some(jS.end(e)) : U.none()))
                    }, YS = (e, t, n) => {
                        const o = fv(n), r = HS(t, o.container());
                        return cv(e, r, o).fold((() => Ku(r, o).bind(L(cv, e, r)).map((e => jS.after(e)))), U.none)
                    }, GS = e => !dv(JS(e)), XS = (e, t, n) => qS([zS, WS, KS, YS], [e, t, n]).filter(GS),
                    JS = e => e.fold(R, R, R, R), QS = e => e.fold(T("before"), T("start"), T("end"), T("after")),
                    ZS = e => e.fold(jS.before, jS.before, jS.after, jS.after),
                    ek = e => e.fold(jS.start, jS.start, jS.end, jS.end),
                    tk = (e, t, n, o, r, a) => Mt(cv(t, n, o), cv(t, n, r), ((t, o) => t !== o && ((e, t, n) => {
                        const o = mu(t, e), r = mu(n, e);
                        return w(o) && o === r
                    })(n, t, o) ? jS.after(e ? t : o) : a)).getOr(a), nk = (e, t) => e.fold(F, (e => {
                        return o = t, !(QS(n = e) === QS(o) && JS(n) === JS(o));
                        var n, o
                    })),
                    ok = (e, t) => e ? t.fold(A(U.some, jS.start), U.none, A(U.some, jS.after), U.none) : t.fold(U.none, A(U.some, jS.before), U.none, A(U.some, jS.end)),
                    rk = (e, t, n, o) => {
                        const r = uv(e, o), a = XS(t, n, r);
                        return XS(t, n, r).bind(L(ok, e)).orThunk((() => ((e, t, n, o, r) => {
                            const a = uv(e, r);
                            return Hu(e, n, a).map(L(uv, e)).fold((() => o.map(ZS)), (r => XS(t, n, r).map(L(tk, e, t, n, a, r)).filter(L(nk, o)))).filter(GS)
                        })(e, t, n, a, o)))
                    }, ak = (e, t, n) => {
                        const o = e ? 1 : -1;
                        return t.setRng(rl(n.container(), n.offset() + o).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0
                    }, sk = (e, t) => {
                        const n = t.selection.getRng(), o = e ? rl.fromRangeEnd(n) : rl.fromRangeStart(n);
                        return !!(e => _(e.selection.getSel().modify))(t) && (e && zr(o) ? ak(!0, t.selection, o) : !(e || !$r(o)) && ak(!1, t.selection, o))
                    };
                var ik;
                !function (e) {
                    e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol"
                }(ik || (ik = {}));
                const lk = (e, t) => e === xu.Backwards ? ae(t) : t,
                    dk = (e, t, n) => e === xu.Forwards ? t.next(n) : t.prev(n),
                    ck = (e, t, n, o) => ir(o.getNode(t === xu.Forwards)) ? ik.Br : !1 === fu(n, o) ? ik.Block : ik.Wrap,
                    uk = (e, t, n, o) => {
                        const r = Mu(n);
                        let a = o;
                        const s = [];
                        for (; a;) {
                            const n = dk(t, r, a);
                            if (!n) break;
                            if (ir(n.getNode(!1))) return t === xu.Forwards ? {
                                positions: lk(t, s).concat([n]),
                                breakType: ik.Br,
                                breakAt: U.some(n)
                            } : {positions: lk(t, s), breakType: ik.Br, breakAt: U.some(n)};
                            if (n.isVisible()) {
                                if (e(a, n)) {
                                    const e = ck(0, t, a, n);
                                    return {positions: lk(t, s), breakType: e, breakAt: U.some(n)}
                                }
                                s.push(n), a = n
                            } else a = n
                        }
                        return {positions: lk(t, s), breakType: ik.Eol, breakAt: U.none()}
                    }, mk = (e, t, n, o) => t(n, o).breakAt.map((o => {
                        const r = t(n, o).positions;
                        return e === xu.Backwards ? r.concat(o) : [o].concat(r)
                    })).getOr([]),
                    fk = (e, t) => Q(e, ((e, n) => e.fold((() => U.some(n)), (o => Mt(ce(o.getClientRects()), ce(n.getClientRects()), ((e, r) => {
                        const a = Math.abs(t - e.left);
                        return Math.abs(t - r.left) <= a ? n : o
                    })).or(e)))), U.none()), gk = (e, t) => ce(t.getClientRects()).bind((t => fk(e, t.left))),
                    pk = L(uk, rl.isAbove, -1), hk = L(uk, rl.isBelow, 1), vk = L(mk, -1, pk), bk = L(mk, 1, hk),
                    yk = (e, t) => pk(e, t).breakAt.isNone(), Ck = (e, t) => hk(e, t).breakAt.isNone(),
                    Ek = (e, t) => gk(vk(e, t), t), wk = (e, t) => gk(bk(e, t), t), _k = cr,
                    Sk = (e, t) => Math.abs(e.left - t), kk = (e, t) => Math.abs(e.right - t),
                    xk = (e, t) => Oe(e, ((e, n) => {
                        const o = Math.min(Sk(e, t), kk(e, t)), r = Math.min(Sk(n, t), kk(n, t));
                        return r === o && xe(n, "node") && _k(n.node) || r < o ? n : e
                    })), Ak = e => {
                        const t = t => W(t, (t => {
                            const n = Ri(t);
                            return n.node = e, n
                        }));
                        if (Vo(e)) return t(e.getClientRects());
                        if (tr(e)) {
                            const n = e.ownerDocument.createRange();
                            return n.setStart(e, 0), n.setEnd(e, e.data.length), t(n.getClientRects())
                        }
                        return []
                    }, Nk = e => oe(e, Ak);
                var Tk;
                !function (e) {
                    e[e.Up = -1] = "Up", e[e.Down = 1] = "Down"
                }(Tk || (Tk = {}));
                const Rk = (e, t, n, o, r, a) => {
                        let s = 0;
                        const i = [], l = o => {
                            let a = Nk([o]);
                            -1 === e && (a = a.reverse());
                            for (let e = 0; e < a.length; e++) {
                                const o = a[e];
                                if (!n(o, d)) {
                                    if (i.length > 0 && t(o, Pe(i)) && s++, o.line = s, r(o)) return !0;
                                    i.push(o)
                                }
                            }
                            return !1
                        }, d = Pe(a.getClientRects());
                        if (!d) return i;
                        const c = a.getNode();
                        return c && (l(c), ((e, t, n, o) => {
                            let r = o;
                            for (; r = uu(r, e, aa, t);) if (n(r)) return
                        })(e, o, l, c)), i
                    }, Dk = L(Rk, Tk.Up, Oi, Bi), Lk = L(Rk, Tk.Down, Bi, Oi), Ok = e => Pe(e.getClientRects()),
                    Bk = e => t => ((e, t) => t.line > e)(e, t), Pk = e => t => ((e, t) => t.line === e)(e, t),
                    Ik = (e, t) => {
                        e.selection.setRng(t), Bg(e, e.selection.getRng())
                    }, Mk = (e, t, n) => U.some(fS(e, t, n)), Fk = (e, t, n, o, r, a) => {
                        const s = t === xu.Forwards, i = Mu(e.getBody()), l = L(Su, s ? i.next : i.prev), d = s ? o : r;
                        if (!n.collapsed) {
                            const o = Ii(n);
                            if (a(o)) return uS(t, e, o, t === xu.Backwards, !1);
                            if (yS(e)) {
                                const e = n.cloneRange();
                                return e.collapse(t === xu.Backwards), U.from(e)
                            }
                        }
                        const c = wu(t, e.getBody(), n);
                        if (d(c)) return mS(e, c.getNode(!s));
                        let u = l(c);
                        const m = Yr(n);
                        if (!u) return m ? U.some(n) : U.none();
                        if (u = uv(s, u), d(u)) return uS(t, e, u.getNode(!s), s, !1);
                        const f = l(u);
                        return f && d(f) && ku(u, f) ? uS(t, e, f.getNode(!s), s, !1) : m ? Mk(e, u.toRange(), !1) : U.none()
                    }, Uk = (e, t, n, o, r, a) => {
                        const s = wu(t, e.getBody(), n), i = Pe(s.getClientRects()), l = t === Tk.Down, d = e.getBody();
                        if (!i) return U.none();
                        if (yS(e)) {
                            const e = l ? rl.fromRangeEnd(n) : rl.fromRangeStart(n);
                            return (l ? wk : Ek)(d, e).orThunk((() => U.from(e))).map((e => e.toRange()))
                        }
                        const c = (l ? Lk : Dk)(d, Bk(1), s), u = X(c, Pk(1)), m = i.left, f = xk(u, m);
                        if (f && a(f.node)) {
                            const n = Math.abs(m - f.left), o = Math.abs(m - f.right);
                            return uS(t, e, f.node, n < o, !1)
                        }
                        let g;
                        if (g = o(s) ? s.getNode() : r(s) ? s.getNode(!0) : Ii(n), g) {
                            const n = ((e, t, n, o) => {
                                const r = Mu(t);
                                let a, s, i, l;
                                const d = [];
                                let c = 0;
                                1 === e ? (a = r.next, s = Bi, i = Oi, l = rl.after(o)) : (a = r.prev, s = Oi, i = Bi, l = rl.before(o));
                                const u = Ok(l);
                                do {
                                    if (!l.isVisible()) continue;
                                    const e = Ok(l);
                                    if (i(e, u)) continue;
                                    d.length > 0 && s(e, Pe(d)) && c++;
                                    const t = Ri(e);
                                    if (t.position = l, t.line = c, n(t)) return d;
                                    d.push(t)
                                } while (l = a(l));
                                return d
                            })(t, d, Bk(1), g);
                            let o = xk(X(n, Pk(1)), m);
                            if (o) return Mk(e, o.position.toRange(), !1);
                            if (o = Pe(X(n, Pk(0))), o) return Mk(e, o.position.toRange(), !1)
                        }
                        return 0 === u.length ? qk(e, l).filter(l ? r : o).map((t => fS(e, t.toRange(), !1))) : U.none()
                    }, qk = (e, t) => {
                        const n = e.selection.getRng(), o = t ? rl.fromRangeEnd(n) : rl.fromRangeStart(n),
                            r = (a = o.container(), s = e.getBody(), Xn(yn.fromDom(a), (e => Zc(e.dom)), (e => e.dom === s)).map((e => e.dom)).getOr(s));
                        var a, s;
                        if (t) {
                            const e = hk(r, o);
                            return ue(e.positions)
                        }
                        {
                            const e = pk(r, o);
                            return ce(e.positions)
                        }
                    }, jk = (e, t, n) => qk(e, t).filter(n).exists((t => (e.selection.setRng(t.toRange()), !0))),
                    Hk = (e, t) => {
                        const n = e.dom.createRng();
                        n.setStart(t.container(), t.offset()), n.setEnd(t.container(), t.offset()), e.selection.setRng(n)
                    }, zk = (e, t) => {
                        e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected")
                    }, $k = (e, t, n) => US(t, n).map((t => (Hk(e, t), n))), Vk = (e, t, n) => {
                        const o = e.getBody(), r = ((e, t, n) => {
                            const o = rl.fromRangeStart(e);
                            if (e.collapsed) return o;
                            {
                                const r = rl.fromRangeEnd(e);
                                return n ? Ku(t, r).getOr(r) : Wu(t, o).getOr(o)
                            }
                        })(e.selection.getRng(), o, n), a = L(lv, e);
                        return rk(n, a, o, r).bind((n => $k(e, t, n)))
                    }, Wk = (e, t) => {
                        const n = t.get();
                        if (e.selection.isCollapsed() && !e.composing && n) {
                            const o = rl.fromRangeStart(e.selection.getRng());
                            rl.isTextPosition(o) && !(e => zr(e) || $r(e))(o) && (Hk(e, zc(n, o)), t.set(null))
                        }
                    }, Kk = (e, t, n) => !!Od(e) && Vk(e, t, n).isSome(), Yk = (e, t, n) => !!Od(t) && sk(e, t), Gk = e => {
                        const t = Zs(null), n = L(lv, e);
                        return e.on("NodeChange", (o => {
                            Od(e) && (((e, t, n) => {
                                const o = W(qo(yn.fromDom(t.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e => e.dom)),
                                    r = X(o, e), a = X(n, e);
                                K(se(r, a), L(zk, !1)), K(se(a, r), L(zk, !0))
                            })(n, e.dom, o.parents), Wk(e, t), ((e, t, n, o) => {
                                if (t.selection.isCollapsed()) {
                                    const r = X(o, e);
                                    K(r, (o => {
                                        const r = rl.fromRangeStart(t.selection.getRng());
                                        XS(e, t.getBody(), r).bind((e => $k(t, n, e)))
                                    }))
                                }
                            })(n, e, t, o.parents))
                        })), t
                    }, Xk = L(Yk, !0), Jk = L(Yk, !1), Qk = (e, t, n) => {
                        if (Od(e)) {
                            const o = qk(e, t).getOrThunk((() => {
                                const n = e.selection.getRng();
                                return t ? rl.fromRangeEnd(n) : rl.fromRangeStart(n)
                            }));
                            return XS(L(lv, e), e.getBody(), o).exists((t => {
                                const o = ZS(t);
                                return US(n, o).exists((t => (Hk(e, t), !0)))
                            }))
                        }
                        return !1
                    }, Zk = (e, t) => n => US(t, n).map((t => () => Hk(e, t))), ex = (e, t, n, o) => {
                        const r = e.getBody(), a = L(lv, e);
                        e.undoManager.ignore((() => {
                            e.selection.setRng(((e, t) => {
                                const n = document.createRange();
                                return n.setStart(e.container(), e.offset()), n.setEnd(t.container(), t.offset()), n
                            })(n, o)), pv(e), XS(a, r, rl.fromRangeStart(e.selection.getRng())).map(ek).bind(Zk(e, t)).each(I)
                        })), e.nodeChanged()
                    }, tx = (e, t, n, o) => {
                        const r = ((e, t) => {
                            const n = mu(t, e);
                            return n || e
                        })(e.getBody(), o.container()), a = L(lv, e), s = XS(a, r, o);
                        return s.bind((e => n ? e.fold(T(U.some(ek(e))), U.none, T(U.some(ZS(e))), U.none) : e.fold(U.none, T(U.some(ZS(e))), U.none, T(U.some(ek(e)))))).map(Zk(e, t)).getOrThunk((() => {
                            const i = zu(n, r, o), l = i.bind((e => XS(a, r, e)));
                            return Mt(s, l, (() => cv(a, r, o).bind((t => (e => Mt(Yu(e), Gu(e), ((t, n) => {
                                const o = uv(!0, t), r = uv(!1, n);
                                return Wu(e, o).forall((e => e.isEqual(r)))
                            })).getOr(!0))(t) ? U.some((() => {
                                sv(e, n, yn.fromDom(t))
                            })) : U.none())))).getOrThunk((() => l.bind((() => i.map((r => () => {
                                n ? ex(e, t, o, r) : ex(e, t, r, o)
                            }))))))
                        }))
                    }, nx = (e, t, n) => {
                        if (e.selection.isCollapsed() && Od(e)) {
                            const o = rl.fromRangeStart(e.selection.getRng());
                            return tx(e, t, n, o)
                        }
                        return U.none()
                    }, ox = (e, t) => {
                        const n = yn.fromDom(e.getBody()), o = yn.fromDom(e.selection.getStart()), r = ph(o, n);
                        return te(r, t).fold(T(r), (e => r.slice(0, e)))
                    }, rx = e => 1 === Un(e), ax = e => ox(e, (t => e.schema.isBlock($t(t)) || (e => Un(e) > 1)(t))),
                    sx = (e, t) => {
                        const n = L(oy, e);
                        return oe(t, (e => n(e) ? [e.dom] : []))
                    }, ix = e => {
                        const t = (e => ox(e, (t => e.schema.isBlock($t(t)))))(e);
                        return sx(e, t)
                    }, lx = (e, t) => {
                        const n = X(ax(e), rx);
                        return ue(n).bind((o => {
                            const r = rl.fromRangeStart(e.selection.getRng());
                            return yv(t, r, o.dom) && !Xm(o) ? U.some((() => ((e, t, n, o) => {
                                const r = sx(t, o);
                                if (0 === r.length) sv(t, e, n); else {
                                    const e = ny(n.dom, r);
                                    t.selection.setRng(e.toRange())
                                }
                            })(t, e, o, n))) : U.none()
                        }))
                    }, dx = (e, t) => {
                        const n = e.selection.getStart(), o = ((e, t) => {
                            const n = t.parentElement;
                            return ir(t) && !b(n) && e.dom.isEmpty(n)
                        })(e, n) || (r = n, Xm(yn.fromDom(r))) ? ny(n, t) : ((e, t) => {
                            const {caretContainer: n, caretPosition: o} = ty(t);
                            return e.insertNode(n.dom), o
                        })(e.selection.getRng(), t);
                        var r;
                        e.selection.setRng(o.toRange())
                    }, cx = e => tr(e.startContainer), ux = e => (e => {
                        const t = e.startContainer.parentNode, n = e.endContainer.parentNode;
                        return !b(t) && !b(n) && t.isEqualNode(n)
                    })(e) && (e => {
                        const t = e.endContainer;
                        return e.endOffset === (tr(t) ? t.length : t.childNodes.length)
                    })(e), mx = e => {
                        const t = e.selection.getRng();
                        return (e => 0 === e.startOffset && cx(e))(t) && ((e, t) => {
                            const n = t.startContainer.parentElement;
                            return !b(n) && oy(e, yn.fromDom(n))
                        })(e, t) && (e => ux(e) || (e => !e.endContainer.isEqualNode(e.commonAncestorContainer))(e))(t)
                    }, fx = e => {
                        if (mx(e)) {
                            const t = ix(e);
                            return U.some((() => {
                                pv(e), ((e, t) => {
                                    const n = se(t, ix(e));
                                    n.length > 0 && dx(e, n)
                                })(e, t)
                            }))
                        }
                        return U.none()
                    }, gx = (e, t) => e.selection.isCollapsed() ? lx(e, t) : fx(e),
                    px = (e, t) => ((e, t, n) => Xn(e, t, n).isSome())(e, (e => Ju(e.dom)), (e => t.isBlock($t(e)))),
                    hx = e => {
                        const t = e.selection.getRng();
                        return t.collapsed && (cx(t) || e.dom.isEmpty(t.startContainer)) && !(e => px(yn.fromDom(e.selection.getStart()), e.schema))(e)
                    }, vx = e => (hx(e) && dx(e, []), !0), bx = (e, t, n) => w(n) ? U.some((() => {
                        e._selectionOverrides.hideFakeCaret(), sv(e, t, yn.fromDom(n))
                    })) : U.none(), yx = (e, t) => e.selection.isCollapsed() ? ((e, t) => {
                        const n = t ? lh : dh, o = t ? xu.Forwards : xu.Backwards,
                            r = wu(o, e.getBody(), e.selection.getRng());
                        return n(r) ? bx(e, t, r.getNode(!t)) : U.from(uv(t, r)).filter((e => n(e) && ku(r, e))).bind((n => bx(e, t, n.getNode(!t))))
                    })(e, t) : ((e, t) => {
                        const n = e.selection.getNode();
                        return fr(n) ? bx(e, t, n) : U.none()
                    })(e, t), Cx = e => Qe(null != e ? e : "").getOr(0),
                    Ex = (e, t) => (e || "table" === $t(t) ? "margin" : "padding") + ("rtl" === co(t, "direction") ? "-right" : "-left"),
                    wx = e => {
                        const t = Sx(e);
                        return !e.mode.isReadOnly() && (t.length > 1 || ((e, t) => re(t, (t => {
                            const n = Ex(vd(e), t), o = mo(t, n).map(Cx).getOr(0);
                            return "false" !== e.dom.getContentEditable(t.dom) && o > 0
                        })))(e, t))
                    }, _x = e => xr(e) || Ar(e),
                    Sx = e => X(So(e.selection.getSelectedBlocks()), (e => !_x(e) && !(e => Nn(e).exists(_x))(e) && Jn(e, (e => dr(e.dom) || cr(e.dom))).exists((e => dr(e.dom))))),
                    kx = (e, t) => {
                        var n, o;
                        const {dom: r} = e, a = bd(e),
                            s = null !== (o = null === (n = /[a-z%]+$/i.exec(a)) || void 0 === n ? void 0 : n[0]) && void 0 !== o ? o : "px",
                            i = Cx(a), l = vd(e);
                        K(Sx(e), (e => {
                            ((e, t, n, o, r, a) => {
                                const s = Ex(n, yn.fromDom(a)), i = Cx(e.getStyle(a, s));
                                if ("outdent" === t) {
                                    const t = Math.max(0, i - o);
                                    e.setStyle(a, s, t ? t + r : "")
                                } else {
                                    const t = i + o + r;
                                    e.setStyle(a, s, t)
                                }
                            })(r, t, l, i, s, e.dom)
                        }))
                    }, xx = e => kx(e, "outdent"), Ax = e => {
                        if (e.selection.isCollapsed() && wx(e)) {
                            const t = e.dom, n = e.selection.getRng(), o = rl.fromRangeStart(n),
                                r = t.getParent(n.startContainer, t.isBlock);
                            if (null !== r && Ch(yn.fromDom(r), o, e.schema)) return U.some((() => xx(e)))
                        }
                        return U.none()
                    },
                    Nx = (e, t, n) => fe([Ax, NS, vS, (e, n) => nx(e, t, n), sS, eb, TS, yx, cS, gx], (t => t(e, n))).filter((t => e.selection.isEditable())),
                    Tx = (e, t) => {
                        Nx(e, t, !0).fold((() => {
                            e.selection.isEditable() && (e => {
                                gv(e, "ForwardDelete")
                            })(e)
                        }), I)
                    }, Rx = (e, t) => {
                        e.addCommand("delete", (() => {
                            ((e, t) => {
                                Nx(e, t, !1).fold((() => {
                                    e.selection.isEditable() && (pv(e), bv(e))
                                }), I)
                            })(e, t)
                        })), e.addCommand("forwardDelete", (() => {
                            Tx(e, t)
                        }))
                    }, Dx = e => void 0 === e.touches || 1 !== e.touches.length ? U.none() : U.some(e.touches[0]),
                    Lx = e => {
                        const t = si(), n = Zs(!1), o = li((t => {
                            e.dispatch("longpress", {...t, type: "longpress"}), n.set(!0)
                        }), 400);
                        e.on("touchstart", (e => {
                            Dx(e).each((r => {
                                o.cancel();
                                const a = {x: r.clientX, y: r.clientY, target: e.target};
                                o.throttle(e), n.set(!1), t.set(a)
                            }))
                        }), !0), e.on("touchmove", (r => {
                            o.cancel(), Dx(r).each((o => {
                                t.on((r => {
                                    ((e, t) => {
                                        const n = Math.abs(e.clientX - t.x), o = Math.abs(e.clientY - t.y);
                                        return n > 5 || o > 5
                                    })(o, r) && (t.clear(), n.set(!1), e.dispatch("longpresscancel"))
                                }))
                            }))
                        }), !0), e.on("touchend touchcancel", (r => {
                            o.cancel(), "touchcancel" !== r.type && t.get().filter((e => e.target.isEqualNode(r.target))).each((() => {
                                n.get() ? r.preventDefault() : e.dispatch("tap", {...r, type: "tap"})
                            }))
                        }), !0)
                    }, Ox = (e, t) => ke(e, t.nodeName),
                    Bx = (e, t) => !!tr(t) || !!Vo(t) && !(Ox(e.getBlockElements(), t) || um(t) || Pa(e, t) || Ea(t)),
                    Px = (e, t) => {
                        if (tr(t)) {
                            if (0 === t.data.length) return !0;
                            if (/^\s+$/.test(t.data)) return !t.nextSibling || Ox(e, t.nextSibling) || Ea(t.nextSibling)
                        }
                        return !1
                    }, Ix = e => e.dom.create(Jl(e), Ql(e)), Mx = e => {
                        const t = e.dom, n = e.selection, o = e.schema, r = o.getBlockElements(), a = n.getStart(),
                            s = e.getBody();
                        let i, l, d = !1;
                        const c = Jl(e);
                        if (!a || !Vo(a)) return;
                        const u = s.nodeName.toLowerCase();
                        if (!o.isValidChild(u, c.toLowerCase()) || ((e, t, n) => V(gh(yn.fromDom(n), yn.fromDom(t)), (t => Ox(e, t.dom))))(r, s, a)) return;
                        const m = n.getRng(), {startContainer: f, startOffset: g, endContainer: p, endOffset: h} = m,
                            v = ip(e);
                        let b = s.firstChild;
                        for (; b;) if (Vo(b) && Da(o, b), Bx(o, b)) {
                            if (Px(r, b)) {
                                l = b, b = b.nextSibling, t.remove(l);
                                continue
                            }
                            i || (i = Ix(e), s.insertBefore(i, b), d = !0), l = b, b = b.nextSibling, i.appendChild(l)
                        } else i = null, b = b.nextSibling;
                        d && v && (m.setStart(f, g), m.setEnd(p, h), n.setRng(m), e.nodeChanged())
                    }, Fx = (e, t, n) => {
                        const o = yn.fromDom(Ix(e)), r = Lr();
                        bo(o, r), n(t, o);
                        const a = document.createRange();
                        return a.setStartBefore(r.dom), a.setEndBefore(r.dom), a
                    }, Ux = e => t => -1 !== (" " + t.attr("class") + " ").indexOf(e), qx = (e, t, n) => function (o) {
                        const r = arguments, a = r[r.length - 2], s = a > 0 ? t.charAt(a - 1) : "";
                        if ('"' === s) return o;
                        if (">" === s) {
                            const e = t.lastIndexOf("<", a);
                            if (-1 !== e) {
                                if (-1 !== t.substring(e, a).indexOf('contenteditable="false"')) return o
                            }
                        }
                        return '<span class="' + n + '" data-mce-content="' + e.dom.encode(r[0]) + '">' + e.dom.encode("string" == typeof r[1] ? r[1] : r[0]) + "</span>"
                    }, jx = (e, t) => re(e, (e => {
                        const n = t.match(e);
                        return null !== n && n[0].length === t.length
                    })), Hx = e => {
                        const t = "contenteditable", n = " " + Bt.trim(_c(e)) + " ", o = " " + Bt.trim(wc(e)) + " ",
                            r = Ux(n), a = Ux(o), s = Sc(e);
                        s.length > 0 && e.on("BeforeSetContent", (t => {
                            ((e, t, n) => {
                                let o = t.length, r = n.content;
                                if ("raw" !== n.format) {
                                    for (; o--;) r = r.replace(t[o], qx(e, r, wc(e)));
                                    n.content = r
                                }
                            })(e, s, t)
                        })), e.parser.addAttributeFilter("class", (e => {
                            let n = e.length;
                            for (; n--;) {
                                const o = e[n];
                                r(o) ? o.attr(t, "true") : a(o) && o.attr(t, "false")
                            }
                        })), e.serializer.addAttributeFilter(t, (e => {
                            let n = e.length;
                            for (; n--;) {
                                const o = e[n];
                                if (!r(o) && !a(o)) continue;
                                const i = o.attr("data-mce-content");
                                s.length > 0 && i ? jx(s, i) ? (o.name = "#text", o.type = 3, o.raw = !0, o.value = i) : o.remove() : o.attr(t, null)
                            }
                        }))
                    }, zx = (e, t) => {
                        t.hasAttribute("data-mce-caret") && (Kr(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t))
                    }, $x = (e, t) => {
                        const n = (e => to(yn.fromDom(e.getBody()), "*[data-mce-caret]").map((e => e.dom)).getOrNull())(e);
                        if (n) return "compositionstart" === t.type ? (t.preventDefault(), t.stopPropagation(), void zx(e, n)) : void (Hr(n) && (zx(e, n), e.undoManager.add()))
                    }, Vx = cr, Wx = (e, t, n) => {
                        const o = Mu(e.getBody()), r = L(Su, 1 === t ? o.next : o.prev);
                        if (n.collapsed) {
                            const o = e.dom.getParent(n.startContainer, "PRE");
                            if (!o) return;
                            if (!r(rl.fromRangeStart(n))) {
                                const n = yn.fromDom((e => {
                                    const t = e.dom.create(Jl(e));
                                    return t.innerHTML = '<br data-mce-bogus="1">', t
                                })(e));
                                1 === t ? ho(yn.fromDom(o), n) : po(yn.fromDom(o), n), e.selection.select(n.dom, !0), e.selection.collapse()
                            }
                        }
                    }, Kx = (e, t) => {
                        const n = t ? xu.Forwards : xu.Backwards, o = e.selection.getRng();
                        return ((e, t, n) => Fk(t, e, n, mh, fh, Vx))(n, e, o).orThunk((() => (Wx(e, n, o), U.none())))
                    }, Yx = (e, t) => {
                        const n = t ? 1 : -1, o = e.selection.getRng();
                        return ((e, t, n) => Uk(t, e, n, (e => mh(e) || ch(e)), (e => fh(e) || uh(e)), Vx))(n, e, o).orThunk((() => (Wx(e, n, o), U.none())))
                    }, Gx = (e, t) => Kx(e, ((e, t) => {
                        const n = t ? e.getEnd(!0) : e.getStart(!0);
                        return dv(n) ? !t : t
                    })(e.selection, t)).exists((t => (Ik(e, t), !0))),
                    Xx = (e, t) => Yx(e, t).exists((t => (Ik(e, t), !0))), Jx = (e, t) => jk(e, t, t ? fh : mh),
                    Qx = (e, t) => bS(e, !t).map((n => {
                        const o = n.toRange(), r = e.selection.getRng();
                        return t ? o.setStart(r.startContainer, r.startOffset) : o.setEnd(r.endContainer, r.endOffset), o
                    })).exists((t => (Ik(e, t), !0))), Zx = e => $(["figcaption"], $t(e)), eA = (e, t) => {
                        const n = yn.fromDom(e.getBody()), o = rl.fromRangeStart(e.selection.getRng());
                        return ((e, t, n) => {
                            const o = L(_n, t);
                            return Jn(yn.fromDom(e.container()), (e => n.isBlock($t(e))), o).filter(Zx)
                        })(o, n, e.schema).exists((() => {
                            if (((e, t, n) => t ? Ck(e.dom, n) : yk(e.dom, n))(n, t, o)) {
                                const o = Fx(e, n, t ? bo : vo);
                                return e.selection.setRng(o), !0
                            }
                            return !1
                        }))
                    }, tA = (e, t) => !!e.selection.isCollapsed() && eA(e, t),
                    nA = (e, t) => t ? U.from(e.dom.getParent(e.selection.getNode(), "details")).map((t => ((e, t) => {
                        const n = e.selection.getRng(), o = rl.fromRangeStart(n);
                        return !(e.getBody().lastChild !== t || !Ck(t, o) || (e.execCommand("InsertNewBlockAfter"), 0))
                    })(e, t))).getOr(!1) : U.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((t => U.from(e.dom.getParent(t, "details")).map((n => ((e, t, n) => {
                        const o = e.selection.getRng(), r = rl.fromRangeStart(o);
                        return !(e.getBody().firstChild !== t || !yk(n, r) || (e.execCommand("InsertNewBlockBefore"), 0))
                    })(e, n, t))))).getOr(!1), oA = (e, t) => nA(e, t),
                    rA = {shiftKey: !1, altKey: !1, ctrlKey: !1, metaKey: !1, keyCode: 0},
                    aA = (e, t) => t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey,
                    sA = (e, t) => oe((e => W(e, (e => ({...rA, ...e}))))(e), (e => aA(e, t) ? [e] : [])),
                    iA = (e, t) => oe((e => W(e, (e => ({...rA, ...e}))))(e), (e => aA(e, t) ? [e] : [])),
                    lA = (e, ...t) => () => e.apply(null, t), dA = (e, t) => ee(sA(e, t), (e => e.action())),
                    cA = (e, t) => fe(iA(e, t), (e => e.action())), uA = (e, t) => {
                        const n = t ? xu.Forwards : xu.Backwards, o = e.selection.getRng();
                        return Fk(e, n, o, lh, dh, fr).exists((t => (Ik(e, t), !0)))
                    }, mA = (e, t) => {
                        const n = t ? 1 : -1, o = e.selection.getRng();
                        return Uk(e, n, o, lh, dh, fr).exists((t => (Ik(e, t), !0)))
                    }, fA = (e, t) => jk(e, t, t ? dh : lh),
                    gA = Rl([{none: ["current"]}, {first: ["current"]}, {middle: ["current", "target"]}, {last: ["current"]}]),
                    pA = {...gA, none: e => gA.none(e)},
                    hA = (e, t, n) => oe(Pn(e), (e => En(e, t) ? n(e) ? [e] : [] : hA(e, t, n))),
                    vA = (e, t) => ((e, t, n = M) => n(t) ? U.none() : $(e, $t(t)) ? U.some(t) : eo(t, e.join(","), (e => En(e, "table") || n(e))))(["td", "th"], e, t),
                    bA = e => hA(e, "th,td", F), yA = (e, t) => no(e, "table", t), CA = (e, t, n, o, r = F) => {
                        const a = 1 === o;
                        if (!a && n <= 0) return pA.first(e[0]);
                        if (a && n >= e.length - 1) return pA.last(e[e.length - 1]);
                        {
                            const a = n + o, s = e[a];
                            return r(s) ? pA.middle(t, s) : CA(e, t, a, o, r)
                        }
                    }, EA = (e, t) => yA(e, t).bind((t => {
                        const n = bA(t);
                        return te(n, (t => _n(e, t))).map((e => ({index: e, all: n})))
                    })), wA = (e, t, n, o, r) => {
                        const a = qo(yn.fromDom(n), "td,th,caption").map((e => e.dom)), s = X(((e, t) => oe(t, (t => {
                            const n = ((e, t) => ({
                                left: e.left - t,
                                top: e.top - t,
                                right: e.right + 2 * t,
                                bottom: e.bottom + 2 * t,
                                width: e.width + t,
                                height: e.height + t
                            }))(Ri(t.getBoundingClientRect()), -1);
                            return [{x: n.left, y: e(n), cell: t}, {x: n.right, y: e(n), cell: t}]
                        })))(e, a), (e => t(e, r)));
                        return ((e, t, n) => Q(e, ((e, o) => e.fold((() => U.some(o)), (e => {
                            const r = Math.sqrt(Math.abs(e.x - t) + Math.abs(e.y - n)),
                                a = Math.sqrt(Math.abs(o.x - t) + Math.abs(o.y - n));
                            return U.some(a < r ? o : e)
                        }))), U.none()))(s, o, r).map((e => e.cell))
                    }, _A = L(wA, (e => e.bottom), ((e, t) => e.y < t)), SA = L(wA, (e => e.top), ((e, t) => e.y > t)),
                    kA = (e, t) => ce(t.getClientRects()).bind((t => _A(e, t.left, t.top))).bind((e => {
                        return gk(Gu(n = e).map((e => pk(n, e).positions.concat(e))).getOr([]), t);
                        var n
                    })), xA = (e, t) => ue(t.getClientRects()).bind((t => SA(e, t.left, t.top))).bind((e => {
                        return gk(Yu(n = e).map((e => [e].concat(hk(n, e).positions))).getOr([]), t);
                        var n
                    })), AA = (e, t, n) => {
                        const o = e(t, n);
                        return (e => e.breakType === ik.Wrap && 0 === e.positions.length)(o) || !ir(n.getNode()) && (e => e.breakType === ik.Br && 1 === e.positions.length)(o) ? !((e, t, n) => n.breakAt.exists((n => e(t, n).breakAt.isSome())))(e, t, o) : o.breakAt.isNone()
                    }, NA = L(AA, pk), TA = L(AA, hk), RA = (e, t, n, o) => {
                        const r = e.selection.getRng(), a = t ? 1 : -1;
                        return !(!Xc() || !((e, t, n) => {
                            const o = rl.fromRangeStart(t);
                            return Vu(!e, n).exists((e => e.isEqual(o)))
                        })(t, r, n)) && (uS(a, e, n, !t, !1).each((t => {
                            Ik(e, t)
                        })), !0)
                    }, DA = (e, t) => {
                        const n = t.getNode(e);
                        return Qo(n) ? U.some(n) : U.none()
                    }, LA = (e, t, n) => {
                        const o = DA(!!t, n), r = !1 === t;
                        o.fold((() => Ik(e, n.toRange())), (o => Vu(r, e.getBody()).filter((e => e.isEqual(n))).fold((() => Ik(e, n.toRange())), (n => ((e, t, n) => {
                            t.undoManager.transact((() => {
                                const o = e ? ho : po, r = Fx(t, yn.fromDom(n), o);
                                Ik(t, r)
                            }))
                        })(t, e, o)))))
                    }, OA = (e, t, n, o) => {
                        const r = e.selection.getRng(), a = rl.fromRangeStart(r), s = e.getBody();
                        if (!t && NA(o, a)) {
                            const o = ((e, t, n) => kA(t, n).orThunk((() => ce(n.getClientRects()).bind((n => fk(vk(e, rl.before(t)), n.left))))).getOr(rl.before(t)))(s, n, a);
                            return LA(e, t, o), !0
                        }
                        if (t && TA(o, a)) {
                            const o = ((e, t, n) => xA(t, n).orThunk((() => ce(n.getClientRects()).bind((n => fk(bk(e, rl.after(t)), n.left))))).getOr(rl.after(t)))(s, n, a);
                            return LA(e, t, o), !0
                        }
                        return !1
                    },
                    BA = (e, t, n) => U.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((o => U.from(e.dom.getParent(o, "table")).map((r => n(e, t, r, o))))).getOr(!1),
                    PA = (e, t) => BA(e, t, RA), IA = (e, t) => BA(e, t, OA),
                    MA = (e, t, n) => n.fold(U.none, U.none, ((e, t) => {
                        return (n = t, Zn(n, bp)).map((e => (e => {
                            const t = Yf.exact(e, 0, e, 0);
                            return Zf(t)
                        })(e)));
                        var n
                    }), (n => (e.execCommand("mceTableInsertRowAfter"), FA(e, t, n)))),
                    FA = (e, t, n) => MA(e, t, ((e, t, n) => EA(e, n).fold((() => pA.none(e)), (n => CA(n.all, e, n.index, 1, t))))(n, oo)),
                    UA = (e, t, n) => MA(e, t, ((e, t, n) => EA(e, n).fold((() => pA.none()), (n => CA(n.all, e, n.index, -1, t))))(n, oo)),
                    qA = (e, t) => {
                        const n = ["table", "li", "dl"], o = yn.fromDom(e.getBody()), r = e => {
                            const t = $t(e);
                            return _n(e, o) || $(n, t)
                        }, a = e.selection.getRng(), s = yn.fromDom(t ? a.endContainer : a.startContainer);
                        return vA(s, r).map((n => {
                            yA(n, r).each((t => {
                                e.model.table.clearSelectedCells(t.dom)
                            })), e.selection.collapse(!t);
                            return (t ? FA : UA)(e, r, n).each((t => {
                                e.selection.setRng(t)
                            })), !0
                        })).getOr(!1)
                    }, jA = (e, t) => {
                        e.on("keydown", (n => {
                            n.isDefaultPrevented() || ((e, t, n) => {
                                const o = Rt.os.isMacOS() || Rt.os.isiOS();
                                dA([{keyCode: Rf.RIGHT, action: lA(Gx, e, !0)}, {
                                    keyCode: Rf.LEFT,
                                    action: lA(Gx, e, !1)
                                }, {keyCode: Rf.UP, action: lA(Xx, e, !1)}, {
                                    keyCode: Rf.DOWN,
                                    action: lA(Xx, e, !0)
                                }, ...o ? [{
                                    keyCode: Rf.UP,
                                    action: lA(Qx, e, !1),
                                    metaKey: !0,
                                    shiftKey: !0
                                }, {
                                    keyCode: Rf.DOWN,
                                    action: lA(Qx, e, !0),
                                    metaKey: !0,
                                    shiftKey: !0
                                }] : [], {keyCode: Rf.RIGHT, action: lA(PA, e, !0)}, {
                                    keyCode: Rf.LEFT,
                                    action: lA(PA, e, !1)
                                }, {keyCode: Rf.UP, action: lA(IA, e, !1)}, {
                                    keyCode: Rf.DOWN,
                                    action: lA(IA, e, !0)
                                }, {keyCode: Rf.UP, action: lA(IA, e, !1)}, {
                                    keyCode: Rf.UP,
                                    action: lA(oA, e, !1)
                                }, {keyCode: Rf.DOWN, action: lA(oA, e, !0)}, {
                                    keyCode: Rf.RIGHT,
                                    action: lA(uA, e, !0)
                                }, {keyCode: Rf.LEFT, action: lA(uA, e, !1)}, {
                                    keyCode: Rf.UP,
                                    action: lA(mA, e, !1)
                                }, {keyCode: Rf.DOWN, action: lA(mA, e, !0)}, {
                                    keyCode: Rf.RIGHT,
                                    action: lA(Kk, e, t, !0)
                                }, {keyCode: Rf.LEFT, action: lA(Kk, e, t, !1)}, {
                                    keyCode: Rf.RIGHT,
                                    ctrlKey: !o,
                                    altKey: o,
                                    action: lA(Xk, e, t)
                                }, {keyCode: Rf.LEFT, ctrlKey: !o, altKey: o, action: lA(Jk, e, t)}, {
                                    keyCode: Rf.UP,
                                    action: lA(tA, e, !1)
                                }, {keyCode: Rf.DOWN, action: lA(tA, e, !0)}], n).each((e => {
                                    n.preventDefault()
                                }))
                            })(e, t, n)
                        }))
                    }, HA = (e, t) => ({container: e, offset: t}), zA = Xs.DOM, $A = e => t => e === t ? -1 : 0,
                    VA = (e, t, n) => {
                        if (tr(e) && t >= 0) return U.some(HA(e, t));
                        {
                            const o = Ni(zA);
                            return U.from(o.backwards(e, t, $A(e), n)).map((e => HA(e.container, e.container.data.length)))
                        }
                    }, WA = (e, t, n) => {
                        if (!tr(e)) return U.none();
                        const o = e.data;
                        if (t >= 0 && t <= o.length) return U.some(HA(e, t));
                        {
                            const o = Ni(zA);
                            return U.from(o.backwards(e, t, $A(e), n)).bind((e => {
                                const o = e.container.data;
                                return WA(e.container, t + o.length, n)
                            }))
                        }
                    }, KA = (e, t, n) => {
                        if (!tr(e)) return U.none();
                        const o = e.data;
                        if (t <= o.length) return U.some(HA(e, t));
                        {
                            const r = Ni(zA);
                            return U.from(r.forwards(e, t, $A(e), n)).bind((e => KA(e.container, t - o.length, n)))
                        }
                    }, YA = (e, t, n, o, r) => {
                        const a = Ni(e, (e => t => e.isBlock(t) || $(["BR", "IMG", "HR", "INPUT"], t.nodeName) || "false" === e.getContentEditable(t))(e));
                        return U.from(a.backwards(t, n, o, r))
                    }, GA = e => Ir(e.toString().replace(/\u00A0/g, " ")),
                    XA = e => "" !== e && -1 !== "  \f\n\r\t\v".indexOf(e), JA = (e, t) => e.substring(t.length),
                    QA = (e, t, n, o = 0) => {
                        if (!(r = t).collapsed || !tr(r.startContainer)) return U.none();
                        var r;
                        const a = {text: "", offset: 0}, s = e.getParent(t.startContainer, e.isBlock) || e.getRoot();
                        return YA(e, t.startContainer, t.startOffset, ((e, t, o) => (a.text = o + a.text, a.offset += t, ((e, t, n) => {
                            let o;
                            const r = n.charAt(0);
                            for (o = t - 1; o >= 0; o--) {
                                const a = e.charAt(o);
                                if (XA(a)) return U.none();
                                if (r === a && ze(e, n, o, t)) break
                            }
                            return U.some(o)
                        })(a.text, a.offset, n).getOr(t))), s).bind((e => {
                            const r = t.cloneRange();
                            if (r.setStart(e.container, e.offset), r.setEnd(t.endContainer, t.endOffset), r.collapsed) return U.none();
                            const a = GA(r);
                            return 0 !== a.lastIndexOf(n) || JA(a, n).length < o ? U.none() : U.some({
                                text: JA(a, n),
                                range: r,
                                trigger: n
                            })
                        }))
                    }, ZA = (e, t, n, o = 0) => {
                        return (r = yn.fromDom(t.startContainer), no(r, Cp)).fold((() => QA(e, t, n, o)), (t => {
                            const o = e.createRng();
                            o.selectNode(t.dom);
                            const r = GA(o);
                            return U.some({range: o, text: JA(r, n), trigger: n})
                        }));
                        var r
                    }, eN = e => {
                        if ((e => 3 === e.nodeType)(e)) return HA(e, e.data.length);
                        {
                            const t = e.childNodes;
                            return t.length > 0 ? eN(t[t.length - 1]) : HA(e, t.length)
                        }
                    }, tN = (e, t) => {
                        const n = e.childNodes;
                        return n.length > 0 && t < n.length ? tN(n[t], 0) : n.length > 0 && (e => 1 === e.nodeType)(e) && n.length === t ? eN(n[n.length - 1]) : HA(e, t)
                    }, nN = e => t => {
                        const n = tN(t.startContainer, t.startOffset);
                        return !((e, t) => {
                            var n;
                            const o = null !== (n = e.getParent(t.container, e.isBlock)) && void 0 !== n ? n : e.getRoot();
                            return YA(e, t.container, t.offset, ((e, t) => 0 === t ? -1 : t), o).filter((e => {
                                const t = e.container.data.charAt(e.offset - 1);
                                return !XA(t)
                            })).isSome()
                        })(e, n)
                    }, oN = (e, t) => {
                        const n = t(), o = e.selection.getRng();
                        return ((e, t, n) => fe(n.triggers, (n => ZA(e, t, n))))(e.dom, o, n).bind((n => rN(e, t, n)))
                    }, rN = (e, t, n, o = {}) => {
                        var r;
                        const a = t(),
                            s = null !== (r = e.selection.getRng().startContainer.nodeValue) && void 0 !== r ? r : "",
                            i = X(a.lookupByTrigger(n.trigger), (t => n.text.length >= t.minChars && t.matches.getOrThunk((() => nN(e.dom)))(n.range, s, n.text)));
                        if (0 === i.length) return U.none();
                        const l = Promise.all(W(i, (e => e.fetch(n.text, e.maxResults, o).then((t => ({
                            matchText: n.text,
                            items: t,
                            columns: e.columns,
                            onAction: e.onAction,
                            highlightOn: e.highlightOn
                        }))))));
                        return U.some({lookupData: l, context: n})
                    };
                var aN;
                !function (e) {
                    e[e.Error = 0] = "Error", e[e.Value = 1] = "Value"
                }(aN || (aN = {}));
                const sN = (e, t, n) => e.stype === aN.Error ? t(e.serror) : n(e.svalue),
                    iN = e => ({stype: aN.Value, svalue: e}), lN = e => ({stype: aN.Error, serror: e}),
                    dN = e => sN(e, Tl.error, Tl.value), cN = iN, uN = e => {
                        const t = [], n = [];
                        return K(e, (e => {
                            sN(e, (e => n.push(e)), (e => t.push(e)))
                        })), {values: t, errors: n}
                    }, mN = lN, fN = (e, t) => e.stype === aN.Error ? t(e.serror) : e,
                    gN = (e, t) => e.stype === aN.Value ? {stype: aN.Value, svalue: t(e.svalue)} : e,
                    pN = (e, t) => e.stype === aN.Error ? {stype: aN.Error, serror: t(e.serror)} : e, hN = sN,
                    vN = e => p(e) && ge(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2),
                    bN = (e, t) => mN([{path: e, getErrorInfo: t}]),
                    yN = (e, t, n, o) => Se(n, o).fold((() => ((e, t, n) => bN(e, (() => 'The chosen schema: "' + n + '" did not exist in branches: ' + vN(t))))(e, n, o)), (n => n.extract(e.concat(["branch: " + o]), t))),
                    CN = (e, t) => ({
                        extract: (n, o) => Se(o, e).fold((() => ((e, t) => bN(e, (() => 'Choice schema did not contain choice key: "' + t + '"')))(n, e)), (e => yN(n, o, t, e))),
                        toString: () => "chooseOn(" + e + "). Possible values: " + ge(t)
                    }), EN = e => (...t) => {
                        if (0 === t.length) throw new Error("Can't merge zero objects");
                        const n = {};
                        for (let o = 0; o < t.length; o++) {
                            const r = t[o];
                            for (const t in r) ke(r, t) && (n[t] = e(n[t], r[t]))
                        }
                        return n
                    }, wN = EN(((e, t) => h(e) && h(t) ? wN(e, t) : t)),
                    _N = (EN(((e, t) => t)), e => ({tag: "defaultedThunk", process: T(e)})), SN = e => A(mN, ne)(e),
                    kN = e => {
                        const t = uN(e);
                        return t.errors.length > 0 ? SN(t.errors) : cN(t.values)
                    }, xN = (e, t, n) => {
                        switch (e.tag) {
                            case"field":
                                return t(e.key, e.newKey, e.presence, e.prop);
                            case"custom":
                                return n(e.newKey, e.instantiator)
                        }
                    }, AN = e => ({extract: (t, n) => fN(e(n), (e => ((e, t) => bN(e, T(t)))(t, e))), toString: T("val")}),
                    NN = AN(cN),
                    TN = (e, t, n, o) => Se(t, n).fold((() => ((e, t, n) => bN(e, (() => 'Could not find valid *required* value for "' + t + '" in ' + vN(n))))(e, n, t)), o),
                    RN = (e, t, n, o) => o(Se(e, t).getOrThunk((() => n(e)))), DN = (e, t, n, o, r) => {
                        const a = e => r.extract(t.concat([o]), e), s = e => e.fold((() => cN(U.none())), (e => {
                            const n = r.extract(t.concat([o]), e);
                            return gN(n, U.some)
                        }));
                        switch (e.tag) {
                            case"required":
                                return TN(t, n, o, a);
                            case"defaultedThunk":
                                return RN(n, o, e.process, a);
                            case"option":
                                return ((e, t, n) => n(Se(e, t)))(n, o, s);
                            case"defaultedOptionThunk":
                                return ((e, t, n, o) => o(Se(e, t).map((t => !0 === t ? n(e) : t))))(n, o, e.process, s);
                            case"mergeWithThunk":
                                return RN(n, o, T({}), (t => {
                                    const o = wN(e.process(n), t);
                                    return a(o)
                                }))
                        }
                    }, LN = e => ({
                        extract: (t, n) => ((e, t, n) => {
                            const o = {}, r = [];
                            for (const a of n) xN(a, ((n, a, s, i) => {
                                const l = DN(s, e, t, n, i);
                                hN(l, (e => {
                                    r.push(...e)
                                }), (e => {
                                    o[a] = e
                                }))
                            }), ((e, n) => {
                                o[e] = n(t)
                            }));
                            return r.length > 0 ? mN(r) : cN(o)
                        })(t, n, e), toString: () => {
                            const t = W(e, (e => xN(e, ((e, t, n, o) => e + " -> " + o.toString()), ((e, t) => "state(" + e + ")"))));
                            return "obj{\n" + t.join("\n") + "}"
                        }
                    }), ON = e => ({
                        extract: (t, n) => {
                            const o = W(n, ((n, o) => e.extract(t.concat(["[" + o + "]"]), n)));
                            return kN(o)
                        }, toString: () => "array(" + e.toString() + ")"
                    }), BN = (e, t, n) => dN(((e, t, n) => {
                        const o = t.extract([e], n);
                        return pN(o, (e => ({input: n, errors: e})))
                    })(e, t, n)), PN = e => "Errors: \n" + (e => {
                        const t = e.length > 10 ? e.slice(0, 10).concat([{
                            path: [],
                            getErrorInfo: T("... (only showing first ten failures)")
                        }]) : e;
                        return W(t, (e => "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
                    })(e.errors).join("\n") + "\n\nInput object: " + vN(e.input), IN = (e, t) => CN(e, ve(t, LN)),
                    MN = T(NN), FN = (e, t) => AN((n => {
                        const o = typeof n;
                        return e(n) ? cN(n) : mN(`Expected type: ${t} but got: ${o}`)
                    })), UN = FN(S, "number"), qN = FN(g, "string"), jN = FN(y, "boolean"), HN = FN(_, "function"),
                    zN = (e, t, n, o) => ({tag: "field", key: e, newKey: t, presence: n, prop: o}),
                    $N = (e, t) => ({tag: "custom", newKey: e, instantiator: t}), VN = e => {
                        return t = t => $(e, t) ? Tl.value(t) : Tl.error(`Unsupported value: "${t}", choose one of "${e.join(", ")}".`), AN((e => t(e).fold(mN, cN)));
                        var t
                    }, WN = (e, t) => zN(e, e, {tag: "required", process: {}}, t), KN = e => WN(e, qN), YN = e => WN(e, HN),
                    GN = (e, t) => zN(e, e, {tag: "option", process: {}}, t), XN = e => GN(e, qN),
                    JN = (e, t, n) => zN(e, e, _N(t), n), QN = (e, t) => JN(e, t, UN),
                    ZN = (e, t, n) => JN(e, t, VN(n)), eT = (e, t) => JN(e, t, jN), tT = (e, t) => JN(e, t, HN),
                    nT = KN("type"), oT = YN("fetch"), rT = YN("onAction"), aT = tT("onSetup", (() => x)),
                    sT = XN("text"), iT = XN("icon"), lT = XN("tooltip"), dT = XN("label"), cT = eT("active", !1),
                    uT = eT("enabled", !0), mT = eT("primary", !1), fT = e => ((e, t) => JN(e, t, qN))("type", e),
                    gT = LN([nT, KN("trigger"), QN("minChars", 1), (hT = 1, ((e, t) => zN(e, e, _N(t), MN()))("columns", hT)), QN("maxResults", 10), (pT = "matches", GN(pT, HN)), oT, rT, ((e, t, n) => JN(e, t, ON(n)))("highlightOn", [], qN)]);
                var pT, hT;
                const vT = [uT, lT, iT, sT, aT], bT = [cT].concat(vT),
                    yT = [tT("predicate", M), ZN("scope", "node", ["node", "editor"]), ZN("position", "selection", ["node", "selection", "line"])],
                    CT = vT.concat([fT("contextformbutton"), mT, rT, $N("original", R)]),
                    ET = bT.concat([fT("contextformbutton"), mT, rT, $N("original", R)]),
                    wT = vT.concat([fT("contextformbutton")]), _T = bT.concat([fT("contextformtogglebutton")]),
                    ST = IN("type", {contextformbutton: CT, contextformtogglebutton: ET});
                LN([fT("contextform"), tT("initValue", T("")), dT, ((e, t) => zN(e, e, {
                    tag: "required",
                    process: {}
                }, ON(t)))("commands", ST), GN("launch", IN("type", {
                    contextformbutton: wT,
                    contextformtogglebutton: _T
                }))].concat(yT));
                const kT = e => {
                        const t = e.ui.registry.getAll().popups, n = ve(t, (e => {
                            return (t = e, BN("Autocompleter", gT, {trigger: t.ch, ...t})).fold((e => {
                                throw new Error(PN(e))
                            }), R);
                            var t
                        })), o = Ae(we(n, (e => e.trigger))), r = _e(n);
                        return {dataset: n, triggers: o, lookupByTrigger: e => X(r, (t => t.trigger === e))}
                    }, xT = e => {
                        const t = si(), n = Zs(!1), o = t.isSet, r = () => {
                            o() && ((e => {
                                yw(e).autocompleter.removeDecoration()
                            })(e), (e => {
                                e.dispatch("AutocompleterEnd")
                            })(e), n.set(!1), t.clear())
                        }, a = n => {
                            o() || (((e, t) => {
                                yw(e).autocompleter.addDecoration(t)
                            })(e, n.range), t.set({trigger: n.trigger, matchLength: n.text.length}))
                        }, s = Ie((() => kT(e))), i = o => {
                            (n => t.get().map((t => ZA(e.dom, e.selection.getRng(), t.trigger).bind((t => rN(e, s, t, n))))).getOrThunk((() => oN(e, s))))(o).fold(r, (o => {
                                a(o.context), o.lookupData.then((a => {
                                    t.get().map((s => {
                                        const i = o.context;
                                        s.trigger === i.trigger && (i.text.length - s.matchLength >= 10 ? r() : (t.set({
                                            ...s,
                                            matchLength: i.text.length
                                        }), n.get() ? ((e, t) => {
                                            e.dispatch("AutocompleterUpdate", t)
                                        })(e, {lookupData: a}) : (n.set(!0), ((e, t) => {
                                            e.dispatch("AutocompleterStart", t)
                                        })(e, {lookupData: a}))))
                                    }))
                                }))
                            }))
                        };
                        e.addCommand("mceAutocompleterReload", ((e, t) => {
                            const n = p(t) ? t.fetchOptions : {};
                            i(n)
                        })), e.addCommand("mceAutocompleterClose", r), ((e, t) => {
                            const n = li(t.load, 50);
                            e.on("keypress compositionend", (e => {
                                27 !== e.which && n.throttle()
                            })), e.on("keydown", (e => {
                                const o = e.which;
                                8 === o ? n.throttle() : 27 === o && t.cancelIfNecessary()
                            })), e.on("remove", n.cancel)
                        })(e, {cancelIfNecessary: r, load: i})
                    }, AT = _t().browser.isSafari(), NT = e => Or(yn.fromDom(e)), TT = (e, t) => {
                        var n;
                        return 0 === e.startOffset && e.endOffset === (null === (n = t.textContent) || void 0 === n ? void 0 : n.length)
                    }, RT = (e, t) => U.from(e.getParent(t.container(), "details")), DT = (e, t) => RT(e, t).isSome(),
                    LT = (e, t) => t.startSummary.exists((t => ((e, t) => Yu(t).exists((t => t.isEqual(e))))(e, t))),
                    OT = (e, t) => t.startSummary.exists((t => ((e, t) => Gu(t).exists((n => ir(n.getNode()) && Ku(t, n).exists((t => t.isEqual(e))) || n.isEqual(e))))(e, t))),
                    BT = (e, t) => {
                        const n = t.getNode();
                        C(n) || e.selection.setCursorLocation(n, t.offset())
                    }, PT = (e, t, n) => {
                        const o = e.dom.getParent(t.container(), "details");
                        if (o && !o.open) {
                            const t = e.dom.select("summary", o)[0];
                            if (t) {
                                (n ? Yu(t) : Gu(t)).each((t => BT(e, t)))
                            }
                        } else BT(e, t)
                    }, IT = (e, t, n) => {
                        const {dom: o, selection: r} = e, a = e.getBody();
                        if ("character" === n) {
                            const n = rl.fromRangeStart(r.getRng()), s = o.getParent(n.container(), o.isBlock),
                                i = RT(o, n), l = s && o.isEmpty(s), d = b(null == s ? void 0 : s.previousSibling),
                                c = b(null == s ? void 0 : s.nextSibling);
                            if (l) {
                                if (t ? c : d) {
                                    if (zu(!t, a, n).exists((e => DT(o, e) && !It(i, RT(o, e))))) return !0
                                }
                            }
                            return zu(t, a, n).fold(M, (n => {
                                const r = RT(o, n);
                                if (DT(o, n) && !It(i, r)) {
                                    if (t || PT(e, n, !1), s && l) {
                                        if (t && d) return !0;
                                        if (!t && c) return !0;
                                        PT(e, n, t), e.dom.remove(s)
                                    }
                                    return !0
                                }
                                return !1
                            }))
                        }
                        return !1
                    }, MT = (e, t, n, o) => {
                        const r = e.selection.getRng(), a = rl.fromRangeStart(r), s = e.getBody();
                        return "selection" === o ? ((e, t) => {
                            const n = t.startSummary.exists((t => t.contains(e.startContainer))),
                                o = t.startSummary.exists((t => t.contains(e.endContainer))),
                                r = t.startDetails.forall((e => t.endDetails.forall((t => e !== t))));
                            return (n || o) && !(n && o) || r
                        })(r, t) : n ? OT(a, t) || ((e, t, n) => n.startDetails.exists((n => Wu(e, t).forall((e => !n.contains(e.container()))))))(s, a, t) : LT(a, t) || ((e, t) => t.startDetails.exists((n => Ku(n, e).forall((n => t.startSummary.exists((t => !t.contains(e.container()) && t.contains(n.container()))))))))(a, t)
                    }, FT = (e, t, n) => ((e, t) => {
                        const n = U.from(e.getParent(t.startContainer, "details")),
                            o = U.from(e.getParent(t.endContainer, "details"));
                        if (n.isSome() || o.isSome()) {
                            const t = n.bind((t => U.from(e.select("summary", t)[0])));
                            return U.some({startSummary: t, startDetails: n, endDetails: o})
                        }
                        return U.none()
                    })(e.dom, e.selection.getRng()).fold((() => IT(e, t, n)), (o => MT(e, o, t, n) || IT(e, t, n))),
                    UT = (e, t, n) => {
                        const o = e.selection, r = o.getNode(), a = o.getRng(), s = rl.fromRangeStart(a);
                        return !!hr(r) && ("selection" === n && TT(a, r) || yv(t, s, r) ? NT(r) : e.undoManager.transact((() => {
                            const a = o.getSel();
                            let {anchorNode: s, anchorOffset: i, focusNode: l, focusOffset: d} = null != a ? a : {};
                            const c = () => {
                                w(s) && w(i) && w(l) && w(d) && (null == a || a.setBaseAndExtent(s, i, l, d))
                            }, u = (e, t) => {
                                K(e.childNodes, (e => {
                                    Nm(e) && t.appendChild(e)
                                }))
                            }, m = e.dom.create("span", {"data-mce-bogus": "1"});
                            u(r, m), r.appendChild(m), c(), "word" !== n && "line" !== n || null == a || a.modify("extend", t ? "right" : "left", n), !o.isCollapsed() && TT(o.getRng(), m) ? NT(r) : (e.execCommand(t ? "ForwardDelete" : "Delete"), s = null == a ? void 0 : a.anchorNode, i = null == a ? void 0 : a.anchorOffset, l = null == a ? void 0 : a.focusNode, d = null == a ? void 0 : a.focusOffset, u(m, r), c()), e.dom.remove(m)
                        })), !0)
                    }, qT = (e, t, n) => FT(e, t, n) || AT && UT(e, t, n) ? U.some(x) : U.none(),
                    jT = e => (t, n, o = {}) => {
                        const r = t.getBody(), a = {
                            bubbles: !0,
                            composed: !0,
                            data: null,
                            isComposing: !1,
                            detail: 0,
                            view: null,
                            target: r,
                            currentTarget: r,
                            eventPhase: Event.AT_TARGET,
                            originalTarget: r,
                            explicitOriginalTarget: r,
                            isTrusted: !1,
                            srcElement: r,
                            cancelable: !1,
                            preventDefault: x,
                            inputType: n
                        }, s = Os(new InputEvent(e));
                        return t.dispatch(e, {...s, ...a, ...o})
                    }, HT = jT("input"), zT = jT("beforeinput"), $T = _t(), VT = $T.os, WT = VT.isMacOS() || VT.isiOS(),
                    KT = $T.browser.isFirefox(), YT = (e, t) => {
                        let n = !1;
                        e.on("keydown", (o => {
                            n = o.keyCode === Rf.BACKSPACE, o.isDefaultPrevented() || ((e, t, n) => {
                                const o = n.keyCode === Rf.BACKSPACE ? "deleteContentBackward" : "deleteContentForward",
                                    r = e.selection.isCollapsed(), a = r ? "character" : "selection",
                                    s = e => r ? e ? "word" : "line" : "selection";
                                cA([{keyCode: Rf.BACKSPACE, action: lA(Ax, e)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(NS, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(NS, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(vS, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(vS, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(nx, e, t, !1)
                                }, {keyCode: Rf.DELETE, action: lA(nx, e, t, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(eb, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(eb, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(qT, e, !1, a)
                                }, {keyCode: Rf.DELETE, action: lA(qT, e, !0, a)}, ...WT ? [{
                                    keyCode: Rf.BACKSPACE,
                                    altKey: !0,
                                    action: lA(qT, e, !1, s(!0))
                                }, {keyCode: Rf.DELETE, altKey: !0, action: lA(qT, e, !0, s(!0))}, {
                                    keyCode: Rf.BACKSPACE,
                                    metaKey: !0,
                                    action: lA(qT, e, !1, s(!1))
                                }] : [{
                                    keyCode: Rf.BACKSPACE,
                                    ctrlKey: !0,
                                    action: lA(qT, e, !1, s(!0))
                                }, {keyCode: Rf.DELETE, ctrlKey: !0, action: lA(qT, e, !0, s(!0))}], {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(TS, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(TS, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(yx, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(yx, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(cS, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(cS, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(sS, e, !1)
                                }, {keyCode: Rf.DELETE, action: lA(sS, e, !0)}, {
                                    keyCode: Rf.BACKSPACE,
                                    action: lA(gx, e, !1)
                                }, {
                                    keyCode: Rf.DELETE,
                                    action: lA(gx, e, !0)
                                }], n).filter((t => e.selection.isEditable())).each((t => {
                                    n.preventDefault(), zT(e, o).isDefaultPrevented() || (t(), HT(e, o))
                                }))
                            })(e, t, o)
                        })), e.on("keyup", (t => {
                            t.isDefaultPrevented() || ((e, t, n) => {
                                dA([{keyCode: Rf.BACKSPACE, action: lA(AS, e)}, {
                                    keyCode: Rf.DELETE,
                                    action: lA(AS, e)
                                }, ...WT ? [{keyCode: Rf.BACKSPACE, altKey: !0, action: lA(vx, e)}, {
                                    keyCode: Rf.DELETE,
                                    altKey: !0,
                                    action: lA(vx, e)
                                }, ...n ? [{keyCode: KT ? 224 : 91, action: lA(vx, e)}] : []] : [{
                                    keyCode: Rf.BACKSPACE,
                                    ctrlKey: !0,
                                    action: lA(vx, e)
                                }, {keyCode: Rf.DELETE, ctrlKey: !0, action: lA(vx, e)}]], t)
                            })(e, t, n), n = !1
                        }))
                    }, GT = (e, t) => {
                        const n = e.dom, o = e.schema.getMoveCaretBeforeOnEnterElements();
                        if (!t) return;
                        if (/^(LI|DT|DD)$/.test(t.nodeName)) {
                            const e = (e => {
                                for (; e;) {
                                    if (Vo(e) || tr(e) && e.data && /[\r\n\s]/.test(e.data)) return e;
                                    e = e.nextSibling
                                }
                                return null
                            })(t.firstChild);
                            e && /^(UL|OL|DL)$/.test(e.nodeName) && t.insertBefore(n.doc.createTextNode(br), t.firstChild)
                        }
                        const r = n.createRng();
                        if (t.normalize(), t.hasChildNodes()) {
                            const e = new Ho(t, t);
                            let n, a = t;
                            for (; n = e.current();) {
                                if (tr(n)) {
                                    r.setStart(n, 0), r.setEnd(n, 0);
                                    break
                                }
                                if (o[n.nodeName.toLowerCase()]) {
                                    r.setStartBefore(n), r.setEndBefore(n);
                                    break
                                }
                                a = n, n = e.next()
                            }
                            n || (r.setStart(a, 0), r.setEnd(a, 0))
                        } else ir(t) ? t.nextSibling && n.isBlock(t.nextSibling) ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)) : (r.setStart(t, 0), r.setEnd(t, 0));
                        e.selection.setRng(r), Bg(e, r)
                    }, XT = (e, t) => {
                        const n = e.getRoot();
                        let o, r = t;
                        for (; r !== n && r && "false" !== e.getContentEditable(r);) {
                            if ("true" === e.getContentEditable(r)) {
                                o = r;
                                break
                            }
                            r = r.parentNode
                        }
                        return r !== n ? o : n
                    }, JT = e => U.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), QT = e => {
                        e.innerHTML = '<br data-mce-bogus="1">'
                    }, ZT = (e, t) => {
                        if (Jl(e).toLowerCase() === t.tagName.toLowerCase()) {
                            ((e, t, n) => {
                                const o = e.dom;
                                U.from(n.style).map(o.parseStyle).each((e => {
                                    const n = {...fo(yn.fromDom(t)), ...e};
                                    o.setStyles(t, n)
                                }));
                                const r = U.from(n.class).map((e => e.split(/\s+/))),
                                    a = U.from(t.className).map((e => X(e.split(/\s+/), (e => "" !== e))));
                                Mt(r, a, ((e, n) => {
                                    const r = X(n, (t => !$(e, t))), a = [...e, ...r];
                                    o.setAttrib(t, "class", a.join(" "))
                                }));
                                const s = ["style", "class"], i = Ee(n, ((e, t) => !$(s, t)));
                                o.setAttribs(t, i)
                            })(e, t, Ql(e))
                        }
                    }, eR = (e, t, n, o, r = !0, a, s) => {
                        const i = e.dom, l = e.schema, d = Jl(e), c = n ? n.nodeName.toUpperCase() : "";
                        let u = t;
                        const m = l.getTextInlineElements();
                        let f;
                        f = a || "TABLE" === c || "HR" === c ? i.create(a || d, s || {}) : n.cloneNode(!1);
                        let g = f;
                        if (r) {
                            do {
                                if (m[u.nodeName]) {
                                    if (Ju(u) || um(u)) continue;
                                    const e = u.cloneNode(!1);
                                    i.setAttrib(e, "id", ""), f.hasChildNodes() ? (e.appendChild(f.firstChild), f.appendChild(e)) : (g = e, f.appendChild(e))
                                }
                            } while ((u = u.parentNode) && u !== o)
                        } else i.setAttrib(f, "style", null), i.setAttrib(f, "class", null);
                        return ZT(e, f), QT(g), f
                    }, tR = (e, t, n) => !t && n.nodeName.toLowerCase() === Jl(e) && e.dom.isEmpty(n) && ((e, t, n) => {
                        let o = t;
                        for (; o && o !== e && b(o.nextSibling);) {
                            const e = o.parentElement;
                            if (!e || !n(e)) return pr(e);
                            o = e
                        }
                        return !1
                    })(e.getBody(), n, (t => ke(e.schema.getTextBlockElements(), t.nodeName.toLowerCase()))),
                    nR = (e, t, n) => {
                        var o, r, a;
                        const s = t(Jl(e)), i = ((e, t) => e.dom.getParent(t, pr))(e, n);
                        i && (e.dom.insertAfter(s, i), GT(e, s), (null !== (a = null === (r = null === (o = n.parentElement) || void 0 === o ? void 0 : o.childNodes) || void 0 === r ? void 0 : r.length) && void 0 !== a ? a : 0) > 1 && e.dom.remove(n))
                    }, oR = (e, t) => {
                        const n = null == e ? void 0 : e.parentNode;
                        return w(n) && n.nodeName === t
                    }, rR = e => w(e) && /^(OL|UL|LI)$/.test(e.nodeName), aR = e => w(e) && /^(LI|DT|DD)$/.test(e.nodeName),
                    sR = e => {
                        const t = e.parentNode;
                        return aR(t) ? t : e
                    }, iR = (e, t, n) => {
                        let o = e[n ? "firstChild" : "lastChild"];
                        for (; o && !Vo(o);) o = o[n ? "nextSibling" : "previousSibling"];
                        return o === t
                    }, lR = e => Q(we(fo(yn.fromDom(e)), ((e, t) => `${t}: ${e};`)), ((e, t) => e + t), ""),
                    dR = (e, t, n, o, r) => {
                        const a = e.dom, s = e.selection.getRng(), i = n.parentNode;
                        if (n === e.getBody() || !i) return;
                        var l;
                        rR(l = n) && rR(l.parentNode) && (r = "LI");
                        const d = aR(o) ? lR(o) : void 0;
                        let c = aR(o) && d ? t(r, {style: lR(o)}) : t(r);
                        if (iR(n, o, !0) && iR(n, o, !1)) if (oR(n, "LI")) {
                            const e = sR(n);
                            a.insertAfter(c, e), (e => {
                                var t;
                                return (null === (t = e.parentNode) || void 0 === t ? void 0 : t.firstChild) === e
                            })(n) ? a.remove(e) : a.remove(n)
                        } else a.replace(c, n); else if (iR(n, o, !0)) oR(n, "LI") ? (a.insertAfter(c, sR(n)), c.appendChild(a.doc.createTextNode(" ")), c.appendChild(n)) : i.insertBefore(c, n), a.remove(o); else if (iR(n, o, !1)) a.insertAfter(c, sR(n)), a.remove(o); else {
                            n = sR(n);
                            const e = s.cloneRange();
                            e.setStartAfter(o), e.setEndAfter(n);
                            const t = e.extractContents();
                            if ("LI" === r && ((e, t) => e.firstChild && e.firstChild.nodeName === t)(t, "LI")) {
                                const e = X(W(c.children, yn.fromDom), O(Qt("br")));
                                c = t.firstChild, a.insertAfter(t, n), K(e, (e => vo(yn.fromDom(c), e))), d && c.setAttribute("style", d)
                            } else a.insertAfter(t, n), a.insertAfter(c, n);
                            a.remove(o)
                        }
                        GT(e, c)
                    }, cR = (e, t) => t && "A" === t.nodeName && e.isEmpty(t),
                    uR = (e, t) => e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t,
                    mR = (e, t) => w(t) && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && e.isEditable(t.parentNode) && "false" !== e.getContentEditable(t),
                    fR = (e, t, n) => tr(t) ? e ? 1 === n && t.data.charAt(n - 1) === Br ? 0 : n : n === t.data.length - 1 && t.data.charAt(n) === Br ? t.data.length : n : n,
                    gR = {
                        insert: (e, t) => {
                            let n, o, r, a, s = !1;
                            const i = e.dom, l = e.schema.getNonEmptyElements(), d = e.selection.getRng(), c = Jl(e),
                                u = yn.fromDom(d.startContainer), m = In(u, d.startOffset),
                                f = m.exists((e => Kt(e) && !oo(e))), p = d.collapsed && f,
                                h = (t, o) => eR(e, n, S, _, nd(e), t, o), v = e => {
                                    const t = fR(e, n, o);
                                    if (tr(n) && (e ? t > 0 : t < n.data.length)) return !1;
                                    if (n.parentNode === S && s && !e) return !0;
                                    if (e && Vo(n) && n === S.firstChild) return !0;
                                    if (uR(n, "TABLE") || uR(n, "HR")) return s && !e || !s && e;
                                    const r = new Ho(n, S);
                                    let a;
                                    for (tr(n) && (e && 0 === t ? r.prev() : e || t !== n.data.length || r.next()); a = r.current();) {
                                        if (Vo(a)) {
                                            if (!a.getAttribute("data-mce-bogus")) {
                                                const e = a.nodeName.toLowerCase();
                                                if (l[e] && "br" !== e) return !1
                                            }
                                        } else if (tr(a) && !ia(a.data)) return !1;
                                        e ? r.prev() : r.next()
                                    }
                                    return !0
                                }, b = () => {
                                    let t;
                                    return t = /^(H[1-6]|PRE|FIGURE)$/.test(r) && "HGROUP" !== k ? h(c) : h(), ((e, t) => {
                                        const n = od(e);
                                        return !E(t) && (g(n) ? $(Bt.explode(n), t.nodeName.toLowerCase()) : n)
                                    })(e, a) && mR(i, a) && i.isEmpty(S, void 0, {includeZwsp: !0}) ? t = i.split(a, S) : i.insertAfter(t, S), GT(e, t), t
                                };
                            dg(i, d).each((e => {
                                d.setStart(e.startContainer, e.startOffset), d.setEnd(e.endContainer, e.endOffset)
                            })), n = d.startContainer, o = d.startOffset;
                            const y = !(!t || !t.shiftKey), C = !(!t || !t.ctrlKey);
                            Vo(n) && n.hasChildNodes() && !p && (s = o > n.childNodes.length - 1, n = n.childNodes[Math.min(o, n.childNodes.length - 1)] || n, o = s && tr(n) ? n.data.length : 0);
                            const _ = XT(i, n);
                            if (!_ || ((e, t) => {
                                const n = e.dom.getParent(t, "ol,ul,dl");
                                return null !== n && "false" === e.dom.getContentEditableParent(n)
                            })(e, n)) return;
                            y || (n = ((e, t, n, o, r) => {
                                var a, s;
                                const i = e.dom, l = null !== (a = XT(i, o)) && void 0 !== a ? a : i.getRoot();
                                let d = i.getParent(o, i.isBlock);
                                if (!d || !mR(i, d)) {
                                    if (d = d || l, !d.hasChildNodes()) {
                                        const o = i.create(t);
                                        return ZT(e, o), d.appendChild(o), n.setStart(o, 0), n.setEnd(o, 0), o
                                    }
                                    let a, c = o;
                                    for (; c && c.parentNode !== d;) c = c.parentNode;
                                    for (; c && !i.isBlock(c);) a = c, c = c.previousSibling;
                                    const u = null === (s = null == a ? void 0 : a.parentElement) || void 0 === s ? void 0 : s.nodeName;
                                    if (a && u && e.schema.isValidChild(u, t.toLowerCase())) {
                                        const s = a.parentNode, l = i.create(t);
                                        for (ZT(e, l), s.insertBefore(l, a), c = a; c && !i.isBlock(c);) {
                                            const e = c.nextSibling;
                                            l.appendChild(c), c = e
                                        }
                                        n.setStart(o, r), n.setEnd(o, r)
                                    }
                                }
                                return o
                            })(e, c, d, n, o));
                            let S = i.getParent(n, i.isBlock) || i.getRoot();
                            a = w(null == S ? void 0 : S.parentNode) ? i.getParent(S.parentNode, i.isBlock) : null, r = S ? S.nodeName.toUpperCase() : "";
                            const k = a ? a.nodeName.toUpperCase() : "";
                            if ("LI" === k && !C) {
                                S = a, a = a.parentNode, r = k
                            }
                            if (Vo(a) && tR(e, y, S)) return nR(e, h, S);
                            if (/^(LI|DT|DD)$/.test(r) && Vo(a) && i.isEmpty(S)) return void dR(e, h, a, S, c);
                            if (!(p || S !== e.getBody() && mR(i, S))) return;
                            const x = S.parentNode;
                            let A;
                            if (p) A = h(c), m.fold((() => {
                                bo(u, yn.fromDom(A))
                            }), (e => {
                                po(e, yn.fromDom(A))
                            })), e.selection.setCursorLocation(A, 0); else if (Ur(S)) A = Kr(S), i.isEmpty(S) && QT(S), ZT(e, A), GT(e, A); else if (v(!1)) A = b(); else if (v(!0) && x) {
                                A = x.insertBefore(h(), S);
                                const t = yn.fromDom(d.startContainer).dom.hasChildNodes() && d.collapsed;
                                GT(e, uR(S, "HR") || t ? A : S)
                            } else {
                                const t = (e => {
                                    const t = e.cloneRange();
                                    return t.setStart(e.startContainer, fR(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, fR(!1, e.endContainer, e.endOffset)), t
                                })(d).cloneRange();
                                t.setEndAfter(S);
                                const n = t.extractContents();
                                (e => {
                                    K(Uo(yn.fromDom(e), Gt), (e => {
                                        const t = e.dom;
                                        t.nodeValue = Ir(t.data)
                                    }))
                                })(n), (e => {
                                    let t = e;
                                    do {
                                        tr(t) && (t.data = t.data.replace(/^[\r\n]+/, "")), t = t.firstChild
                                    } while (t)
                                })(n), A = n.firstChild, i.insertAfter(n, S), ((e, t, n) => {
                                    var o;
                                    const r = [];
                                    if (!n) return;
                                    let a = n;
                                    for (; a = a.firstChild;) {
                                        if (e.isBlock(a)) return;
                                        Vo(a) && !t[a.nodeName.toLowerCase()] && r.push(a)
                                    }
                                    let s = r.length;
                                    for (; s--;) a = r[s], (!a.hasChildNodes() || a.firstChild === a.lastChild && "" === (null === (o = a.firstChild) || void 0 === o ? void 0 : o.nodeValue) || cR(e, a)) && e.remove(a)
                                })(i, l, A), ((e, t) => {
                                    t.normalize();
                                    const n = t.lastChild;
                                    (!n || Vo(n) && /^(left|right)$/gi.test(e.getStyle(n, "float", !0))) && e.add(t, "br")
                                })(i, S), i.isEmpty(S) && QT(S), A.normalize(), i.isEmpty(A) ? (i.remove(A), b()) : (ZT(e, A), GT(e, A))
                            }
                            i.setAttrib(A, "id", ""), e.dispatch("NewBlock", {newBlock: A})
                        }, fakeEventName: "insertParagraph"
                    }, pR = (e, t, n) => {
                        const o = e.dom.createRng();
                        n ? (o.setStartBefore(t), o.setEndBefore(t)) : (o.setStartAfter(t), o.setEndAfter(t)), e.selection.setRng(o), Bg(e, o)
                    }, hR = (e, t) => {
                        const n = e.selection, o = e.dom, r = n.getRng();
                        let a, s = !1;
                        dg(o, r).each((e => {
                            r.setStart(e.startContainer, e.startOffset), r.setEnd(e.endContainer, e.endOffset)
                        }));
                        let i = r.startOffset, l = r.startContainer;
                        if (Vo(l) && l.hasChildNodes()) {
                            const e = i > l.childNodes.length - 1;
                            l = l.childNodes[Math.min(i, l.childNodes.length - 1)] || l, i = e && tr(l) ? l.data.length : 0
                        }
                        let d = o.getParent(l, o.isBlock);
                        const c = d && d.parentNode ? o.getParent(d.parentNode, o.isBlock) : null,
                            u = c ? c.nodeName.toUpperCase() : "", m = !(!t || !t.ctrlKey);
                        "LI" !== u || m || (d = c), tr(l) && i >= l.data.length && (((e, t, n) => {
                            const o = new Ho(t, n);
                            let r;
                            const a = e.getNonEmptyElements();
                            for (; r = o.next();) if (a[r.nodeName.toLowerCase()] || tr(r) && r.length > 0) return !0;
                            return !1
                        })(e.schema, l, d || o.getRoot()) || (a = o.create("br"), r.insertNode(a), r.setStartAfter(a), r.setEndAfter(a), s = !0)), a = o.create("br"), sl(o, r, a), pR(e, a, s), e.undoManager.add()
                    }, vR = (e, t) => {
                        const n = yn.fromTag("br");
                        po(yn.fromDom(t), n), e.undoManager.add()
                    }, bR = (e, t) => {
                        yR(e.getBody(), t) || ho(yn.fromDom(t), yn.fromTag("br"));
                        const n = yn.fromTag("br");
                        ho(yn.fromDom(t), n), pR(e, n.dom, !1), e.undoManager.add()
                    }, yR = (e, t) => {
                        return n = rl.after(t), !!ir(n.getNode()) || Wu(e, rl.after(t)).map((e => ir(e.getNode()))).getOr(!1);
                        var n
                    }, CR = e => e && "A" === e.nodeName && "href" in e, ER = e => e.fold(M, CR, CR, M), wR = (e, t) => {
                        t.fold(x, L(vR, e), L(bR, e), x)
                    }, _R = {
                        insert: (e, t) => {
                            const n = (e => {
                                const t = L(lv, e), n = rl.fromRangeStart(e.selection.getRng());
                                return XS(t, e.getBody(), n).filter(ER)
                            })(e);
                            n.isSome() ? n.each(L(wR, e)) : hR(e, t)
                        }, fakeEventName: "insertLineBreak"
                    }, SR = (e, t) => JT(e).filter((e => t.length > 0 && En(yn.fromDom(e), t))).isSome(),
                    kR = Rl([{br: []}, {block: []}, {none: []}]), xR = (e, t) => (e => SR(e, td(e)))(e),
                    AR = e => (t, n) => (e => JT(e).filter((e => Ar(yn.fromDom(e)))).isSome())(t) === e,
                    NR = (e, t) => (n, o) => {
                        const r = (e => JT(e).fold(T(""), (e => e.nodeName.toUpperCase())))(n) === e.toUpperCase();
                        return r === t
                    }, TR = e => {
                        const t = XT(e.dom, e.selection.getStart());
                        return E(t)
                    }, RR = e => NR("pre", e), DR = e => (t, n) => Xl(t) === e, LR = (e, t) => (e => SR(e, ed(e)))(e),
                    OR = (e, t) => t, BR = e => {
                        const t = Jl(e), n = XT(e.dom, e.selection.getStart());
                        return w(n) && e.schema.isValidChild(n.nodeName, t)
                    }, PR = e => {
                        const t = e.selection.getRng(), n = yn.fromDom(t.startContainer),
                            o = In(n, t.startOffset).map((e => Kt(e) && !oo(e)));
                        return t.collapsed && o.getOr(!0)
                    }, IR = (e, t) => (n, o) => Q(e, ((e, t) => e && t(n, o)), !0) ? U.some(t) : U.none(),
                    MR = (e, t, n) => {
                        if (t.selection.isCollapsed() || (e => {
                            e.execCommand("delete")
                        })(t), w(n)) {
                            if (zT(t, e.fakeEventName).isDefaultPrevented()) return
                        }
                        e.insert(t, n), w(n) && HT(t, e.fakeEventName)
                    }, FR = (e, t) => {
                        const n = () => MR(_R, e, t), o = () => MR(gR, e, t),
                            r = ((e, t) => qS([IR([xR], kR.none()), IR([RR(!0), TR], kR.none()), IR([NR("summary", !0)], kR.br()), IR([RR(!0), DR(!1), OR], kR.br()), IR([RR(!0), DR(!1)], kR.block()), IR([RR(!0), DR(!0), OR], kR.block()), IR([RR(!0), DR(!0)], kR.br()), IR([AR(!0), OR], kR.br()), IR([AR(!0)], kR.block()), IR([LR], kR.br()), IR([OR], kR.br()), IR([BR], kR.block()), IR([PR], kR.block())], [e, !(!t || !t.shiftKey)]).getOr(kR.none()))(e, t);
                        switch (Zl(e)) {
                            case"linebreak":
                                r.fold(n, n, x);
                                break;
                            case"block":
                                r.fold(o, o, x);
                                break;
                            case"invert":
                                r.fold(o, n, x);
                                break;
                            default:
                                r.fold(n, o, x)
                        }
                    }, UR = _t(), qR = UR.os.isiOS() && UR.browser.isSafari(), jR = (e, t) => {
                        var n;
                        t.isDefaultPrevented() || (t.preventDefault(), (n = e.undoManager).typing && (n.typing = !1, n.add()), e.undoManager.transact((() => {
                            FR(e, t)
                        })))
                    }, HR = e => {
                        let t = U.none();
                        e.on("keydown", (n => {
                            n.keyCode === Rf.ENTER && (qR && (e => {
                                if (!e.collapsed) return !1;
                                const t = e.startContainer;
                                if (tr(t)) {
                                    const n = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/,
                                        o = t.data.charAt(e.startOffset - 1);
                                    return n.test(o)
                                }
                                return !1
                            })(e.selection.getRng()) ? (e => {
                                t = U.some(e.selection.getBookmark()), e.undoManager.add()
                            })(e) : jR(e, n))
                        })), e.on("keyup", (n => {
                            n.keyCode === Rf.ENTER && t.each((() => ((e, n) => {
                                e.undoManager.undo(), t.fold(x, (t => e.selection.moveToBookmark(t))), jR(e, n), t = U.none()
                            })(e, n)))
                        }))
                    }, zR = (e, t) => {
                        e.on("keydown", (n => {
                            n.isDefaultPrevented() || ((e, t, n) => {
                                const o = Rt.os.isMacOS() || Rt.os.isiOS();
                                dA([{keyCode: Rf.END, action: lA(Jx, e, !0)}, {
                                    keyCode: Rf.HOME,
                                    action: lA(Jx, e, !1)
                                }, ...o ? [] : [{
                                    keyCode: Rf.HOME,
                                    action: lA(Qx, e, !1),
                                    ctrlKey: !0,
                                    shiftKey: !0
                                }, {keyCode: Rf.END, action: lA(Qx, e, !0), ctrlKey: !0, shiftKey: !0}], {
                                    keyCode: Rf.END,
                                    action: lA(fA, e, !0)
                                }, {keyCode: Rf.HOME, action: lA(fA, e, !1)}, {
                                    keyCode: Rf.END,
                                    action: lA(Qk, e, !0, t)
                                }, {keyCode: Rf.HOME, action: lA(Qk, e, !1, t)}], n).each((e => {
                                    n.preventDefault()
                                }))
                            })(e, t, n)
                        }))
                    }, $R = e => {
                        e.on("input", (t => {
                            t.isComposing || (e => {
                                const t = yn.fromDom(e.getBody());
                                e.selection.isCollapsed() && Wh(t, rl.fromRangeStart(e.selection.getRng()), e.schema).each((t => {
                                    e.selection.setRng(t.toRange())
                                }))
                            })(e)
                        }))
                    }, VR = _t(), WR = e => e.stopImmediatePropagation(),
                    KR = e => e.keyCode === Rf.PAGE_UP || e.keyCode === Rf.PAGE_DOWN, YR = (e, t, n) => {
                        n && !e.get() ? t.on("NodeChange", WR, !0) : !n && e.get() && t.off("NodeChange", WR), e.set(n)
                    }, GR = (e, t) => {
                        if (VR.os.isMacOS()) return;
                        const n = Zs(!1);
                        e.on("keydown", (t => {
                            KR(t) && YR(n, e, !0)
                        })), e.on("keyup", (o => {
                            o.isDefaultPrevented() || ((e, t, n) => {
                                dA([{keyCode: Rf.PAGE_UP, action: lA(Qk, e, !1, t)}, {
                                    keyCode: Rf.PAGE_DOWN,
                                    action: lA(Qk, e, !0, t)
                                }], n)
                            })(e, t, o), KR(o) && n.get() && (YR(n, e, !1), e.nodeChanged())
                        }))
                    }, XR = (e, t) => {
                        const n = t.container(), o = t.offset();
                        return tr(n) ? (n.insertData(o, e), U.some(rl(n, o + e.length))) : _u(t).map((n => {
                            const o = yn.fromText(e);
                            return t.isAtEnd() ? ho(n, o) : po(n, o), rl(o.dom, e.length)
                        }))
                    }, JR = L(XR, br), QR = L(XR, " "), ZR = e => t => {
                        e.selection.setRng(t.toRange()), e.nodeChanged()
                    }, eD = e => {
                        const t = rl.fromRangeStart(e.selection.getRng()), n = yn.fromDom(e.getBody());
                        if (e.selection.isCollapsed()) {
                            const o = L(lv, e), r = rl.fromRangeStart(e.selection.getRng());
                            return XS(o, e.getBody(), r).bind((e => t => t.fold((t => Ku(e.dom, rl.before(t))), (e => Yu(e)), (e => Gu(e)), (t => Wu(e.dom, rl.after(t)))))(n)).map((o => () => ((e, t, n) => o => Mh(e, o, n) ? JR(t) : QR(t))(n, t, e.schema)(o).each(ZR(e))))
                        }
                        return U.none()
                    }, tD = e => {
                        return Ft(Rt.browser.isFirefox() && e.selection.isEditable() && (t = e.dom, n = e.selection.getRng().startContainer, t.isEditable(t.getParent(n, "summary"))), (() => {
                            const t = yn.fromDom(e.getBody());
                            e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
                            ((e, t, n) => Mh(e, t, n) ? JR(t) : QR(t))(t, rl.fromRangeStart(e.selection.getRng()), e.schema).each(ZR(e))
                        }));
                        var t, n
                    }, nD = e => {
                        e.on("keydown", (t => {
                            t.isDefaultPrevented() || ((e, t) => {
                                cA([{keyCode: Rf.SPACEBAR, action: lA(eD, e)}, {
                                    keyCode: Rf.SPACEBAR,
                                    action: lA(tD, e)
                                }], t).each((n => {
                                    t.preventDefault(), zT(e, "insertText", {data: " "}).isDefaultPrevented() || (n(), HT(e, "insertText", {data: " "}))
                                }))
                            })(e, t)
                        }))
                    }, oD = e => Rc(e) ? [{keyCode: Rf.TAB, action: lA(qA, e, !0)}, {
                        keyCode: Rf.TAB,
                        shiftKey: !0,
                        action: lA(qA, e, !1)
                    }] : [], rD = e => {
                        e.on("keydown", (t => {
                            t.isDefaultPrevented() || ((e, t) => {
                                dA([...oD(e)], t).each((e => {
                                    t.preventDefault()
                                }))
                            })(e, t)
                        }))
                    }, aD = e => {
                        if (e.addShortcut("Meta+P", "", "mcePrint"), xT(e), hw(e)) return Zs(null);
                        {
                            const t = Gk(e);
                            return (e => {
                                e.on("beforeinput", (t => {
                                    e.selection.isEditable() && !V(t.getTargetRanges(), (t => !up(e.dom, t))) || t.preventDefault()
                                }))
                            })(e), (e => {
                                e.on("keyup compositionstart", L($x, e))
                            })(e), jA(e, t), YT(e, t), HR(e), nD(e), $R(e), rD(e), zR(e, t), GR(e, t), t
                        }
                    };

                class sD {
                    constructor(e) {
                        let t;
                        this.lastPath = [], this.editor = e;
                        const n = this;
                        "onselectionchange" in e.getDoc() || e.on("NodeChange click mouseup keyup focus", (n => {
                            const o = e.selection.getRng(), r = {
                                startContainer: o.startContainer,
                                startOffset: o.startOffset,
                                endContainer: o.endContainer,
                                endOffset: o.endOffset
                            };
                            "nodechange" !== n.type && ng(r, t) || e.dispatch("SelectionChange"), t = r
                        })), e.on("contextmenu", (() => {
                            e.dispatch("SelectionChange")
                        })), e.on("SelectionChange", (() => {
                            const t = e.selection.getStart(!0);
                            t && km(e) && !n.isSameElementPath(t) && e.dom.isChildOf(t, e.getBody()) && e.nodeChanged({selectionChange: !0})
                        })), e.on("mouseup", (t => {
                            !t.isDefaultPrevented() && km(e) && ("IMG" === e.selection.getNode().nodeName ? Yg.setEditorTimeout(e, (() => {
                                e.nodeChanged()
                            })) : e.nodeChanged())
                        }))
                    }

                    nodeChanged(e = {}) {
                        const t = this.editor.selection;
                        let n;
                        if (this.editor.initialized && t && !Vd(this.editor) && !this.editor.mode.isReadOnly()) {
                            const o = this.editor.getBody();
                            n = t.getStart(!0) || o, n.ownerDocument === this.editor.getDoc() && this.editor.dom.isChildOf(n, o) || (n = o);
                            const r = [];
                            this.editor.dom.getParent(n, (e => e === o || (r.push(e), !1))), this.editor.dispatch("NodeChange", {
                                ...e,
                                element: n,
                                parents: r
                            })
                        }
                    }

                    isSameElementPath(e) {
                        let t;
                        const n = this.editor, o = ae(n.dom.getParents(e, F, n.getBody()));
                        if (o.length === this.lastPath.length) {
                            for (t = o.length; t >= 0 && o[t] === this.lastPath[t]; t--) ;
                            if (-1 === t) return this.lastPath = o, !0
                        }
                        return this.lastPath = o, !1
                    }
                }

                const iD = wi("image"), lD = wi("event"), dD = e => t => {
                    t[lD] = e
                }, cD = dD(0), uD = dD(2), mD = dD(1), fD = (gD = 0, e => {
                    const t = e;
                    return U.from(t[lD]).exists((e => e === gD))
                });
                var gD;
                const pD = wi("mode"), hD = e => t => {
                        t[pD] = e
                    }, vD = (e, t) => hD(t)(e), bD = hD(0), yD = hD(2), CD = hD(1), ED = e => t => {
                        const n = t;
                        return U.from(n[pD]).exists((t => t === e))
                    }, wD = ED(0), _D = ED(1), SD = ["none", "copy", "link", "move"],
                    kD = ["none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", "uninitialized"],
                    xD = () => {
                        const e = new window.DataTransfer;
                        let t = "move", n = "all";
                        const o = {
                            get dropEffect() {
                                return t
                            }, set dropEffect(e) {
                                $(SD, e) && (t = e)
                            }, get effectAllowed() {
                                return n
                            }, set effectAllowed(e) {
                                fD(o) && $(kD, e) && (n = e)
                            }, get items() {
                                return ((e, t) => ({
                                    ...t, get length() {
                                        return t.length
                                    }, add: (n, o) => {
                                        if (wD(e)) {
                                            if (!g(n)) return t.add(n);
                                            if (!C(o)) return t.add(n, o)
                                        }
                                        return null
                                    }, remove: n => {
                                        wD(e) && t.remove(n)
                                    }, clear: () => {
                                        wD(e) && t.clear()
                                    }
                                }))(o, e.items)
                            }, get files() {
                                return _D(o) ? Object.freeze({length: 0, item: e => null}) : e.files
                            }, get types() {
                                return e.types
                            }, setDragImage: (t, n, r) => {
                                var a;
                                wD(o) && (a = {image: t, x: n, y: r}, o[iD] = a, e.setDragImage(t, n, r))
                            }, getData: t => _D(o) ? "" : e.getData(t), setData: (t, n) => {
                                wD(o) && e.setData(t, n)
                            }, clearData: t => {
                                wD(o) && e.clearData(t)
                            }
                        };
                        return bD(o), o
                    }, AD = e => {
                        const t = xD(), n = (e => {
                            const t = e;
                            return U.from(t[pD])
                        })(e);
                        return yD(e), cD(t), t.dropEffect = e.dropEffect, t.effectAllowed = e.effectAllowed, (e => {
                            const t = e;
                            return U.from(t[iD])
                        })(e).each((e => t.setDragImage(e.image, e.x, e.y))), K(e.types, (n => {
                            "Files" !== n && t.setData(n, e.getData(n))
                        })), K(e.files, (e => t.items.add(e))), (e => {
                            const t = e;
                            return U.from(t[lD])
                        })(e).each((e => {
                            ((e, t) => {
                                dD(t)(e)
                            })(t, e)
                        })), n.each((n => {
                            vD(e, n), vD(t, n)
                        })), t
                    }, ND = (e, t) => e.setData("text/html", t), TD = "x-tinymce/html", RD = T(TD),
                    DD = "\x3c!-- " + TD + " --\x3e", LD = e => DD + e, OD = e => -1 !== e.indexOf(DD),
                    BD = (e, t, n) => {
                        const o = e.split(/\n\n/), r = ((e, t) => {
                            let n = "<" + e;
                            const o = we(t, ((e, t) => t + '="' + is.encodeAllRaw(e) + '"'));
                            return o.length && (n += " " + o.join(" ")), n + ">"
                        })(t, n), a = "</" + t + ">", s = W(o, (e => e.split(/\n/).join("<br />")));
                        return 1 === s.length ? s[0] : W(s, (e => r + e + a)).join("")
                    }, PD = "%MCEPASTEBIN%", ID = e => e.dom.get("mcepastebin"),
                    MD = e => w(e) && "mcepastebin" === e.id, FD = e => e === PD, UD = e => {
                        const t = Zs(null);
                        return {
                            create: () => ((e, t) => {
                                const {dom: n, selection: o} = e, r = e.getBody();
                                t.set(o.getRng());
                                const a = n.add(e.getBody(), "div", {
                                    id: "mcepastebin",
                                    class: "mce-pastebin",
                                    contentEditable: !0,
                                    "data-mce-bogus": "all",
                                    style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
                                }, PD);
                                Rt.browser.isFirefox() && n.setStyle(a, "left", "rtl" === n.getStyle(r, "direction", !0) ? 65535 : -65535), n.bind(a, "beforedeactivate focusin focusout", (e => {
                                    e.stopPropagation()
                                })), a.focus(), o.select(a, !0)
                            })(e, t), remove: () => ((e, t) => {
                                const n = e.dom;
                                if (ID(e)) {
                                    let o;
                                    const r = t.get();
                                    for (; o = ID(e);) n.remove(o), n.unbind(o);
                                    r && e.selection.setRng(r)
                                }
                                t.set(null)
                            })(e, t), getEl: () => ID(e), getHtml: () => (e => {
                                const t = e.dom, n = (e, n) => {
                                    e.appendChild(n), t.remove(n, !0)
                                }, [o, ...r] = X(e.getBody().childNodes, MD);
                                K(r, (e => {
                                    n(o, e)
                                }));
                                const a = t.select("div[id=mcepastebin]", o);
                                for (let e = a.length - 1; e >= 0; e--) {
                                    const r = t.create("div");
                                    o.insertBefore(r, a[e]), n(r, a[e])
                                }
                                return o ? o.innerHTML : ""
                            })(e), getLastRng: t.get
                        }
                    }, qD = (e, t) => (Bt.each(t, (t => {
                        e = f(t, RegExp) ? e.replace(t, "") : e.replace(t[0], t[1])
                    })), e),
                    jD = e => e = qD(e, [/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, (e, t, n) => t || n ? br : " "], /<br class="Apple-interchange-newline">/g, /<br>$/i]),
                    HD = (e, t) => ({content: e, cancelled: t}), zD = (e, t, n) => {
                        const o = ((e, t, n) => e.dispatch("PastePreProcess", {content: t, internal: n}))(e, t, n),
                            r = ((e, t) => {
                                const n = DE({sanitize: Ac(e), sandbox_iframes: Bc(e)}, e.schema);
                                n.addNodeFilter("meta", (e => {
                                    Bt.each(e, (e => {
                                        e.remove()
                                    }))
                                }));
                                const o = n.parse(t, {forced_root_block: !1, isRootContent: !0});
                                return Kp({validate: !0}, e.schema).serialize(o)
                            })(e, o.content);
                        return e.hasEventListeners("PastePostProcess") && !o.isDefaultPrevented() ? ((e, t, n) => {
                            const o = e.dom.create("div", {style: "display:none"}, t),
                                r = ((e, t, n) => e.dispatch("PastePostProcess", {node: t, internal: n}))(e, o, n);
                            return HD(r.node.innerHTML, r.isDefaultPrevented())
                        })(e, r, n) : HD(r, o.isDefaultPrevented())
                    }, $D = (e, t) => (e.insertContent(t, {merge: pc(e), paste: !0}), !0),
                    VD = e => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e),
                    WD = (e, t, n) => !(e.selection.isCollapsed() || !VD(t)) && ((e, t, n) => (e.undoManager.extra((() => {
                        n(e, t)
                    }), (() => {
                        e.execCommand("mceInsertLink", !1, t)
                    })), !0))(e, t, n),
                    KD = (e, t, n) => !!((e, t) => VD(t) && V(Tc(e), (e => Ve(t.toLowerCase(), `.${e.toLowerCase()}`))))(e, t) && ((e, t, n) => (e.undoManager.extra((() => {
                        n(e, t)
                    }), (() => {
                        e.insertContent('<img src="' + t + '">')
                    })), !0))(e, t, n), YD = (e, t, n) => {
                        n || !hc(e) ? $D(e, t) : ((e, t) => {
                            Bt.each([WD, KD, $D], (n => !n(e, t, $D)))
                        })(e, t)
                    }, GD = (e => {
                        let t = 0;
                        return () => e + t++
                    })("mceclip"), XD = e => {
                        const t = xD();
                        return ND(t, e), yD(t), t
                    }, JD = (e, t, n, o, r) => {
                        const a = ((e, t, n) => zD(e, t, n))(e, t, n);
                        if (!a.cancelled) {
                            const t = a.content, n = () => YD(e, t, o);
                            if (r) {
                                zT(e, "insertFromPaste", {dataTransfer: XD(t)}).isDefaultPrevented() || (n(), HT(e, "insertFromPaste"))
                            } else n()
                        }
                    }, QD = (e, t, n, o) => {
                        const r = n || OD(t);
                        JD(e, (e => e.replace(DD, ""))(t), r, !1, o)
                    }, ZD = (e, t, n) => {
                        const o = e.dom.encode(t).replace(/\r\n/g, "\n"), r = ca(o, bc(e)), a = BD(r, Jl(e), Ql(e));
                        JD(e, a, !1, !0, n)
                    }, eL = e => {
                        const t = {};
                        if (e && e.types) for (let n = 0; n < e.types.length; n++) {
                            const o = e.types[n];
                            try {
                                t[o] = e.getData(o)
                            } catch (e) {
                                t[o] = ""
                            }
                        }
                        return t
                    }, tL = (e, t) => t in e && e[t].length > 0, nL = e => tL(e, "text/html") || tL(e, "text/plain"),
                    oL = (e, t, n, o) => {
                        const r = GD(), a = ad(e) && w(n.name), s = a ? ((e, t) => {
                            const n = t.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
                            return w(n) ? e.dom.encode(n[1]) : void 0
                        })(e, n.name) : r, i = a ? n.name : void 0, l = t.create(r, n, o, s, i);
                        return t.add(l), l
                    }, rL = e => {
                        const t = Tc(e);
                        return e => $e(e.type, "image/") && V(t, (t => (e => {
                            const t = e.toLowerCase(), n = {
                                jpg: "jpeg",
                                jpe: "jpeg",
                                jfi: "jpeg",
                                jif: "jpeg",
                                jfif: "jpeg",
                                pjpeg: "jpeg",
                                pjp: "jpeg",
                                svg: "svg+xml"
                            };
                            return Bt.hasOwn(n, t) ? "image/" + n[t] : "image/" + t
                        })(t) === e.type))
                    }, aL = (e, t, n) => {
                        const o = (e => "paste" === e.type)(t) ? t.clipboardData : t.dataTransfer;
                        if (dc(e) && o) {
                            const a = ((e, t) => {
                                const n = t.items ? oe(me(t.items), (e => "file" === e.kind ? [e.getAsFile()] : [])) : [],
                                    o = t.files ? me(t.files) : [];
                                return X(n.length > 0 ? n : o, rL(e))
                            })(e, o);
                            if (a.length > 0) return t.preventDefault(), (r = a, Promise.all(W(r, (e => sC(e).then((t => ({
                                file: e,
                                uri: t
                            }))))))).then((t => {
                                n && e.selection.setRng(n), K(t, (t => {
                                    ((e, t) => {
                                        oC(t.uri).each((({data: n, type: o, base64Encoded: r}) => {
                                            const a = r ? n : btoa(n), s = t.file, i = e.editorUpload.blobCache,
                                                l = i.getByData(a, o), d = null != l ? l : oL(e, i, s, a);
                                            QD(e, `<img src="${d.blobUri()}">`, !1, !0)
                                        }))
                                    })(e, t)
                                }))
                            })), !0
                        }
                        var r;
                        return !1
                    }, sL = (e, t, n, o, r) => {
                        let a = jD(n);
                        const s = tL(t, RD()) || OD(n),
                            i = !s && (e => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e))(a),
                            l = VD(a);
                        (FD(a) || !a.length || i && !l) && (o = !0), (o || l) && (a = tL(t, "text/plain") && i ? t["text/plain"] : (e => {
                            const t = ys(), n = DE({}, t);
                            let o = "";
                            const r = t.getVoidElements(),
                                a = Bt.makeMap("script noscript style textarea video audio iframe object", " "),
                                s = t.getBlockElements(), i = e => {
                                    const n = e.name, l = e;
                                    if ("br" !== n) {
                                        if ("wbr" !== n) if (r[n] && (o += " "), a[n]) o += " "; else {
                                            if (3 === e.type && (o += e.value), !(e.name in t.getVoidElements())) {
                                                let t = e.firstChild;
                                                if (t) do {
                                                    i(t)
                                                } while (t = t.next)
                                            }
                                            s[n] && l.next && (o += "\n", "p" === n && (o += "\n"))
                                        }
                                    } else o += "\n"
                                };
                            return e = qD(e, [/<!\[[^\]]+\]>/g]), i(n.parse(e)), o
                        })(a)), FD(a) || (o ? ZD(e, a, r) : QD(e, a, s, r))
                    }, iL = (e, t, n) => {
                        let o;
                        e.on("keydown", (e => {
                            (e => Rf.metaKeyPressed(e) && 86 === e.keyCode || e.shiftKey && 45 === e.keyCode)(e) && !e.isDefaultPrevented() && (o = e.shiftKey && 86 === e.keyCode)
                        })), e.on("paste", (r => {
                            if (r.isDefaultPrevented() || (e => {
                                var t, n;
                                return Rt.os.isAndroid() && 0 === (null === (n = null === (t = e.clipboardData) || void 0 === t ? void 0 : t.items) || void 0 === n ? void 0 : n.length)
                            })(r)) return;
                            const a = "text" === n.get() || o;
                            o = !1;
                            const s = eL(r.clipboardData);
                            !nL(s) && aL(e, r, t.getLastRng() || e.selection.getRng()) || (tL(s, "text/html") ? (r.preventDefault(), sL(e, s, s["text/html"], a, !0)) : tL(s, "text/plain") && tL(s, "text/uri-list") ? (r.preventDefault(), sL(e, s, s["text/plain"], a, !0)) : (t.create(), Yg.setEditorTimeout(e, (() => {
                                const n = t.getHtml();
                                t.remove(), sL(e, s, n, a, !1)
                            }), 0)))
                        }))
                    }, lL = (e, t, n) => {
                        iL(e, t, n), (e => {
                            const t = e => $e(e, "webkit-fake-url"), n = e => $e(e, "data:");
                            e.parser.addNodeFilter("img", ((o, r, a) => {
                                if (!dc(e) && (e => {
                                    var t;
                                    return !0 === (null === (t = e.data) || void 0 === t ? void 0 : t.paste)
                                })(a)) for (const r of o) {
                                    const o = r.attr("src");
                                    g(o) && !r.attr("data-mce-object") && o !== Rt.transparentSrc && (t(o) || !yc(e) && n(o)) && r.remove()
                                }
                            }))
                        })(e)
                    }, dL = (e, t) => {
                        e.addCommand("mceTogglePlainTextPaste", (() => {
                            ((e, t) => {
                                "text" === t.get() ? (t.set("html"), Tf(e, !1)) : (t.set("text"), Tf(e, !0)), e.focus()
                            })(e, t)
                        })), e.addCommand("mceInsertClipboardContent", ((t, n) => {
                            n.html && QD(e, n.html, n.internal, !1), n.text && ZD(e, n.text, !1)
                        }))
                    }, cL = (e, t, n, o) => {
                        ((e, t, n) => {
                            if (!e) return !1;
                            try {
                                return e.clearData(), e.setData("text/html", t), e.setData("text/plain", n), e.setData(RD(), t), !0
                            } catch (e) {
                                return !1
                            }
                        })(e.clipboardData, t.html, t.text) ? (e.preventDefault(), o()) : n(t.html, o)
                    }, uL = e => (t, n) => {
                        const {dom: o, selection: r} = e,
                            a = o.create("div", {contenteditable: "false", "data-mce-bogus": "all"}),
                            s = o.create("div", {contenteditable: "true"}, t);
                        o.setStyles(a, {
                            position: "fixed",
                            top: "0",
                            left: "-3000px",
                            width: "1000px",
                            overflow: "hidden"
                        }), a.appendChild(s), o.add(e.getBody(), a);
                        const i = r.getRng();
                        s.focus();
                        const l = o.createRng();
                        l.selectNodeContents(s), r.setRng(l), Yg.setEditorTimeout(e, (() => {
                            r.setRng(i), o.remove(a), n()
                        }), 0)
                    }, mL = e => ({
                        html: LD(e.selection.getContent({contextual: !0})),
                        text: e.selection.getContent({format: "text"})
                    }),
                    fL = e => !e.selection.isCollapsed() || (e => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()))(e),
                    gL = e => {
                        e.on("cut", (e => t => {
                            !t.isDefaultPrevented() && fL(e) && e.selection.isEditable() && cL(t, mL(e), uL(e), (() => {
                                if (Rt.browser.isChromium() || Rt.browser.isFirefox()) {
                                    const t = e.selection.getRng();
                                    Yg.setEditorTimeout(e, (() => {
                                        e.selection.setRng(t), e.execCommand("Delete")
                                    }), 0)
                                } else e.execCommand("Delete")
                            }))
                        })(e)), e.on("copy", (e => t => {
                            !t.isDefaultPrevented() && fL(e) && cL(t, mL(e), uL(e), x)
                        })(e))
                    }, pL = (e, t) => {
                        var n, o;
                        return mg.getCaretRangeFromPoint(null !== (n = t.clientX) && void 0 !== n ? n : 0, null !== (o = t.clientY) && void 0 !== o ? o : 0, e.getDoc())
                    }, hL = (e, t) => {
                        e.focus(), t && e.selection.setRng(t)
                    }, vL = (e, t) => {
                        lc(e) && e.on("dragend dragover draggesture dragdrop drop drag", (e => {
                            e.preventDefault(), e.stopPropagation()
                        })), dc(e) || e.on("drop", (e => {
                            const t = e.dataTransfer;
                            t && (e => V(e.files, (e => /^image\//.test(e.type))))(t) && e.preventDefault()
                        })), e.on("drop", (n => {
                            if (n.isDefaultPrevented()) return;
                            const o = pL(e, n);
                            if (E(o)) return;
                            const r = eL(n.dataTransfer), a = tL(r, RD());
                            if ((!nL(r) || (e => {
                                const t = e["text/plain"];
                                return !!t && 0 === t.indexOf("file://")
                            })(r)) && aL(e, n, o)) return;
                            const s = r[RD()], i = s || r["text/html"] || r["text/plain"], l = ((e, t, n, o) => {
                                const r = e.getParent(n, (e => Pa(t, e)));
                                if (!b(e.getParent(n, "summary"))) return !0;
                                if (r && ke(o, "text/html")) {
                                    const e = (new DOMParser).parseFromString(o["text/html"], "text/html").body;
                                    return !b(e.querySelector(r.nodeName.toLowerCase()))
                                }
                                return !1
                            })(e.dom, e.schema, o.startContainer, r), d = t.get();
                            d && !l || i && (n.preventDefault(), Yg.setEditorTimeout(e, (() => {
                                e.undoManager.transact((() => {
                                    (s || d && l) && e.execCommand("Delete"), hL(e, o);
                                    const t = jD(i);
                                    r["text/html"] ? QD(e, t, a, !0) : ZD(e, t, !0)
                                }))
                            })))
                        })), e.on("dragstart", (e => {
                            t.set(!0)
                        })), e.on("dragover dragend", (n => {
                            dc(e) && !t.get() && (n.preventDefault(), hL(e, pL(e, n))), "dragend" === n.type && t.set(!1)
                        })), (e => {
                            e.on("input", (t => {
                                const n = e => b(e.querySelector("summary"));
                                if ("deleteByDrag" === t.inputType) {
                                    const t = X(e.dom.select("details"), n);
                                    K(t, (t => {
                                        ir(t.firstChild) && t.firstChild.remove();
                                        const n = e.dom.create("summary");
                                        n.appendChild(Lr().dom), t.prepend(n)
                                    }))
                                }
                            }))
                        })(e)
                    }, bL = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
                    yL = e => Bt.trim(e).replace(bL, Ts).toLowerCase(), CL = (e, t, n) => {
                        const o = fc(e);
                        if (n || "all" === o || !gc(e)) return t;
                        const r = o ? o.split(/[, ]/) : [];
                        if (r && "none" !== o) {
                            const n = e.dom, o = e.selection.getNode();
                            t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, ((e, t, a, s) => {
                                const i = n.parseStyle(n.decode(a)), l = {};
                                for (let e = 0; e < r.length; e++) {
                                    const t = i[r[e]];
                                    let a = t, s = n.getStyle(o, r[e], !0);
                                    /color/.test(r[e]) && (a = yL(a), s = yL(s)), s !== a && (l[r[e]] = t)
                                }
                                const d = n.serializeStyle(l, "span");
                                return d ? t + ' style="' + d + '"' + s : t + s
                            }))
                        } else t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
                        return t = t.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, ((e, t, n, o) => t + ' style="' + n + '"' + o)), t
                    }, EL = e => {
                        const t = Zs(!1), n = Zs(vc(e) ? "text" : "html"), o = UD(e);
                        (e => {
                            (Rt.browser.isChromium() || Rt.browser.isSafari()) && ((e, t) => {
                                e.on("PastePreProcess", (n => {
                                    n.content = t(e, n.content, n.internal)
                                }))
                            })(e, CL)
                        })(e), dL(e, n), (e => {
                            const t = t => n => {
                                t(e, n)
                            }, n = cc(e);
                            _(n) && e.on("PastePreProcess", t(n));
                            const o = uc(e);
                            _(o) && e.on("PastePostProcess", t(o))
                        })(e), e.on("PreInit", (() => {
                            gL(e), vL(e, t), lL(e, o, n)
                        }))
                    }, wL = e => {
                        (e => {
                            e.on("click", (t => {
                                e.dom.getParent(t.target, "details") && t.preventDefault()
                            }))
                        })(e), (e => {
                            e.parser.addNodeFilter("details", (t => {
                                const n = Dc(e);
                                K(t, (e => {
                                    "expanded" === n ? e.attr("open", "open") : "collapsed" === n && e.attr("open", null)
                                }))
                            })), e.serializer.addNodeFilter("details", (t => {
                                const n = Lc(e);
                                K(t, (e => {
                                    "expanded" === n ? e.attr("open", "open") : "collapsed" === n && e.attr("open", null)
                                }))
                            }))
                        })(e)
                    }, _L = ir, SL = tr, kL = e => cr(e.dom), xL = e => t => _n(yn.fromDom(e), t),
                    AL = (e, t, n) => Jn(yn.fromDom(e), (e => (e => dr(e.dom))(e) || n.isBlock($t(e))), xL(t)).getOr(yn.fromDom(t)).dom,
                    NL = (e, t) => Jn(yn.fromDom(e), kL, xL(t)), TL = (e, t, n) => {
                        const o = new Ho(e, t), r = n ? o.next.bind(o) : o.prev.bind(o);
                        let a = e;
                        for (let t = n ? e : r(); t && !_L(t); t = r()) oa(t) && (a = t);
                        return a
                    }, RL = e => {
                        const t = ((e, t, n) => {
                            const o = rl.fromRangeStart(e).getNode(), r = AL(o, t, n), a = TL(o, r, !1), s = TL(o, r, !0),
                                i = document.createRange();
                            return NL(a, r).fold((() => {
                                SL(a) ? i.setStart(a, 0) : i.setStartBefore(a)
                            }), (e => i.setStartBefore(e.dom))), NL(s, r).fold((() => {
                                SL(s) ? i.setEnd(s, s.data.length) : i.setEndAfter(s)
                            }), (e => i.setEndAfter(e.dom))), i
                        })(e.selection.getRng(), e.getBody(), e.schema);
                        e.selection.setRng(vb(t))
                    };
                var DL;
                !function (e) {
                    e.Before = "before", e.After = "after"
                }(DL || (DL = {}));
                const LL = (e, t) => Math.abs(e.left - t), OL = (e, t) => Math.abs(e.right - t), BL = (e, t) => {
                        const n = ((e, t) => Math.max(0, Math.min(e.bottom, t.bottom) - Math.max(e.top, t.top)))(e, t) / Math.min(e.height, t.height);
                        return ((e, t) => e.top < t.bottom && e.bottom > t.top)(e, t) && n > .5
                    }, PL = (e, t) => (e => Q(e, ((e, t) => e.fold((() => U.some(t)), (e => {
                        const n = Math.min(t.left, e.left), o = Math.min(t.top, e.top), r = Math.max(t.right, e.right),
                            a = Math.max(t.bottom, e.bottom);
                        return U.some({top: o, right: r, bottom: a, left: n, width: r - n, height: a - o})
                    }))), U.none()))(X(e, (e => {
                        return (n = t) >= (o = e).top && n <= o.bottom;
                        var n, o
                    }))).fold((() => [[], e]), (t => {
                        const {pass: n, fail: o} = G(e, (e => BL(e, t)));
                        return [n, o]
                    })),
                    IL = (e, t, n) => t > e.left && t < e.right ? 0 : Math.min(Math.abs(e.left - t), Math.abs(e.right - t)),
                    ML = (e, t, n, o) => {
                        const r = e => oa(e.node) ? U.some(e) : Vo(e.node) ? ML(me(e.node.childNodes), t, n, !1) : U.none(),
                            a = (e, a) => {
                                const s = le(e, ((e, o) => a(e, t, n) - a(o, t, n)));
                                return fe(s, r).map((e => o && !tr(e.node) && s.length > 1 ? ((e, o, a) => r(o).filter((o => Math.abs(a(e, t, n) - a(o, t, n)) < 2 && tr(o.node))))(e, s[1], a).getOr(e) : e))
                            }, [s, i] = PL(Nk(e), n), {pass: l, fail: d} = G(i, (e => e.top < n));
                        return a(s, IL).orThunk((() => a(d, Pi))).orThunk((() => a(l, Pi)))
                    }, FL = (e, t, n) => {
                        const o = yn.fromDom(e), r = xn(o), a = yn.fromPoint(r, t, n).filter((e => Sn(o, e))).getOr(o);
                        return ((e, t, n, o) => {
                            const r = (t, a) => {
                                const s = X(t.dom.childNodes, O((e => Vo(e) && e.classList.contains("mce-drag-container"))));
                                return a.fold((() => ML(s, n, o, !0)), (e => {
                                    const t = X(s, (t => t !== e.dom));
                                    return ML(t, n, o, !0)
                                })).orThunk((() => (_n(t, e) ? U.none() : Tn(t)).bind((e => r(e, U.some(t))))))
                            };
                            return r(t, U.none())
                        })(o, a, t, n)
                    }, UL = (e, t, n) => FL(e, t, n).filter((e => Qc(e.node))).map((e => ((e, t) => ({
                        node: e.node,
                        position: LL(e, t) < OL(e, t) ? DL.Before : DL.After
                    }))(e, t))), qL = e => {
                        var t, n;
                        const o = e.getBoundingClientRect(), r = e.ownerDocument, a = r.documentElement, s = r.defaultView;
                        return {
                            top: o.top + (null !== (t = null == s ? void 0 : s.scrollY) && void 0 !== t ? t : 0) - a.clientTop,
                            left: o.left + (null !== (n = null == s ? void 0 : s.scrollX) && void 0 !== n ? n : 0) - a.clientLeft
                        }
                    }, jL = (e, t) => {
                        return n = (e => e.inline ? qL(e.getBody()) : {left: 0, top: 0})(e), o = (e => {
                            const t = e.getBody();
                            return e.inline ? {left: t.scrollLeft, top: t.scrollTop} : {left: 0, top: 0}
                        })(e), r = ((e, t) => {
                            if (t.target.ownerDocument !== e.getDoc()) {
                                const n = qL(e.getContentAreaContainer()), o = (e => {
                                    const t = e.getBody(), n = e.getDoc().documentElement,
                                        o = {left: t.scrollLeft, top: t.scrollTop},
                                        r = {left: t.scrollLeft || n.scrollLeft, top: t.scrollTop || n.scrollTop};
                                    return e.inline ? o : r
                                })(e);
                                return {left: t.pageX - n.left + o.left, top: t.pageY - n.top + o.top}
                            }
                            return {left: t.pageX, top: t.pageY}
                        })(e, t), {pageX: r.left - n.left + o.left, pageY: r.top - n.top + o.top};
                        var n, o, r
                    }, HL = e => ({target: e, srcElement: e}), zL = (e, t, n, o) => {
                        const r = ((e, t) => {
                            const n = AD(e);
                            return "dragstart" === t ? (cD(n), bD(n)) : "drop" === t ? (uD(n), yD(n)) : (mD(n), CD(n)), n
                        })(n, e);
                        return C(o) ? ((e, t, n) => {
                            const o = B("Function not supported on simulated event.");
                            return {
                                bubbles: !0,
                                cancelBubble: !1,
                                cancelable: !0,
                                composed: !1,
                                currentTarget: null,
                                defaultPrevented: !1,
                                eventPhase: 0,
                                isTrusted: !0,
                                returnValue: !1,
                                timeStamp: 0,
                                type: e,
                                composedPath: o,
                                initEvent: o,
                                preventDefault: x,
                                stopImmediatePropagation: x,
                                stopPropagation: x,
                                AT_TARGET: window.Event.AT_TARGET,
                                BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
                                CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
                                NONE: window.Event.NONE,
                                altKey: !1,
                                button: 0,
                                buttons: 0,
                                clientX: 0,
                                clientY: 0,
                                ctrlKey: !1,
                                metaKey: !1,
                                movementX: 0,
                                movementY: 0,
                                offsetX: 0,
                                offsetY: 0,
                                pageX: 0,
                                pageY: 0,
                                relatedTarget: null,
                                screenX: 0,
                                screenY: 0,
                                shiftKey: !1,
                                x: 0,
                                y: 0,
                                detail: 0,
                                view: null,
                                which: 0,
                                initUIEvent: o,
                                initMouseEvent: o,
                                getModifierState: o,
                                dataTransfer: n, ...HL(t)
                            }
                        })(e, t, r) : ((e, t, n, o) => ({...t, dataTransfer: o, type: e, ...HL(n)}))(e, o, t, r)
                    }, $L = cr, VL = ((...e) => t => {
                        for (let n = 0; n < e.length; n++) if (e[n](t)) return !0;
                        return !1
                    })($L, dr), WL = (e, t, n, o) => {
                        const r = e.dom, a = t.cloneNode(!0);
                        r.setStyles(a, {width: n, height: o}), r.setAttrib(a, "data-mce-selected", null);
                        const s = r.create("div", {
                            class: "mce-drag-container",
                            "data-mce-bogus": "all",
                            unselectable: "on",
                            contenteditable: "false"
                        });
                        return r.setStyles(s, {
                            position: "absolute",
                            opacity: .5,
                            overflow: "hidden",
                            border: 0,
                            padding: 0,
                            margin: 0,
                            width: n,
                            height: o
                        }), r.setStyles(a, {margin: 0, boxSizing: "border-box"}), s.appendChild(a), s
                    }, KL = (e, t) => n => () => {
                        const o = "left" === e ? n.scrollX : n.scrollY;
                        n.scroll({[e]: o + t, behavior: "smooth"})
                    }, YL = KL("left", -32), GL = KL("left", 32), XL = KL("top", -32), JL = KL("top", 32), QL = e => {
                        e && e.parentNode && e.parentNode.removeChild(e)
                    }, ZL = (e, t) => n => {
                        if ((e => 0 === e.button)(n)) {
                            const o = ee(t.dom.getParents(n.target), VL).getOr(null);
                            if (w(o) && ((e, t, n) => $L(n) && n !== t && e.isEditable(n.parentElement))(t.dom, t.getBody(), o)) {
                                const r = t.dom.getPos(o), a = t.getBody(), s = t.getDoc().documentElement;
                                e.set({
                                    element: o,
                                    dataTransfer: xD(),
                                    dragging: !1,
                                    screenX: n.screenX,
                                    screenY: n.screenY,
                                    maxX: (t.inline ? a.scrollWidth : s.offsetWidth) - 2,
                                    maxY: (t.inline ? a.scrollHeight : s.offsetHeight) - 2,
                                    relX: n.pageX - r.x,
                                    relY: n.pageY - r.y,
                                    width: o.offsetWidth,
                                    height: o.offsetHeight,
                                    ghost: WL(t, o, o.offsetWidth, o.offsetHeight),
                                    intervalId: ai(100)
                                })
                            }
                        }
                    }, eO = (e, t, n, o, r) => {
                        "dragstart" === t && ND(o, e.dom.getOuterHTML(n));
                        const a = zL(t, n, o, r);
                        return e.dispatch(t, a)
                    }, tO = (e, t) => {
                        const n = ii(((e, n) => ((e, t, n) => {
                            e._selectionOverrides.hideFakeCaret(), UL(e.getBody(), t, n).fold((() => e.selection.placeCaretAt(t, n)), (o => {
                                const r = e._selectionOverrides.showCaret(1, o.node, o.position === DL.Before, !1);
                                r ? e.selection.setRng(r) : e.selection.placeCaretAt(t, n)
                            }))
                        })(t, e, n)), 0);
                        t.on("remove", n.cancel);
                        const o = e;
                        return r => e.on((e => {
                            const a = Math.max(Math.abs(r.screenX - e.screenX), Math.abs(r.screenY - e.screenY));
                            if (!e.dragging && a > 10) {
                                const n = eO(t, "dragstart", e.element, e.dataTransfer, r);
                                if (w(n.dataTransfer) && (e.dataTransfer = n.dataTransfer), n.isDefaultPrevented()) return;
                                e.dragging = !0, t.focus()
                            }
                            if (e.dragging) {
                                const a = r.currentTarget === t.getDoc().documentElement,
                                    l = ((e, t) => ({pageX: t.pageX - e.relX, pageY: t.pageY + 5}))(e, jL(t, r));
                                s = e.ghost, i = t.getBody(), s.parentNode !== i && i.appendChild(s), ((e, t, n, o, r, a, s, i, l, d, c, u) => {
                                    let m = 0, f = 0;
                                    e.style.left = t.pageX + "px", e.style.top = t.pageY + "px", t.pageX + n > r && (m = t.pageX + n - r), t.pageY + o > a && (f = t.pageY + o - a), e.style.width = n - m + "px", e.style.height = o - f + "px";
                                    const g = l.clientHeight, p = l.clientWidth, h = s + l.getBoundingClientRect().top,
                                        v = i + l.getBoundingClientRect().left;
                                    c.on((e => {
                                        e.intervalId.clear(), e.dragging && u && (s + 8 >= g ? e.intervalId.set(JL(d)) : s - 8 <= 0 ? e.intervalId.set(XL(d)) : i + 8 >= p ? e.intervalId.set(GL(d)) : i - 8 <= 0 ? e.intervalId.set(YL(d)) : h + 16 >= window.innerHeight ? e.intervalId.set(JL(window)) : h - 16 <= 0 ? e.intervalId.set(XL(window)) : v + 16 >= window.innerWidth ? e.intervalId.set(GL(window)) : v - 16 <= 0 && e.intervalId.set(YL(window)))
                                    }))
                                })(e.ghost, l, e.width, e.height, e.maxX, e.maxY, r.clientY, r.clientX, t.getContentAreaContainer(), t.getWin(), o, a), n.throttle(r.clientX, r.clientY)
                            }
                            var s, i
                        }))
                    }, nO = (e, t) => n => {
                        e.on((e => {
                            var o;
                            if (e.intervalId.clear(), e.dragging) {
                                if (((e, t, n) => !E(t) && t !== n && !e.dom.isChildOf(t, n) && e.dom.isEditable(t))(t, (e => {
                                    const t = e.getSel();
                                    if (w(t)) {
                                        const e = t.getRangeAt(0).startContainer;
                                        return tr(e) ? e.parentNode : e
                                    }
                                    return null
                                })(t.selection), e.element)) {
                                    const r = null !== (o = t.getDoc().elementFromPoint(n.clientX, n.clientY)) && void 0 !== o ? o : t.getBody();
                                    eO(t, "drop", r, e.dataTransfer, n).isDefaultPrevented() || t.undoManager.transact((() => {
                                        ((e, t) => {
                                            const n = e.getParent(t.parentNode, e.isBlock);
                                            QL(t), n && n !== e.getRoot() && e.isEmpty(n) && Or(yn.fromDom(n))
                                        })(t.dom, e.element), (e => {
                                            const t = e.getData("text/html");
                                            return "" === t ? U.none() : U.some(t)
                                        })(e.dataTransfer).each((e => t.insertContent(e))), t._selectionOverrides.hideFakeCaret()
                                    }))
                                }
                                eO(t, "dragend", t.getBody(), e.dataTransfer, n)
                            }
                        })), rO(e)
                    }, oO = (e, t, n) => {
                        e.on((e => {
                            e.intervalId.clear(), e.dragging && n.fold((() => eO(t, "dragend", e.element, e.dataTransfer)), (n => eO(t, "dragend", e.element, e.dataTransfer, n)))
                        })), rO(e)
                    }, rO = e => {
                        e.on((e => {
                            e.intervalId.clear(), QL(e.ghost)
                        })), e.clear()
                    }, aO = e => {
                        const t = si(), n = Xs.DOM, o = document, r = ZL(t, e), a = tO(t, e), s = nO(t, e),
                            i = ((e, t) => n => oO(e, t, U.some(n)))(t, e);
                        e.on("mousedown", r), e.on("mousemove", a), e.on("mouseup", s), n.bind(o, "mousemove", a), n.bind(o, "mouseup", i), e.on("remove", (() => {
                            n.unbind(o, "mousemove", a), n.unbind(o, "mouseup", i)
                        })), e.on("keydown", (n => {
                            n.keyCode === Rf.ESC && oO(t, e, U.none())
                        }))
                    }, sO = e => {
                        aO(e), Jd(e) && (e => {
                            const t = t => {
                                if (!t.isDefaultPrevented()) {
                                    const n = t.dataTransfer;
                                    n && ($(n.types, "Files") || n.files.length > 0) && (t.preventDefault(), "drop" === t.type && f_(e, "Dropped file type is not supported"))
                                }
                            }, n = n => {
                                Zg(e, n.target) && t(n)
                            }, o = () => {
                                const o = Xs.DOM, r = e.dom, a = document, s = e.inline ? e.getBody() : e.getDoc(),
                                    i = ["drop", "dragover"];
                                K(i, (e => {
                                    o.bind(a, e, n), r.bind(s, e, t)
                                })), e.on("remove", (() => {
                                    K(i, (e => {
                                        o.unbind(a, e, n), r.unbind(s, e, t)
                                    }))
                                }))
                            };
                            e.on("init", (() => {
                                Yg.setEditorTimeout(e, o, 0)
                            }))
                        })(e)
                    }, iO = cr, lO = (e, t) => tb(e.getBody(), t), dO = e => {
                        const t = e.selection, n = e.dom, o = e.getBody(), r = Gc(e, o, n.isBlock, (() => ip(e))),
                            a = "sel-" + n.uniqueId(), s = "data-mce-selected";
                        let i;
                        const l = e => e !== o && (iO(e) || fr(e)) && n.isChildOf(e, o) && n.isEditable(e.parentNode),
                            d = (n, o, a, s = !0) => e.dispatch("ShowCaret", {
                                target: o,
                                direction: n,
                                before: a
                            }).isDefaultPrevented() ? null : (s && t.scrollIntoView(o, -1 === n), r.show(a, o)), c = () => {
                                e.on("click", (t => {
                                    n.isEditable(t.target) || (t.preventDefault(), e.focus())
                                })), e.on("blur NewBlock", h), e.on("ResizeWindow FullscreenStateChanged", r.reposition), e.on("tap", (t => {
                                    const n = t.target, o = lO(e, n);
                                    iO(o) ? (t.preventDefault(), mS(e, o).each(p)) : l(n) && mS(e, n).each(p)
                                }), !0), e.on("mousedown", (r => {
                                    const a = r.target;
                                    if (a !== o && "HTML" !== a.nodeName && !n.isChildOf(a, o)) return;
                                    if (!s_(e, r.clientX, r.clientY)) return;
                                    h(), v();
                                    const s = lO(e, a);
                                    iO(s) ? (r.preventDefault(), mS(e, s).each(p)) : UL(o, r.clientX, r.clientY).each((n => {
                                        r.preventDefault();
                                        (e => {
                                            e && t.setRng(e)
                                        })(d(1, n.node, n.position === DL.Before, !1)), Wo(s) ? s.focus() : e.getBody().focus()
                                    }))
                                })), e.on("keypress", (e => {
                                    Rf.modifierPressed(e) || iO(t.getNode()) && e.preventDefault()
                                })), e.on("GetSelectionRange", (e => {
                                    let t = e.range;
                                    if (i) {
                                        if (!i.parentNode) return void (i = null);
                                        t = t.cloneRange(), t.selectNode(i), e.range = t
                                    }
                                })), e.on("SetSelectionRange", (e => {
                                    e.range = f(e.range);
                                    const t = p(e.range, e.forward);
                                    t && (e.range = t)
                                }));
                                e.on("AfterSetSelectionRange", (e => {
                                    const t = e.range, o = t.startContainer.parentElement;
                                    var r;
                                    m(t) || Vo(r = o) && "mcepastebin" === r.id || v(), (e => w(e) && n.hasClass(e, "mce-offscreen-selection"))(o) || h()
                                })), sO(e), (e => {
                                    const t = ii((() => {
                                        if (!e.removed && e.getBody().contains(document.activeElement)) {
                                            const t = e.selection.getRng();
                                            if (t.collapsed) {
                                                const n = fS(e, t, !1);
                                                e.selection.setRng(n)
                                            }
                                        }
                                    }), 0);
                                    e.on("focus", (() => {
                                        t.throttle()
                                    })), e.on("blur", (() => {
                                        t.cancel()
                                    }))
                                })(e), (e => {
                                    e.on("init", (() => {
                                        e.on("focusin", (t => {
                                            const n = t.target;
                                            if (fr(n)) {
                                                const t = tb(e.getBody(), n), o = cr(t) ? t : n;
                                                e.selection.getNode() !== o && mS(e, o).each((t => e.selection.setRng(t)))
                                            }
                                        }))
                                    }))
                                })(e)
                            }, u = e => jr(e) || Vr(e) || Wr(e), m = e => u(e.startContainer) || u(e.endContainer), f = t => {
                                const o = e.schema.getVoidElements(), r = n.createRng(), a = t.startContainer,
                                    s = t.startOffset, i = t.endContainer, l = t.endOffset;
                                return ke(o, a.nodeName.toLowerCase()) ? 0 === s ? r.setStartBefore(a) : r.setStartAfter(a) : r.setStart(a, s), ke(o, i.nodeName.toLowerCase()) ? 0 === l ? r.setEndBefore(i) : r.setEndAfter(i) : r.setEnd(i, l), r
                            }, g = o => {
                                const r = o.cloneNode(!0), l = e.dispatch("ObjectSelected", {target: o, targetClone: r});
                                if (l.isDefaultPrevented()) return null;
                                const d = ((o, r) => {
                                    const s = yn.fromDom(e.getBody()), i = e.getDoc(), l = to(s, "#" + a).getOrThunk((() => {
                                        const e = yn.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', i);
                                        return en(e, "id", a), bo(s, e), e
                                    })), d = n.createRng();
                                    Eo(l), Co(l, [yn.fromText(br, i), yn.fromDom(r), yn.fromText(br, i)]), d.setStart(l.dom.firstChild, 1), d.setEnd(l.dom.lastChild, 0), lo(l, {top: n.getPos(o, e.getBody()).y + "px"}), Pg(l);
                                    const c = t.getSel();
                                    return c && (c.removeAllRanges(), c.addRange(d)), d
                                })(o, l.targetClone), c = yn.fromDom(o);
                                return K(qo(yn.fromDom(e.getBody()), `*[${s}]`), (e => {
                                    _n(c, e) || an(e, s)
                                })), n.getAttrib(o, s) || o.setAttribute(s, "1"), i = o, v(), d
                            }, p = (e, t) => {
                                if (!e) return null;
                                if (e.collapsed) {
                                    if (!m(e)) {
                                        const r = t ? 1 : -1, a = wu(r, o, e), s = a.getNode(!t);
                                        if (w(s)) {
                                            if (Qc(s)) return d(r, s, !!t && !a.isAtEnd(), !1);
                                            if (qr(s) && cr(s.nextSibling)) {
                                                const e = n.createRng();
                                                return e.setStart(s, 0), e.setEnd(s, 0), e
                                            }
                                        }
                                        const i = a.getNode(t);
                                        if (w(i)) {
                                            if (Qc(i)) return d(r, i, !t && !a.isAtEnd(), !1);
                                            if (qr(i) && cr(i.previousSibling)) {
                                                const e = n.createRng();
                                                return e.setStart(i, 1), e.setEnd(i, 1), e
                                            }
                                        }
                                    }
                                    return null
                                }
                                let r = e.startContainer, a = e.startOffset;
                                const s = e.endOffset;
                                if (tr(r) && 0 === a && iO(r.parentNode) && (r = r.parentNode, a = n.nodeIndex(r), r = r.parentNode), !Vo(r)) return null;
                                if (s === a + 1 && r === e.endContainer) {
                                    const e = r.childNodes[a];
                                    if (l(e)) return g(e)
                                }
                                return null
                            }, h = () => {
                                i && i.removeAttribute(s), to(yn.fromDom(e.getBody()), "#" + a).each(wo), i = null
                            }, v = () => {
                                r.hide()
                            };
                        return hw(e) || c(), {
                            showCaret: d, showBlockCaretContainer: e => {
                                e.hasAttribute("data-mce-caret") && (Kr(e), t.scrollIntoView(e))
                            }, hideFakeCaret: v, destroy: () => {
                                r.destroy(), i = null
                            }
                        }
                    }, cO = (e, t) => {
                        let n = t;
                        for (let t = e.previousSibling; tr(t); t = t.previousSibling) n += t.data.length;
                        return n
                    }, uO = (e, t, n, o, r) => {
                        if (tr(n) && (o < 0 || o > n.data.length)) return [];
                        const a = r && tr(n) ? [cO(n, o)] : [o];
                        let s = n;
                        for (; s !== t && s.parentNode;) a.push(e.nodeIndex(s, r)), s = s.parentNode;
                        return s === t ? a.reverse() : []
                    }, mO = (e, t, n, o, r, a, s = !1) => ({start: uO(e, t, n, o, s), end: uO(e, t, r, a, s)}),
                    fO = (e, t) => {
                        const n = t.slice(), o = n.pop();
                        if (S(o)) {
                            return Q(n, ((e, t) => e.bind((e => U.from(e.childNodes[t])))), U.some(e)).bind((e => tr(e) && (o < 0 || o > e.data.length) ? U.none() : U.some({
                                node: e,
                                offset: o
                            })))
                        }
                        return U.none()
                    }, gO = (e, t) => fO(e, t.start).bind((({node: n, offset: o}) => fO(e, t.end).map((({
                                                                                                            node: e,
                                                                                                            offset: t
                                                                                                        }) => {
                        const r = document.createRange();
                        return r.setStart(n, o), r.setEnd(e, t), r
                    })))), pO = (e, t, n) => {
                        if (t && e.isEmpty(t) && !n(t)) {
                            const o = t.parentNode;
                            e.remove(t, tr(t.firstChild) && ia(t.firstChild.data)), pO(e, o, n)
                        }
                    }, hO = (e, t, n, o = !0) => {
                        const r = t.startContainer.parentNode, a = t.endContainer.parentNode;
                        t.deleteContents(), o && !n(t.startContainer) && (tr(t.startContainer) && 0 === t.startContainer.data.length && e.remove(t.startContainer), tr(t.endContainer) && 0 === t.endContainer.data.length && e.remove(t.endContainer), pO(e, r, n), r !== a && pO(e, a, n))
                    }, vO = (e, t) => U.from(e.dom.getParent(t.startContainer, e.dom.isBlock)), bO = (e, t, n) => {
                        const o = e.dynamicPatternsLookup({text: n, block: t});
                        return {
                            ...e,
                            blockPatterns: Bl(o).concat(e.blockPatterns),
                            inlinePatterns: Pl(o).concat(e.inlinePatterns)
                        }
                    }, yO = (e, t, n, o) => {
                        const r = e.createRng();
                        return r.setStart(t, 0), r.setEnd(n, o), r.toString()
                    }, CO = (e, t, n) => {
                        const o = ((e, t, n) => {
                            if (tr(e) && t >= e.length) return U.some(HA(e, t));
                            {
                                const o = Ni(zA);
                                return U.from(o.forwards(e, t, $A(e), n)).map((e => HA(e.container, 0)))
                            }
                        })(t, 0, t);
                        o.each((o => {
                            const r = o.container;
                            KA(r, n.start.length, t).each((n => {
                                const o = e.createRng();
                                o.setStart(r, 0), o.setEnd(n.container, n.offset), hO(e, o, (e => e === t))
                            }));
                            const a = yn.fromDom(r), s = Er(a);
                            /^\s[^\s]/.test(s) && ((e, t) => {
                                Cr.set(e, t)
                            })(a, s.slice(1))
                        }))
                    }, EO = (e, t) => {
                        const n = e.dom, o = t.pattern,
                            r = gO(n.getRoot(), t.range).getOrDie("Unable to resolve path range");
                        return vO(e, r).each((t => {
                            "block-format" === o.type ? ((e, t) => {
                                const n = t.get(e);
                                return v(n) && ce(n).exists((e => ke(e, "block")))
                            })(o.format, e.formatter) && e.undoManager.transact((() => {
                                CO(e.dom, t, o), e.formatter.apply(o.format)
                            })) : "block-command" === o.type && e.undoManager.transact((() => {
                                CO(e.dom, t, o), e.execCommand(o.cmd, !1, o.value)
                            }))
                        })), !0
                    }, wO = (e, t) => {
                        const n = (e => le(e, ((e, t) => t.start.length - e.start.length)))(e), o = t.replace(br, " ");
                        return ee(n, (e => 0 === t.indexOf(e.start) || 0 === o.indexOf(e.start)))
                    }, _O = (e, t) => e.create("span", {"data-mce-type": "bookmark", id: t}), SO = (e, t) => {
                        const n = e.createRng();
                        return n.setStartAfter(t.start), n.setEndBefore(t.end), n
                    }, kO = (e, t, n) => {
                        const o = gO(e.getRoot(), n).getOrDie("Unable to resolve path range"), r = o.startContainer,
                            a = o.endContainer, s = 0 === o.endOffset ? a : a.splitText(o.endOffset),
                            i = 0 === o.startOffset ? r : r.splitText(o.startOffset), l = i.parentNode;
                        return {
                            prefix: t,
                            end: s.parentNode.insertBefore(_O(e, t + "-end"), s),
                            start: l.insertBefore(_O(e, t + "-start"), i)
                        }
                    }, xO = (e, t, n) => {
                        pO(e, e.get(t.prefix + "-end"), n), pO(e, e.get(t.prefix + "-start"), n)
                    }, AO = e => 0 === e.start.length, NO = (e, t, n, o) => {
                        const r = t.start;
                        var a;
                        return YA(e, o.container, o.offset, (a = r, (e, t) => {
                            const n = e.data.substring(0, t), o = n.lastIndexOf(a.charAt(a.length - 1)),
                                r = n.lastIndexOf(a);
                            return -1 !== r ? r + a.length : -1 !== o ? o + 1 : -1
                        }), n).bind((o => {
                            var a, s;
                            const i = null !== (s = null === (a = n.textContent) || void 0 === a ? void 0 : a.indexOf(r)) && void 0 !== s ? s : -1;
                            if (-1 !== i && o.offset >= i + r.length) {
                                const t = e.createRng();
                                return t.setStart(o.container, o.offset - r.length), t.setEnd(o.container, o.offset), U.some(t)
                            }
                            {
                                const a = o.offset - r.length;
                                return WA(o.container, a, n).map((t => {
                                    const n = e.createRng();
                                    return n.setStart(t.container, t.offset), n.setEnd(o.container, o.offset), n
                                })).filter((e => e.toString() === r)).orThunk((() => NO(e, t, n, HA(o.container, 0))))
                            }
                        }))
                    }, TO = (e, t, n, o) => {
                        const r = e.dom, a = r.getRoot(), s = n.pattern, i = n.position.container, l = n.position.offset;
                        return WA(i, l - n.pattern.end.length, t).bind((d => {
                            const c = mO(r, a, d.container, d.offset, i, l, o);
                            if (AO(s)) return U.some({matches: [{pattern: s, startRng: c, endRng: c}], position: d});
                            {
                                const i = RO(e, n.remainingPatterns, d.container, d.offset, t, o),
                                    l = i.getOr({matches: [], position: d}), u = l.position,
                                    m = ((e, t, n, o, r, a = !1) => {
                                        if (0 === t.start.length && !a) {
                                            const t = e.createRng();
                                            return t.setStart(n, o), t.setEnd(n, o), U.some(t)
                                        }
                                        return VA(n, o, r).bind((n => NO(e, t, r, n).bind((e => {
                                            var t;
                                            if (a) {
                                                if (e.endContainer === n.container && e.endOffset === n.offset) return U.none();
                                                if (0 === n.offset && (null === (t = e.endContainer.textContent) || void 0 === t ? void 0 : t.length) === e.endOffset) return U.none()
                                            }
                                            return U.some(e)
                                        }))))
                                    })(r, s, u.container, u.offset, t, i.isNone());
                                return m.map((e => {
                                    const t = ((e, t, n, o = !1) => mO(e, t, n.startContainer, n.startOffset, n.endContainer, n.endOffset, o))(r, a, e, o);
                                    return {
                                        matches: l.matches.concat([{pattern: s, startRng: t, endRng: c}]),
                                        position: HA(e.startContainer, e.startOffset)
                                    }
                                }))
                            }
                        }))
                    }, RO = (e, t, n, o, r, a) => {
                        const s = e.dom;
                        return VA(n, o, s.getRoot()).bind((i => {
                            const l = yO(s, r, n, o);
                            for (let s = 0; s < t.length; s++) {
                                const d = t[s];
                                if (!Ve(l, d.end)) continue;
                                const c = t.slice();
                                c.splice(s, 1);
                                const u = TO(e, r, {pattern: d, remainingPatterns: c, position: i}, a);
                                if (u.isNone() && o > 0) return RO(e, t, n, o - 1, r, a);
                                if (u.isSome()) return u
                            }
                            return U.none()
                        }))
                    }, DO = (e, t, n) => {
                        e.selection.setRng(n), "inline-format" === t.type ? K(t.format, (t => {
                            e.formatter.apply(t)
                        })) : e.execCommand(t.cmd, !1, t.value)
                    }, LO = (e, t, n, o, r, a) => {
                        var s;
                        return ((e, t) => {
                            const n = re(e, (e => V(t, (t => e.pattern.start === t.pattern.start && e.pattern.end === t.pattern.end))));
                            return e.length === t.length ? n ? e : t : e.length > t.length ? e : t
                        })(RO(e, r.inlinePatterns, n, o, t, a).fold((() => []), (e => e.matches)), RO(e, (s = r.inlinePatterns, le(s, ((e, t) => t.end.length - e.end.length))), n, o, t, a).fold((() => []), (e => e.matches)))
                    }, OO = (e, t) => {
                        if (0 === t.length) return;
                        const n = e.dom, o = e.selection.getBookmark(), r = ((e, t) => {
                            const n = wi("mce_textpattern"), o = J(t, ((t, o) => {
                                const r = kO(e, n + `_end${t.length}`, o.endRng);
                                return t.concat([{...o, endMarker: r}])
                            }), []);
                            return J(o, ((t, r) => {
                                const a = o.length - t.length - 1,
                                    s = AO(r.pattern) ? r.endMarker : kO(e, n + `_start${a}`, r.startRng);
                                return t.concat([{...r, startMarker: s}])
                            }), [])
                        })(n, t);
                        K(r, (t => {
                            const o = n.getParent(t.startMarker.start, n.isBlock), r = e => e === o;
                            AO(t.pattern) ? ((e, t, n, o) => {
                                const r = SO(e.dom, n);
                                hO(e.dom, r, o), DO(e, t, r)
                            })(e, t.pattern, t.endMarker, r) : ((e, t, n, o, r) => {
                                const a = e.dom, s = SO(a, o), i = SO(a, n);
                                hO(a, i, r), hO(a, s, r);
                                const l = {prefix: n.prefix, start: n.end, end: o.start}, d = SO(a, l);
                                DO(e, t, d)
                            })(e, t.pattern, t.startMarker, t.endMarker, r), xO(n, t.endMarker, r), xO(n, t.startMarker, r)
                        })), e.selection.moveToBookmark(o)
                    }, BO = (e, t) => {
                        const n = e.selection.getRng();
                        return vO(e, n).map((o => {
                            var r;
                            const a = Math.max(0, n.startOffset),
                                s = bO(t, o, null !== (r = o.textContent) && void 0 !== r ? r : ""),
                                i = LO(e, o, n.startContainer, a, s, !0), l = ((e, t, n, o) => {
                                    var r;
                                    const a = e.dom, s = Jl(e);
                                    if (!a.is(t, s)) return [];
                                    const i = null !== (r = t.textContent) && void 0 !== r ? r : "";
                                    return wO(n.blockPatterns, i).map((e => Bt.trim(i).length === e.start.length ? [] : [{
                                        pattern: e,
                                        range: mO(a, a.getRoot(), t, 0, t, 0, o)
                                    }])).getOr([])
                                })(e, o, s, !0);
                            return (l.length > 0 || i.length > 0) && (e.undoManager.add(), e.undoManager.extra((() => {
                                e.execCommand("mceInsertNewLine")
                            }), (() => {
                                (e => {
                                    e.insertContent(Br, {preserve_zwsp: !0})
                                })(e), OO(e, i), ((e, t) => {
                                    if (0 === t.length) return;
                                    const n = e.selection.getBookmark();
                                    K(t, (t => EO(e, t))), e.selection.moveToBookmark(n)
                                })(e, l);
                                const t = e.selection.getRng(), n = VA(t.startContainer, t.startOffset, e.dom.getRoot());
                                e.execCommand("mceInsertNewLine"), n.each((t => {
                                    const n = t.container;
                                    n.data.charAt(t.offset - 1) === vr && (n.deleteData(t.offset - 1, 1), pO(e.dom, n.parentNode, (t => t === e.dom.getRoot())))
                                }))
                            })), !0)
                        })).getOr(!1)
                    }, PO = (e, t, n) => {
                        for (let o = 0; o < e.length; o++) if (n(e[o], t)) return !0;
                        return !1
                    }, IO = e => {
                        const t = [",", ".", ";", ":", "!", "?"], n = [32], o = () => {
                            return t = Cc(e), n = Ec(e), {
                                inlinePatterns: Pl(t),
                                blockPatterns: Bl(t),
                                dynamicPatternsLookup: n
                            };
                            var t, n
                        }, r = () => (e => e.options.isSet("text_patterns_lookup"))(e);
                        e.on("keydown", (t => {
                            if (13 === t.keyCode && !Rf.modifierPressed(t) && e.selection.isCollapsed()) {
                                const n = o();
                                (n.inlinePatterns.length > 0 || n.blockPatterns.length > 0 || r()) && BO(e, n) && t.preventDefault()
                            }
                        }), !0);
                        const a = () => {
                            if (e.selection.isCollapsed()) {
                                const t = o();
                                (t.inlinePatterns.length > 0 || r()) && ((e, t) => {
                                    const n = e.selection.getRng();
                                    vO(e, n).map((o => {
                                        const r = Math.max(0, n.startOffset - 1), a = yO(e.dom, o, n.startContainer, r),
                                            s = bO(t, o, a), i = LO(e, o, n.startContainer, r, s, !1);
                                        i.length > 0 && e.undoManager.transact((() => {
                                            OO(e, i)
                                        }))
                                    }))
                                })(e, t)
                            }
                        };
                        e.on("keyup", (e => {
                            ((e, t) => PO(e, t, ((e, t) => e === t.keyCode && !Rf.modifierPressed(t))))(n, e) && a()
                        })), e.on("keypress", (n => {
                            ((e, t) => PO(e, t, ((e, t) => e.charCodeAt(0) === t.charCode)))(t, n) && Yg.setEditorTimeout(e, a)
                        }))
                    }, MO = e => {
                        const t = Bt.each, n = Rf.BACKSPACE, o = Rf.DELETE, r = e.dom, a = e.selection, s = e.parser,
                            i = Rt.browser, l = i.isFirefox(), d = i.isChromium() || i.isSafari(),
                            c = Rt.deviceType.isiPhone() || Rt.deviceType.isiPad(), u = Rt.os.isMacOS() || Rt.os.isiOS(),
                            m = (t, n) => {
                                try {
                                    e.getDoc().execCommand(t, !1, String(n))
                                } catch (e) {
                                }
                            }, f = e => e.isDefaultPrevented(), p = () => {
                                const t = e => {
                                    const t = r.create("body"), n = e.cloneContents();
                                    return t.appendChild(n), a.serializer.serialize(t, {format: "html"})
                                };
                                e.on("keydown", (a => {
                                    const s = a.keyCode;
                                    if (!f(a) && (s === o || s === n) && e.selection.isEditable()) {
                                        const n = e.selection.isCollapsed(), o = e.getBody();
                                        if (n && !ya(yn.fromDom(o))) return;
                                        if (!n && !(n => {
                                            const o = t(n), a = r.createRng();
                                            return a.selectNode(e.getBody()), o === t(a)
                                        })(e.selection.getRng())) return;
                                        a.preventDefault(), e.setContent(""), o.firstChild && r.isBlock(o.firstChild) ? e.selection.setCursorLocation(o.firstChild, 0) : e.selection.setCursorLocation(o, 0), e.nodeChanged()
                                    }
                                }))
                            }, h = () => {
                                e.shortcuts.add("meta+a", null, "SelectAll")
                            }, v = () => {
                                e.inline || r.bind(e.getDoc(), "mousedown mouseup", (t => {
                                    let n;
                                    if (t.target === e.getDoc().documentElement) if (n = a.getRng(), e.getBody().focus(), "mousedown" === t.type) {
                                        if (jr(n.startContainer)) return;
                                        a.placeCaretAt(t.clientX, t.clientY)
                                    } else a.setRng(n)
                                }))
                            }, b = () => {
                                Range.prototype.getClientRects || e.on("mousedown", (t => {
                                    if (!f(t) && "HTML" === t.target.nodeName) {
                                        const t = e.getBody();
                                        t.blur(), Yg.setEditorTimeout(e, (() => {
                                            t.focus()
                                        }))
                                    }
                                }))
                            }, y = () => {
                                const t = ec(e);
                                e.on("click", (n => {
                                    const o = n.target;
                                    /^(IMG|HR)$/.test(o.nodeName) && r.isEditable(o) && (n.preventDefault(), e.selection.select(o), e.nodeChanged()), "A" === o.nodeName && r.hasClass(o, t) && 0 === o.childNodes.length && r.isEditable(o.parentNode) && (n.preventDefault(), a.select(o))
                                }))
                            }, C = () => {
                                e.on("keydown", (e => {
                                    if (!f(e) && e.keyCode === n && a.isCollapsed() && 0 === a.getRng().startOffset) {
                                        const t = a.getNode().previousSibling;
                                        if (t && t.nodeName && "table" === t.nodeName.toLowerCase()) return e.preventDefault(), !1
                                    }
                                    return !0
                                }))
                            }, E = () => {
                                const t = () => {
                                    m("StyleWithCSS", !1), m("enableInlineTableEditing", !1), Sd(e) || m("enableObjectResizing", !1)
                                };
                                Wd(e) || e.on("BeforeExecCommand mousedown", t)
                            }, w = () => {
                                e.on("SetContent ExecCommand", (e => {
                                    "setcontent" !== e.type && "mceInsertLink" !== e.command || t(r.select("a:not([data-mce-block])"), (e => {
                                        var t;
                                        let n = e.parentNode;
                                        const o = r.getRoot();
                                        if ((null == n ? void 0 : n.lastChild) === e) {
                                            for (; n && !r.isBlock(n);) {
                                                if ((null === (t = n.parentNode) || void 0 === t ? void 0 : t.lastChild) !== n || n === o) return;
                                                n = n.parentNode
                                            }
                                            r.add(n, "br", {"data-mce-bogus": 1})
                                        }
                                    }))
                                }))
                            }, _ = () => {
                                e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}")
                            }, S = () => {
                                e.inline || e.on("keydown", (() => {
                                    document.activeElement === document.body && e.getWin().focus()
                                }))
                            }, k = () => {
                                e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (t => {
                                    let n;
                                    "HTML" === t.target.nodeName && (n = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(n), e.selection.normalize(), e.nodeChanged())
                                })))
                            }, A = () => {
                                u && e.on("keydown", (t => {
                                    if (Rf.metaKeyPressed(t) && !t.shiftKey && (37 === t.keyCode || 39 === t.keyCode)) {
                                        t.preventDefault();
                                        e.selection.getSel().modify("move", 37 === t.keyCode ? "backward" : "forward", "lineboundary")
                                    }
                                }))
                            }, N = () => {
                                e.on("click", (e => {
                                    let t = e.target;
                                    do {
                                        if ("A" === t.tagName) return void e.preventDefault()
                                    } while (t = t.parentNode)
                                })), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}")
                            }, T = () => {
                                e.on("init", (() => {
                                    e.dom.bind(e.getBody(), "submit", (e => {
                                        e.preventDefault()
                                    }))
                                }))
                            }, R = x, D = () => {
                                e.on("keydown", (t => {
                                    if (f(t) || t.keyCode !== Rf.BACKSPACE) return;
                                    let n = a.getRng();
                                    const o = n.startContainer, s = n.startOffset, i = r.getRoot();
                                    let l = o;
                                    if (n.collapsed && 0 === s) {
                                        for (; l.parentNode && l.parentNode.firstChild === l && l.parentNode !== i;) l = l.parentNode;
                                        "BLOCKQUOTE" === l.nodeName && (e.formatter.toggle("blockquote", void 0, l), n = r.createRng(), n.setStart(o, 0), n.setEnd(o, 0), a.setRng(n))
                                    }
                                })), p(), Rt.windowsPhone || e.on("keyup focusin mouseup", (t => {
                                    Rf.modifierPressed(t) || (e => {
                                        const t = e.getBody(), n = e.selection.getRng();
                                        return n.startContainer === n.endContainer && n.startContainer === t && 0 === n.startOffset && n.endOffset === t.childNodes.length
                                    })(e) || a.normalize()
                                }), !0), d && (v(), y(), e.on("init", (() => {
                                    m("DefaultParagraphSeparator", Jl(e))
                                })), T(), C(), s.addNodeFilter("br", (e => {
                                    let t = e.length;
                                    for (; t--;) "Apple-interchange-newline" === e[t].attr("class") && e[t].remove()
                                })), c ? (S(), k(), N()) : h()), l && (e.on("keydown", (t => {
                                    if (!f(t) && t.keyCode === n) {
                                        if (!e.getBody().getElementsByTagName("hr").length) return;
                                        if (a.isCollapsed() && 0 === a.getRng().startOffset) {
                                            const e = a.getNode(), n = e.previousSibling;
                                            if ("HR" === e.nodeName) return r.remove(e), void t.preventDefault();
                                            n && n.nodeName && "hr" === n.nodeName.toLowerCase() && (r.remove(n), t.preventDefault())
                                        }
                                    }
                                })), b(), (() => {
                                    const n = () => {
                                            const n = r.getAttribs(a.getStart().cloneNode(!1));
                                            return () => {
                                                const o = a.getStart();
                                                o !== e.getBody() && (r.setAttrib(o, "style", null), t(n, (e => {
                                                    o.setAttributeNode(e.cloneNode(!0))
                                                })))
                                            }
                                        },
                                        o = () => !a.isCollapsed() && r.getParent(a.getStart(), r.isBlock) !== r.getParent(a.getEnd(), r.isBlock);
                                    e.on("keypress", (t => {
                                        let r;
                                        return !(!(f(t) || 8 !== t.keyCode && 46 !== t.keyCode) && o() && (r = n(), e.getDoc().execCommand("delete", !1), r(), t.preventDefault(), 1))
                                    })), r.bind(e.getDoc(), "cut", (t => {
                                        if (!f(t) && o()) {
                                            const t = n();
                                            Yg.setEditorTimeout(e, (() => {
                                                t()
                                            }))
                                        }
                                    }))
                                })(), E(), w(), _(), A(), C(), e.on("drop", (t => {
                                    var n;
                                    const o = null === (n = t.dataTransfer) || void 0 === n ? void 0 : n.getData("text/html");
                                    g(o) && /^<img[^>]*>$/.test(o) && e.dispatch("dragend", new window.DragEvent("dragend", t))
                                })))
                            };
                        return hw(e) ? (d && (v(), y(), T(), h(), c && (S(), k(), N())), l && (b(), E(), _(), A())) : D(), {
                            refreshContentEditable: R,
                            isHidden: () => {
                                if (!l || e.removed) return !1;
                                const t = e.selection.getSel();
                                return !t || !t.rangeCount || 0 === t.rangeCount
                            }
                        }
                    }, FO = Xs.DOM, UO = e => e.inline ? e.getElement().nodeName.toLowerCase() : void 0,
                    qO = e => Ee(e, (e => !1 === C(e))), jO = e => {
                        const t = e.options.get, n = e.editorUpload.blobCache;
                        return qO({
                            allow_conditional_comments: t("allow_conditional_comments"),
                            allow_html_data_urls: t("allow_html_data_urls"),
                            allow_svg_data_urls: t("allow_svg_data_urls"),
                            allow_html_in_named_anchor: t("allow_html_in_named_anchor"),
                            allow_script_urls: t("allow_script_urls"),
                            allow_unsafe_link_target: t("allow_unsafe_link_target"),
                            convert_unsafe_embeds: t("convert_unsafe_embeds"),
                            convert_fonts_to_spans: t("convert_fonts_to_spans"),
                            fix_list_elements: t("fix_list_elements"),
                            font_size_legacy_values: t("font_size_legacy_values"),
                            forced_root_block: t("forced_root_block"),
                            forced_root_block_attrs: t("forced_root_block_attrs"),
                            preserve_cdata: t("preserve_cdata"),
                            inline_styles: t("inline_styles"),
                            root_name: UO(e),
                            sandbox_iframes: t("sandbox_iframes"),
                            sanitize: t("xss_sanitization"),
                            validate: !0,
                            blob_cache: n,
                            document: e.getDoc()
                        })
                    }, HO = e => {
                        const t = e.options.get;
                        return qO({
                            custom_elements: t("custom_elements"),
                            extended_valid_elements: t("extended_valid_elements"),
                            invalid_elements: t("invalid_elements"),
                            invalid_styles: t("invalid_styles"),
                            schema: t("schema"),
                            valid_children: t("valid_children"),
                            valid_classes: t("valid_classes"),
                            valid_elements: t("valid_elements"),
                            valid_styles: t("valid_styles"),
                            verify_html: t("verify_html"),
                            padd_empty_block_inline_children: t("format_empty_lines")
                        })
                    }, zO = e => {
                        e.bindPendingEventDelegates(), e.initialized = !0, (e => {
                            e.dispatch("Init")
                        })(e), e.focus(!0), (e => {
                            const t = e.dom.getRoot();
                            e.inline || km(e) && e.selection.getStart(!0) !== t || Yu(t).each((t => {
                                const n = t.getNode(), o = Qo(n) ? Yu(n).getOr(t) : t;
                                e.selection.setRng(o.toRange())
                            }))
                        })(e), e.nodeChanged({initial: !0});
                        const t = oc(e);
                        _(t) && t.call(e, e), (e => {
                            const t = ac(e);
                            t && Yg.setEditorTimeout(e, (() => {
                                let n;
                                n = !0 === t ? e : e.editorManager.get(t), n && !n.destroyed && (n.focus(), n.selection.scrollIntoView())
                            }), 100)
                        })(e)
                    }, $O = e => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, VO = e => {
                        const t = $O(e), n = Ed(e), o = e.contentCSS, r = () => {
                            t.unloadAll(o), e.inline || e.ui.styleSheetLoader.unloadAll(n)
                        }, a = () => {
                            e.removed ? r() : e.on("remove", r)
                        };
                        if (e.contentStyles.length > 0) {
                            let t = "";
                            Bt.each(e.contentStyles, (e => {
                                t += e + "\r\n"
                            })), e.dom.addStyle(t)
                        }
                        const s = Promise.all(((e, t, n) => {
                            const {pass: o, fail: r} = G(t, (e => tinymce.Resource.has(v_(e)))), a = o.map((t => {
                                const n = tinymce.Resource.get(v_(t));
                                return g(n) ? Promise.resolve($O(e).loadRawCss(t, n)) : Promise.resolve()
                            })), s = [...a, $O(e).loadAll(r)];
                            return e.inline ? s : s.concat([e.ui.styleSheetLoader.loadAll(n)])
                        })(e, o, n)).then(a).catch(a), i = Cd(e);
                        return i && ((e, t) => {
                            const n = yn.fromDom(e.getBody()), o = $n(zn(n)), r = yn.fromTag("style");
                            en(r, "type", "text/css"), bo(r, yn.fromText(t)), bo(o, r), e.on("remove", (() => {
                                wo(r)
                            }))
                        })(e, i), s
                    }, WO = e => {
                        !0 !== e.removed && ((e => {
                            hw(e) || e.load({initial: !0, format: "html"}), e.startContent = e.getContent({format: "raw"})
                        })(e), zO(e))
                    }, KO = e => {
                        const t = e.getElement();
                        let n = e.getDoc();
                        e.inline && (FO.addClass(t, "mce-content-body"), e.contentDocument = n = document, e.contentWindow = window, e.bodyElement = t, e.contentAreaContainer = t);
                        const o = e.getBody();
                        o.disabled = !0, e.readonly = Wd(e), e._editableRoot = Kd(e), !e.readonly && e.hasEditableRoot() && (e.inline && "static" === FO.getStyle(o, "position", !0) && (o.style.position = "relative"), o.contentEditable = "true"), o.disabled = !1, e.editorUpload = N_(e), e.schema = ys(HO(e)), e.dom = Xs(n, {
                            keep_values: !0,
                            url_converter: e.convertURL,
                            url_converter_scope: e,
                            update_styles: !0,
                            root_element: e.inline ? e.getBody() : null,
                            collect: e.inline,
                            schema: e.schema,
                            contentCssCors: fd(e),
                            referrerPolicy: gd(e),
                            onSetAttrib: t => {
                                e.dispatch("SetAttrib", t)
                            },
                            force_hex_color: Oc(e)
                        }), e.parser = (e => {
                            const t = DE(jO(e), e.schema);
                            return t.addAttributeFilter("src,href,style,tabindex", ((t, n) => {
                                const o = e.dom, r = "data-mce-" + n;
                                let a = t.length;
                                for (; a--;) {
                                    const s = t[a];
                                    let i = s.attr(n);
                                    if (i && !s.attr(r)) {
                                        if (0 === i.indexOf("data:") || 0 === i.indexOf("blob:")) continue;
                                        "style" === n ? (i = o.serializeStyle(o.parseStyle(i), s.name), i.length || (i = null), s.attr(r, i), s.attr(n, i)) : "tabindex" === n ? (s.attr(r, i), s.attr(n, null)) : s.attr(r, e.convertURL(i, n, s.name))
                                    }
                                }
                            })), t.addNodeFilter("script", (e => {
                                let t = e.length;
                                for (; t--;) {
                                    const n = e[t], o = n.attr("type") || "no/type";
                                    0 !== o.indexOf("mce-") && n.attr("type", "mce-" + o)
                                }
                            })), kc(e) && t.addNodeFilter("#cdata", (t => {
                                var n;
                                let o = t.length;
                                for (; o--;) {
                                    const r = t[o];
                                    r.type = 8, r.name = "#comment", r.value = "[CDATA[" + e.dom.encode(null !== (n = r.value) && void 0 !== n ? n : "") + "]]"
                                }
                            })), t.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (t => {
                                let n = t.length;
                                const o = e.schema.getNonEmptyElements();
                                for (; n--;) {
                                    const e = t[n];
                                    e.isEmpty(o) && 0 === e.getAll("br").length && e.append(new Ap("br", 1))
                                }
                            })), t
                        })(e), e.serializer = Ow((e => {
                            const t = e.options.get;
                            return {
                                ...jO(e), ...HO(e), ...qO({
                                    remove_trailing_brs: t("remove_trailing_brs"),
                                    pad_empty_with_br: t("pad_empty_with_br"),
                                    url_converter: t("url_converter"),
                                    url_converter_scope: t("url_converter_scope"),
                                    element_format: t("element_format"),
                                    entities: t("entities"),
                                    entity_encoding: t("entity_encoding"),
                                    indent: t("indent"),
                                    indent_after: t("indent_after"),
                                    indent_before: t("indent_before")
                                })
                            }
                        })(e), e), e.selection = Nw(e.dom, e.getWin(), e.serializer, e), e.annotator = Ef(e), e.formatter = q_(e), e.undoManager = H_(e), e._nodeChangeDispatcher = new sD(e), e._selectionOverrides = dO(e), Lx(e), wL(e), Hx(e), hw(e) || ((e => {
                            e.on("mousedown", (t => {
                                t.detail >= 3 && (t.preventDefault(), RL(e))
                            }))
                        })(e), (e => {
                            IO(e)
                        })(e));
                        const r = aD(e);
                        Rx(e, r), (e => {
                            e.on("NodeChange", L(Mx, e))
                        })(e), K_(e), EL(e);
                        const a = vw(e);
                        (e => {
                            const t = e.getDoc(), n = e.getBody();
                            (e => {
                                e.dispatch("PreInit")
                            })(e), sc(e) || (t.body.spellcheck = !1, FO.setAttrib(n, "spellcheck", "false")), e.quirks = MO(e), (e => {
                                e.dispatch("PostRender")
                            })(e);
                            const o = wd(e);
                            void 0 !== o && (n.dir = o);
                            const r = ic(e);
                            r && e.on("BeforeSetContent", (e => {
                                Bt.each(r, (t => {
                                    e.content = e.content.replace(t, (e => "\x3c!--mce:protected " + escape(e) + "--\x3e"))
                                }))
                            })), e.on("SetContent", (() => {
                                e.addVisual(e.getBody())
                            })), e.on("compositionstart compositionend", (t => {
                                e.composing = "compositionstart" === t.type
                            }))
                        })(e), a.fold((() => {
                            const t = (e => {
                                let t = !1;
                                const n = setTimeout((() => {
                                    t || e.setProgressState(!0)
                                }), 500);
                                return () => {
                                    clearTimeout(n), t = !0, e.setProgressState(!1)
                                }
                            })(e);
                            VO(e).then((() => {
                                WO(e), t()
                            }))
                        }), (t => {
                            e.setProgressState(!0), VO(e).then((() => {
                                t().then((t => {
                                    e.setProgressState(!1), WO(e), Cw(e)
                                }), (t => {
                                    e.notificationManager.open({type: "error", text: String(t)}), WO(e), Cw(e)
                                }))
                            }))
                        }))
                    }, YO = F, GO = Xs.DOM, XO = (e, t) => {
                        const n = e.translate("Rich Text Area"), o = on(yn.fromDom(e.getElement()), "tabindex").bind(Qe),
                            r = ((e, t, n, o) => {
                                const r = yn.fromTag("iframe");
                                return o.each((e => en(r, "tabindex", e))), tn(r, n), tn(r, {
                                    id: e + "_ifr",
                                    frameBorder: "0",
                                    allowTransparency: "true",
                                    title: t
                                }), fn(r, "tox-edit-area__iframe"), r
                            })(e.id, n, $l(e), o).dom;
                        r.onload = () => {
                            r.onload = null, e.dispatch("load")
                        }, e.contentAreaContainer = t.iframeContainer, e.iframeElement = r, e.iframeHTML = (e => {
                            let t = Vl(e) + "<html><head>";
                            Wl(e) !== e.documentBaseUrl && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
                            const n = Kl(e), o = Yl(e), r = e.translate(tc(e));
                            return Gl(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + Gl(e) + '" />'), t += `</head><body id="${n}" class="mce-content-body ${o}" data-id="${e.id}" aria-label="${r}"><br></body></html>`, t
                        })(e), GO.add(t.iframeContainer, r)
                    }, JO = e => {
                        const t = e.iframeElement, n = () => {
                            e.contentDocument = t.contentDocument, KO(e)
                        };
                        if (Nc(e) || Rt.browser.isFirefox()) {
                            const t = e.getDoc();
                            t.open(), t.write(e.iframeHTML), t.close(), n()
                        } else {
                            const o = ((e, t, n) => No(e, t, YO, n))(yn.fromDom(t), "load", (() => {
                                o.unbind(), n()
                            }));
                            t.srcdoc = e.iframeHTML
                        }
                    }, QO = Xs.DOM, ZO = (e, t, n) => {
                        const o = d_.get(n), r = d_.urls[n] || e.documentBaseUrl.replace(/\/$/, "");
                        if (n = Bt.trim(n), o && -1 === Bt.inArray(t, n)) {
                            if (e.plugins[n]) return;
                            try {
                                const a = o(e, r) || {};
                                e.plugins[n] = a, _(a.init) && (a.init(e, r), t.push(n))
                            } catch (t) {
                                ((e, t, n) => {
                                    const o = oi.translate(["Failed to initialize plugin: {0}", t]);
                                    Sf(e, "PluginLoadError", {message: o}), h_(o, n), f_(e, o)
                                })(e, n, t)
                            }
                        }
                    }, eB = (e, t) => ({editorContainer: e, iframeContainer: t, api: {}}), tB = e => {
                        const t = e.getElement();
                        return e.inline ? eB(null) : (e => {
                            const t = QO.create("div");
                            return QO.insertAfter(t, e), eB(t, t)
                        })(t)
                    }, nB = e => {
                        const t = e.getElement();
                        return e.orgDisplay = t.style.display, g(Td(e)) ? (e => {
                            const t = e.theme.renderUI;
                            return t ? t() : tB(e)
                        })(e) : _(Td(e)) ? (e => {
                            const t = e.getElement(), n = Td(e)(e, t);
                            return n.editorContainer.nodeType && (n.editorContainer.id = n.editorContainer.id || e.id + "_parent"), n.iframeContainer && n.iframeContainer.nodeType && (n.iframeContainer.id = n.iframeContainer.id || e.id + "_iframecontainer"), n.height = n.iframeHeight ? n.iframeHeight : t.offsetHeight, n
                        })(e) : tB(e)
                    }, oB = async e => {
                        e.dispatch("ScriptsLoaded"), (e => {
                            const t = Bt.trim(id(e)), n = e.ui.registry.getAll().icons,
                                o = {...Qw.get("default").icons, ...Qw.get(t).icons};
                            he(o, ((t, o) => {
                                ke(n, o) || e.ui.registry.addIcon(o, t)
                            }))
                        })(e), (e => {
                            const t = Td(e);
                            if (g(t)) {
                                const n = c_.get(t);
                                e.theme = n(e, c_.urls[t]) || {}, _(e.theme.init) && e.theme.init(e, c_.urls[t] || e.documentBaseUrl.replace(/\/$/, ""))
                            } else e.theme = {}
                        })(e), (e => {
                            const t = Dd(e), n = Zw.get(t);
                            e.model = n(e, Zw.urls[t])
                        })(e), (e => {
                            const t = [];
                            K(Gd(e), (n => {
                                ZO(e, t, (e => e.replace(/^\-/, ""))(n))
                            }))
                        })(e);
                        const t = await nB(e);
                        ((e, t) => {
                            const n = {
                                show: U.from(t.show).getOr(x),
                                hide: U.from(t.hide).getOr(x),
                                isEnabled: U.from(t.isEnabled).getOr(F),
                                setEnabled: n => {
                                    e.mode.isReadOnly() || U.from(t.setEnabled).each((e => e(n)))
                                }
                            };
                            e.ui = {...e.ui, ...n}
                        })(e, U.from(t.api).getOr({})), e.editorContainer = t.editorContainer, y_(e), e.inline ? KO(e) : ((e, t) => {
                            XO(e, t), t.editorContainer && (t.editorContainer.style.display = e.orgDisplay, e.hidden = GO.isHidden(t.editorContainer)), e.getElement().style.display = "none", GO.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, JO(e)
                        })(e, {editorContainer: t.editorContainer, iframeContainer: t.iframeContainer})
                    }, rB = Xs.DOM, aB = e => "-" === e.charAt(0), sB = (e, t) => {
                        const n = pd(t), o = hd(t);
                        if (!oi.hasCode(n) && "en" !== n) {
                            const r = Xe(o) ? o : `${t.editorManager.baseURL}/langs/${n}.js`;
                            e.add(r).catch((() => {
                                ((e, t, n) => {
                                    g_(e, "LanguageLoadError", p_("language", t, n))
                                })(t, r, n)
                            }))
                        }
                    }, iB = (e, t) => {
                        const n = Td(e);
                        if (g(n) && !aB(n) && !ke(c_.urls, n)) {
                            const o = Rd(e), r = o ? e.documentBaseURI.toAbsolute(o) : `themes/${n}/theme${t}.js`;
                            c_.load(n, r).catch((() => {
                                ((e, t, n) => {
                                    g_(e, "ThemeLoadError", p_("theme", t, n))
                                })(e, r, n)
                            }))
                        }
                    }, lB = (e, t) => {
                        const n = Dd(e);
                        if ("plugin" !== n && !ke(Zw.urls, n)) {
                            const o = Ld(e), r = g(o) ? e.documentBaseURI.toAbsolute(o) : `models/${n}/model${t}.js`;
                            Zw.load(n, r).catch((() => {
                                ((e, t, n) => {
                                    g_(e, "ModelLoadError", p_("model", t, n))
                                })(e, r, n)
                            }))
                        }
                    }, dB = (e, t, n) => U.from(t).filter((e => Xe(e) && !Qw.has(e))).map((t => ({
                        url: `${e.editorManager.baseURL}/icons/${t}/icons${n}.js`,
                        name: U.some(t)
                    }))), cB = (e, t, n) => {
                        const o = dB(t, "default", n), r = (e => U.from(ld(e)).filter(Xe).map((e => ({
                            url: e,
                            name: U.none()
                        }))))(t).orThunk((() => dB(t, id(t), "")));
                        K((e => {
                            const t = [], n = e => {
                                t.push(e)
                            };
                            for (let t = 0; t < e.length; t++) e[t].each(n);
                            return t
                        })([o, r]), (n => {
                            e.add(n.url).catch((() => {
                                ((e, t, n) => {
                                    g_(e, "IconsLoadError", p_("icons", t, n))
                                })(t, n.url, n.name.getOrUndefined())
                            }))
                        }))
                    }, uB = (e, t) => {
                        const n = (t, n) => {
                            d_.load(t, n).catch((() => {
                                ((e, t, n) => {
                                    g_(e, "PluginLoadError", p_("plugin", t, n))
                                })(e, n, t)
                            }))
                        };
                        he(Xd(e), ((t, o) => {
                            n(o, t), e.options.set("plugins", Gd(e).concat(o))
                        })), K(Gd(e), (e => {
                            !(e = Bt.trim(e)) || d_.urls[e] || aB(e) || n(e, `plugins/${e}/plugin${t}.js`)
                        }))
                    }, mB = (e, t) => {
                        const n = Qs.ScriptLoader, o = () => {
                            !e.removed && (e => {
                                const t = Td(e);
                                return !g(t) || w(c_.get(t))
                            })(e) && (e => {
                                const t = Dd(e);
                                return w(Zw.get(t))
                            })(e) && oB(e)
                        };
                        iB(e, t), lB(e, t), sB(n, e), cB(n, e, t), uB(e, t), n.loadQueue().then(o, o)
                    }, fB = e => {
                        const t = e.id;
                        oi.setCode(pd(e));
                        const n = () => {
                            rB.unbind(window, "ready", n), e.render()
                        };
                        if (!qs.Event.domLoaded) return void rB.bind(window, "ready", n);
                        if (!e.getElement()) return;
                        const o = yn.fromDom(e.getElement()), r = sn(o);
                        e.on("remove", (() => {
                            Y(o.dom.attributes, (e => an(o, e.name))), tn(o, r)
                        })), e.ui.styleSheetLoader = ((e, t) => za.forElement(e, {
                            contentCssCors: Yd(t),
                            referrerPolicy: gd(t)
                        }))(o, e), Ud(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
                        const a = e.getElement().form || rB.getParent(t, "form");
                        a && (e.formElement = a, qd(e) && !er(e.getElement()) && (rB.insertAfter(rB.create("input", {
                            type: "hidden",
                            name: t
                        }), t), e.hasHiddenInput = !0), e.formEventDelegate = t => {
                            e.dispatch(t.type, t)
                        }, rB.bind(a, "submit reset", e.formEventDelegate), e.on("reset", (() => {
                            e.resetContent()
                        })), !jd(e) || a.submit.nodeType || a.submit.length || a._mceOldSubmit || (a._mceOldSubmit = a.submit, a.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), a._mceOldSubmit(a)))), e.windowManager = u_(e), e.notificationManager = l_(e), (e => "xml" === e.options.get("encoding"))(e) && e.on("GetContent", (e => {
                            e.save && (e.content = rB.encode(e.content))
                        })), Hd(e) && e.on("submit", (() => {
                            e.initialized && e.save()
                        })), zd(e) && (e._beforeUnload = () => {
                            !e.initialized || e.destroyed || e.isHidden() || e.save({
                                format: "raw",
                                no_events: !0,
                                set_dirty: !1
                            })
                        }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), mB(e, e.suffix)
                    }, gB = _t().deviceType, pB = gB.isPhone(), hB = gB.isTablet(), vB = e => {
                        if (E(e)) return [];
                        {
                            const t = v(e) ? e : e.split(/[ ,]/), n = W(t, Ke);
                            return X(n, Xe)
                        }
                    }, bB = (e, t) => {
                        const n = ((e, t) => {
                            const n = {}, o = {};
                            return Ce(e, t, ye(n), ye(o)), {t: n, f: o}
                        })(t, ((t, n) => $(e, n)));
                        return o = n.t, r = n.f, {sections: T(o), options: T(r)};
                        var o, r
                    }, yB = (e, t) => ke(e.sections(), t), CB = (e, t) => ({
                        ...{
                            table_grid: !1,
                            object_resizing: !1,
                            resize: !1,
                            toolbar_mode: Se(e, "toolbar_mode").getOr("scrolling"),
                            toolbar_sticky: !1
                        }, ...t ? {menubar: !1} : {}
                    }), EB = (e, t) => {
                        var n;
                        const o = null !== (n = t.external_plugins) && void 0 !== n ? n : {};
                        return e && e.external_plugins ? Bt.extend({}, e.external_plugins, o) : o
                    }, wB = (e, t, n, o) => {
                        const r = vB(n.forced_plugins), a = vB(o.plugins),
                            s = ((e, t) => yB(e, t) ? e.sections()[t] : {})(t, "mobile"),
                            i = ((e, t, n, o) => e && yB(t, "mobile") ? o : n)(e, t, a, s.plugins ? vB(s.plugins) : a),
                            l = ((e, t) => [...vB(e), ...vB(t)])(r, i);
                        return Bt.extend(o, {forced_plugins: r, plugins: l})
                    }, _B = (e, t, n, o, r) => {
                        var a;
                        const s = e ? {mobile: CB(null !== (a = r.mobile) && void 0 !== a ? a : {}, t)} : {},
                            i = bB(["mobile"], wN(s, r)),
                            l = Bt.extend(n, o, i.options(), ((e, t) => e && yB(t, "mobile"))(e, i) ? ((e, t, n = {}) => {
                                const o = e.sections(), r = Se(o, t).getOr({});
                                return Bt.extend({}, n, r)
                            })(i, "mobile") : {}, {external_plugins: EB(o, i.options())});
                        return wB(e, i, o, l)
                    }, SB = (e, t) => ((e, t) => yw(e).editor.addVisual(t))(e, t), kB = e => {
                        const t = t => () => {
                            K("left,center,right,justify".split(","), (n => {
                                t !== n && e.formatter.remove("align" + n)
                            })), "none" !== t && ((t, n) => {
                                e.formatter.toggle(t, n), e.nodeChanged()
                            })("align" + t)
                        };
                        e.editorCommands.addCommands({
                            JustifyLeft: t("left"),
                            JustifyCenter: t("center"),
                            JustifyRight: t("right"),
                            JustifyFull: t("justify"),
                            JustifyNone: t("none")
                        })
                    }, xB = e => {
                        kB(e), (e => {
                            const t = t => () => {
                                const n = e.selection,
                                    o = n.isCollapsed() ? [e.dom.getParent(n.getNode(), e.dom.isBlock)] : n.getSelectedBlocks();
                                return V(o, (n => w(e.formatter.matchNode(n, t))))
                            };
                            e.editorCommands.addCommands({
                                JustifyLeft: t("alignleft"),
                                JustifyCenter: t("aligncenter"),
                                JustifyRight: t("alignright"),
                                JustifyFull: t("alignjustify")
                            }, "state")
                        })(e)
                    }, AB = (e, t) => {
                        const n = e.selection, o = e.dom;
                        return /^ | $/.test(t) ? ((e, t, n, o) => {
                            const r = yn.fromDom(e.getRoot());
                            return n = Fh(r, rl.fromRangeStart(t), o) ? n.replace(/^ /, "&nbsp;") : n.replace(/^&nbsp;/, " "), Uh(r, rl.fromRangeEnd(t), o) ? n.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : n.replace(/&nbsp;(<br( \/)?>)?$/, " ")
                        })(o, n.getRng(), t, e.schema) : t
                    }, NB = (e, t) => {
                        if (e.selection.isEditable()) {
                            const {content: n, details: o} = (e => {
                                if ("string" != typeof e) {
                                    const t = Bt.extend({paste: e.paste, data: {paste: e.paste}}, e);
                                    return {content: e.content, details: t}
                                }
                                return {content: e, details: {}}
                            })(t);
                            PE(e, {...o, content: AB(e, n), format: "html", set: !1, selection: !0}).each((t => {
                                const n = ((e, t, n) => bw(e).editor.insertContent(t, n))(e, t.content, o);
                                IE(e, n, t), e.addVisual()
                            }))
                        }
                    }, TB = {"font-size": "size", "font-family": "face"}, RB = Qt("font"),
                    DB = (e, t, n) => Ib(yn.fromDom(n), (t => (t => mo(t, e).orThunk((() => RB(t) ? Se(TB, e).bind((e => on(t, e))) : U.none())))(t)), (e => _n(yn.fromDom(t), e))),
                    LB = e => (t, n) => U.from(n).map(yn.fromDom).filter(Yt).bind((n => DB(e, t, n.dom).or(((e, t) => U.from(Xs.DOM.getStyle(t, e, !0)))(e, n.dom)))).getOr(""),
                    OB = LB("font-size"),
                    BB = A((e => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",")), LB("font-family")),
                    PB = e => Yu(e.getBody()).bind((e => {
                        const t = e.container();
                        return U.from(tr(t) ? t.parentNode : t)
                    })), IB = (e, t) => (e => U.from(e.selection.getRng()).bind((t => {
                        const n = e.getBody();
                        return t.startContainer === n && 0 === t.startOffset ? U.none() : U.from(e.selection.getStart(!0))
                    })))(e).orThunk(L(PB, e)).map(yn.fromDom).filter(Yt).bind(t), MB = (e, t) => IB(e, N(U.some, t)),
                    FB = (e, t) => {
                        if (/^[0-9.]+$/.test(t)) {
                            const n = parseInt(t, 10);
                            if (n >= 1 && n <= 7) {
                                const o = (e => Bt.explode(e.options.get("font_size_style_values")))(e),
                                    r = (e => Bt.explode(e.options.get("font_size_classes")))(e);
                                return r.length > 0 ? r[n - 1] || t : o[n - 1] || t
                            }
                            return t
                        }
                        return t
                    }, UB = e => {
                        const t = e.split(/\s*,\s*/);
                        return W(t, (e => -1 === e.indexOf(" ") || $e(e, '"') || $e(e, "'") ? e : `'${e}'`)).join(",")
                    }, qB = e => {
                        const t = (t, n) => {
                            e.formatter.toggle(t, n), e.nodeChanged()
                        };
                        e.editorCommands.addCommands({
                            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": e => {
                                t(e)
                            }, "ForeColor,HiliteColor": (e, n, o) => {
                                t(e, {value: o})
                            }, BackColor: (e, n, o) => {
                                t("hilitecolor", {value: o})
                            }, FontName: (t, n, o) => {
                                ((e, t) => {
                                    const n = FB(e, t);
                                    e.formatter.toggle("fontname", {value: UB(n)}), e.nodeChanged()
                                })(e, o)
                            }, FontSize: (t, n, o) => {
                                ((e, t) => {
                                    e.formatter.toggle("fontsize", {value: FB(e, t)}), e.nodeChanged()
                                })(e, o)
                            }, LineHeight: (t, n, o) => {
                                ((e, t) => {
                                    e.formatter.toggle("lineheight", {value: String(t)}), e.nodeChanged()
                                })(e, o)
                            }, Lang: (e, n, o) => {
                                var r;
                                t(e, {value: o.code, customValue: null !== (r = o.customCode) && void 0 !== r ? r : null})
                            }, RemoveFormat: t => {
                                e.formatter.remove(t)
                            }, mceBlockQuote: () => {
                                t("blockquote")
                            }, FormatBlock: (e, n, o) => {
                                t(g(o) ? o : "p")
                            }, mceToggleFormat: (e, n, o) => {
                                t(o)
                            }
                        })
                    }, jB = e => {
                        const t = t => e.formatter.match(t);
                        e.editorCommands.addCommands({
                            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": e => t(e),
                            mceBlockQuote: () => t("blockquote")
                        }, "state"), e.editorCommands.addQueryValueHandler("FontName", (() => (e => MB(e, (t => BB(e.getBody(), t.dom))).getOr(""))(e))), e.editorCommands.addQueryValueHandler("FontSize", (() => (e => MB(e, (t => OB(e.getBody(), t.dom))).getOr(""))(e))), e.editorCommands.addQueryValueHandler("LineHeight", (() => (e => MB(e, (t => {
                            const n = yn.fromDom(e.getBody()), o = Ib(t, (e => mo(e, "line-height")), L(_n, n));
                            return o.getOrThunk((() => {
                                const e = parseFloat(co(t, "line-height")), n = parseFloat(co(t, "font-size"));
                                return String(e / n)
                            }))
                        })).getOr(""))(e)))
                    }, HB = e => {
                        e.editorCommands.addCommands({
                            Indent: () => {
                                (e => {
                                    kx(e, "indent")
                                })(e)
                            }, Outdent: () => {
                                xx(e)
                            }
                        }), e.editorCommands.addCommands({Outdent: () => wx(e)}, "state")
                    }, zB = (e, t) => {
                        const n = e.dom, o = e.selection.getRng(), r = t ? e.selection.getStart() : e.selection.getEnd(),
                            a = t ? o.startContainer : o.endContainer, s = XT(n, a);
                        if (!s || !s.isContentEditable) return;
                        const i = t ? po : ho, l = Jl(e);
                        ((e, t, n, o) => {
                            const r = e.dom, a = e => r.isBlock(e) && e.parentElement === n,
                                s = a(t) ? t : r.getParent(o, a, n);
                            return U.from(s).map(yn.fromDom)
                        })(e, r, s, a).each((t => {
                            const n = eR(e, a, t.dom, s, !1, l);
                            i(t, yn.fromDom(n)), e.selection.setCursorLocation(n, 0), e.dispatch("NewBlock", {newBlock: n}), HT(e, "insertParagraph")
                        }))
                    }, $B = e => {
                        e.editorCommands.addCommands({
                            InsertNewBlockBefore: () => {
                                (e => {
                                    zB(e, !0)
                                })(e)
                            }, InsertNewBlockAfter: () => {
                                (e => {
                                    zB(e, !1)
                                })(e)
                            }
                        })
                    }, VB = e => {
                        xB(e), (e => {
                            e.editorCommands.addCommands({
                                "Cut,Copy,Paste": t => {
                                    const n = e.getDoc();
                                    let o;
                                    try {
                                        n.execCommand(t)
                                    } catch (e) {
                                        o = !0
                                    }
                                    if ("paste" !== t || n.queryCommandEnabled(t) || (o = !0), o || !n.queryCommandSupported(t)) {
                                        let t = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
                                        (Rt.os.isMacOS() || Rt.os.isiOS()) && (t = t.replace(/Ctrl\+/g, "⌘+")), e.notificationManager.open({
                                            text: t,
                                            type: "error"
                                        })
                                    }
                                }
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceAddUndoLevel: () => {
                                    e.undoManager.add()
                                }, mceEndUndoLevel: () => {
                                    e.undoManager.add()
                                }, Undo: () => {
                                    e.undoManager.undo()
                                }, Redo: () => {
                                    e.undoManager.redo()
                                }
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceSelectNodeDepth: (t, n, o) => {
                                    let r = 0;
                                    e.dom.getParent(e.selection.getNode(), (t => !Vo(t) || r++ !== o || (e.selection.select(t), !1)), e.getBody())
                                }, mceSelectNode: (t, n, o) => {
                                    e.selection.select(o)
                                }, selectAll: () => {
                                    const t = e.dom.getParent(e.selection.getStart(), dr);
                                    if (t) {
                                        const n = e.dom.createRng();
                                        n.selectNodeContents(t), e.selection.setRng(n)
                                    }
                                }
                            })
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceCleanup: () => {
                                    const t = e.selection.getBookmark();
                                    e.setContent(e.getContent()), e.selection.moveToBookmark(t)
                                }, insertImage: (t, n, o) => {
                                    NB(e, e.dom.createHTML("img", {src: o}))
                                }, insertHorizontalRule: () => {
                                    e.execCommand("mceInsertContent", !1, "<hr>")
                                }, insertText: (t, n, o) => {
                                    NB(e, e.dom.encode(o))
                                }, insertHTML: (t, n, o) => {
                                    NB(e, o)
                                }, mceInsertContent: (t, n, o) => {
                                    NB(e, o)
                                }, mceSetContent: (t, n, o) => {
                                    e.setContent(o)
                                }, mceReplaceContent: (t, n, o) => {
                                    e.execCommand("mceInsertContent", !1, o.replace(/\{\$selection\}/g, e.selection.getContent({format: "text"})))
                                }, mceNewDocument: () => {
                                    e.setContent(mc(e))
                                }
                            })
                        })(e), (e => {
                            const t = (t, n, o) => {
                                const r = g(o) ? {href: o} : o, a = e.dom.getParent(e.selection.getNode(), "a");
                                p(r) && g(r.href) && (r.href = r.href.replace(/ /g, "%20"), a && r.href || e.formatter.remove("link"), r.href && e.formatter.apply("link", r, a))
                            };
                            e.editorCommands.addCommands({
                                unlink: () => {
                                    if (e.selection.isEditable()) {
                                        if (e.selection.isCollapsed()) {
                                            const t = e.dom.getParent(e.selection.getStart(), "a");
                                            return void (t && e.dom.remove(t, !0))
                                        }
                                        e.formatter.remove("link")
                                    }
                                }, mceInsertLink: t, createLink: t
                            })
                        })(e), HB(e), $B(e), (e => {
                            e.editorCommands.addCommands({
                                insertParagraph: () => {
                                    MR(gR, e)
                                }, mceInsertNewLine: (t, n, o) => {
                                    FR(e, o)
                                }, InsertLineBreak: (t, n, o) => {
                                    MR(_R, e)
                                }
                            })
                        })(e), (e => {
                            (e => {
                                e.editorCommands.addCommands({
                                    "InsertUnorderedList,InsertOrderedList": t => {
                                        e.getDoc().execCommand(t);
                                        const n = e.dom.getParent(e.selection.getNode(), "ol,ul");
                                        if (n) {
                                            const t = n.parentNode;
                                            if (t && /^(H[1-6]|P|ADDRESS|PRE)$/.test(t.nodeName)) {
                                                const o = e.selection.getBookmark();
                                                e.dom.split(t, n), e.selection.moveToBookmark(o)
                                            }
                                        }
                                    }
                                })
                            })(e), (e => {
                                e.editorCommands.addCommands({
                                    "InsertUnorderedList,InsertOrderedList": t => {
                                        const n = e.dom.getParent(e.selection.getNode(), "ul,ol");
                                        return n && ("insertunorderedlist" === t && "UL" === n.tagName || "insertorderedlist" === t && "OL" === n.tagName)
                                    }
                                }, "state")
                            })(e)
                        })(e), (e => {
                            qB(e), jB(e)
                        })(e), (e => {
                            e.editorCommands.addCommands({
                                mceRemoveNode: (t, n, o) => {
                                    const r = null != o ? o : e.selection.getNode();
                                    if (r !== e.getBody()) {
                                        const t = e.selection.getBookmark();
                                        e.dom.remove(r, !0), e.selection.moveToBookmark(t)
                                    }
                                }, mcePrint: () => {
                                    e.getWin().print()
                                }, mceFocus: (t, n, o) => {
                                    cp(e, !0 === o)
                                }, mceToggleVisualAid: () => {
                                    e.hasVisual = !e.hasVisual, e.addVisual()
                                }
                            })
                        })(e)
                    }, WB = ["toggleview"], KB = e => $(WB, e.toLowerCase());

                class YB {
                    constructor(e) {
                        this.commands = {state: {}, exec: {}, value: {}}, this.editor = e
                    }

                    execCommand(e, t = !1, n, o) {
                        const r = this.editor, a = e.toLowerCase(), s = null == o ? void 0 : o.skip_focus;
                        if (r.removed) return !1;
                        "mcefocus" !== a && (/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(a) || s ? (e => {
                            Wg(e).each((t => e.selection.setRng(t)))
                        })(r) : r.focus());
                        if (r.dispatch("BeforeExecCommand", {
                            command: e,
                            ui: t,
                            value: n
                        }).isDefaultPrevented()) return !1;
                        const i = this.commands.exec[a];
                        return !!_(i) && (i(a, t, n), r.dispatch("ExecCommand", {command: e, ui: t, value: n}), !0)
                    }

                    queryCommandState(e) {
                        if (!KB(e) && this.editor.quirks.isHidden() || this.editor.removed) return !1;
                        const t = e.toLowerCase(), n = this.commands.state[t];
                        return !!_(n) && n(t)
                    }

                    queryCommandValue(e) {
                        if (!KB(e) && this.editor.quirks.isHidden() || this.editor.removed) return "";
                        const t = e.toLowerCase(), n = this.commands.value[t];
                        return _(n) ? n(t) : ""
                    }

                    addCommands(e, t = "exec") {
                        const n = this.commands;
                        he(e, ((e, o) => {
                            K(o.toLowerCase().split(","), (o => {
                                n[t][o] = e
                            }))
                        }))
                    }

                    addCommand(e, t, n) {
                        const o = e.toLowerCase();
                        this.commands.exec[o] = (e, o, r) => t.call(null != n ? n : this.editor, o, r)
                    }

                    queryCommandSupported(e) {
                        const t = e.toLowerCase();
                        return !!this.commands.exec[t]
                    }

                    addQueryStateHandler(e, t, n) {
                        this.commands.state[e.toLowerCase()] = () => t.call(null != n ? n : this.editor)
                    }

                    addQueryValueHandler(e, t, n) {
                        this.commands.value[e.toLowerCase()] = () => t.call(null != n ? n : this.editor)
                    }
                }

                const GB = "data-mce-contenteditable", XB = (e, t, n) => {
                        try {
                            e.getDoc().execCommand(t, !1, String(n))
                        } catch (e) {
                        }
                    }, JB = (e, t) => {
                        e.dom.contentEditable = t ? "true" : "false"
                    }, QB = (e, t) => {
                        const n = yn.fromDom(e.getBody());
                        ((e, t, n) => {
                            vn(e, t) && !n ? pn(e, t) : n && fn(e, t)
                        })(n, "mce-content-readonly", t), t ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), (e => {
                            U.from(e.selection.getNode()).each((e => {
                                e.removeAttribute("data-mce-selected")
                            }))
                        })(e), e.readonly = !0, JB(n, !1), K(qo(n, '*[contenteditable="true"]'), (e => {
                            en(e, GB, "true"), JB(e, !1)
                        }))) : (e.readonly = !1, e.hasEditableRoot() && JB(n, !0), (e => {
                            K(qo(e, `*[${GB}="true"]`), (e => {
                                an(e, GB), JB(e, !0)
                            }))
                        })(n), XB(e, "StyleWithCSS", !1), XB(e, "enableInlineTableEditing", !1), XB(e, "enableObjectResizing", !1), lp(e) && e.focus(), (e => {
                            e.selection.setRng(e.selection.getRng())
                        })(e), e.nodeChanged())
                    }, ZB = e => e.readonly, eP = e => {
                        e.parser.addAttributeFilter("contenteditable", (t => {
                            ZB(e) && K(t, (e => {
                                e.attr(GB, e.attr("contenteditable")), e.attr("contenteditable", "false")
                            }))
                        })), e.serializer.addAttributeFilter(GB, (t => {
                            ZB(e) && K(t, (e => {
                                e.attr("contenteditable", e.attr(GB))
                            }))
                        })), e.serializer.addTempAttr(GB)
                    }, tP = ["copy"], nP = (e, t) => {
                        if ((e => "click" === e.type)(t) && !Rf.metaKeyPressed(t)) {
                            const n = yn.fromDom(t.target);
                            ((e, t) => no(t, "a", (t => _n(t, yn.fromDom(e.getBody())))).bind((e => on(e, "href"))))(e, n).each((n => {
                                if (t.preventDefault(), /^#/.test(n)) {
                                    const t = e.dom.select(`${n},[name="${He(n, "#")}"]`);
                                    t.length && e.selection.scrollIntoView(t[0], !0)
                                } else window.open(n, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes")
                            }))
                        } else (e => $(tP, e.type))(t) && e.dispatch(t.type, t)
                    },
                    oP = Bt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");

                class rP {
                    static isNative(e) {
                        return !!oP[e.toLowerCase()]
                    }

                    constructor(e) {
                        this.bindings = {}, this.settings = e || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || M
                    }

                    fire(e, t) {
                        return this.dispatch(e, t)
                    }

                    dispatch(e, t) {
                        const n = e.toLowerCase(), o = Bs(n, null != t ? t : {}, this.scope);
                        this.settings.beforeFire && this.settings.beforeFire(o);
                        const r = this.bindings[n];
                        if (r) for (let e = 0, t = r.length; e < t; e++) {
                            const t = r[e];
                            if (!t.removed) {
                                if (t.once && this.off(n, t.func), o.isImmediatePropagationStopped()) return o;
                                if (!1 === t.func.call(this.scope, o)) return o.preventDefault(), o
                            }
                        }
                        return o
                    }

                    on(e, t, n, o) {
                        if (!1 === t && (t = M), t) {
                            const r = {func: t, removed: !1};
                            o && Bt.extend(r, o);
                            const a = e.toLowerCase().split(" ");
                            let s = a.length;
                            for (; s--;) {
                                const e = a[s];
                                let t = this.bindings[e];
                                t || (t = [], this.toggleEvent(e, !0)), t = n ? [r, ...t] : [...t, r], this.bindings[e] = t
                            }
                        }
                        return this
                    }

                    off(e, t) {
                        if (e) {
                            const n = e.toLowerCase().split(" ");
                            let o = n.length;
                            for (; o--;) {
                                const r = n[o];
                                let a = this.bindings[r];
                                if (!r) return he(this.bindings, ((e, t) => {
                                    this.toggleEvent(t, !1), delete this.bindings[t]
                                })), this;
                                if (a) {
                                    if (t) {
                                        const e = G(a, (e => e.func === t));
                                        a = e.fail, this.bindings[r] = a, K(e.pass, (e => {
                                            e.removed = !0
                                        }))
                                    } else a.length = 0;
                                    a.length || (this.toggleEvent(e, !1), delete this.bindings[r])
                                }
                            }
                        } else he(this.bindings, ((e, t) => {
                            this.toggleEvent(t, !1)
                        })), this.bindings = {};
                        return this
                    }

                    once(e, t, n) {
                        return this.on(e, t, n, {once: !0})
                    }

                    has(e) {
                        e = e.toLowerCase();
                        const t = this.bindings[e];
                        return !(!t || 0 === t.length)
                    }
                }

                const aP = e => (e._eventDispatcher || (e._eventDispatcher = new rP({
                    scope: e, toggleEvent: (t, n) => {
                        rP.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, n)
                    }
                })), e._eventDispatcher), sP = {
                    fire(e, t, n) {
                        return this.dispatch(e, t, n)
                    }, dispatch(e, t, n) {
                        const o = this;
                        if (o.removed && "remove" !== e && "detach" !== e) return Bs(e.toLowerCase(), null != t ? t : {}, o);
                        const r = aP(o).dispatch(e, t);
                        if (!1 !== n && o.parent) {
                            let t = o.parent();
                            for (; t && !r.isPropagationStopped();) t.dispatch(e, r, !1), t = t.parent ? t.parent() : void 0
                        }
                        return r
                    }, on(e, t, n) {
                        return aP(this).on(e, t, n)
                    }, off(e, t) {
                        return aP(this).off(e, t)
                    }, once(e, t) {
                        return aP(this).once(e, t)
                    }, hasEventListeners(e) {
                        return aP(this).has(e)
                    }
                }, iP = Xs.DOM;
                let lP;
                const dP = (e, t) => {
                        if ("selectionchange" === t) return e.getDoc();
                        if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(t)) return e.getDoc().documentElement;
                        const n = Ad(e);
                        return n ? (e.eventRoot || (e.eventRoot = iP.select(n)[0]), e.eventRoot) : e.getBody()
                    }, cP = (e, t, n) => {
                        (e => !e.hidden && !ZB(e))(e) ? e.dispatch(t, n) : ZB(e) && nP(e, n)
                    }, uP = (e, t) => {
                        if (e.delegates || (e.delegates = {}), e.delegates[t] || e.removed) return;
                        const n = dP(e, t);
                        if (Ad(e)) {
                            if (lP || (lP = {}, e.editorManager.on("removeEditor", (() => {
                                e.editorManager.activeEditor || lP && (he(lP, ((t, n) => {
                                    e.dom.unbind(dP(e, n))
                                })), lP = null)
                            }))), lP[t]) return;
                            const o = n => {
                                const o = n.target, r = e.editorManager.get();
                                let a = r.length;
                                for (; a--;) {
                                    const e = r[a].getBody();
                                    (e === o || iP.isChildOf(o, e)) && cP(r[a], t, n)
                                }
                            };
                            lP[t] = o, iP.bind(n, t, o)
                        } else {
                            const o = n => {
                                cP(e, t, n)
                            };
                            iP.bind(n, t, o), e.delegates[t] = o
                        }
                    }, mP = {
                        ...sP, bindPendingEventDelegates() {
                            const e = this;
                            Bt.each(e._pendingNativeEvents, (t => {
                                uP(e, t)
                            }))
                        }, toggleNativeEvent(e, t) {
                            const n = this;
                            "focus" !== e && "blur" !== e && (n.removed || (t ? n.initialized ? uP(n, e) : n._pendingNativeEvents ? n._pendingNativeEvents.push(e) : n._pendingNativeEvents = [e] : n.initialized && n.delegates && (n.dom.unbind(dP(n, e), e, n.delegates[e]), delete n.delegates[e])))
                        }, unbindAllNativeEvents() {
                            const e = this, t = e.getBody(), n = e.dom;
                            e.delegates && (he(e.delegates, ((t, n) => {
                                e.dom.unbind(dP(e, n), n, t)
                            })), delete e.delegates), !e.inline && t && n && (t.onload = null, n.unbind(e.getWin()), n.unbind(e.getDoc())), n && (n.unbind(t), n.unbind(e.getContainer()))
                        }
                    }, fP = e => g(e) ? {value: e.split(/[ ,]/), valid: !0} : k(e, g) ? {value: e, valid: !0} : {
                        valid: !1,
                        message: "The value must be a string[] or a comma/space separated string."
                    }, gP = (e, t) => e + (Je(t.message) ? "" : `. ${t.message}`), pP = e => e.valid,
                    hP = (e, t, n = "") => {
                        const o = t(e);
                        return y(o) ? o ? {value: e, valid: !0} : {valid: !1, message: n} : o
                    }, vP = (e, t) => {
                        const n = {}, o = {}, r = (e, t, n) => {
                            const r = hP(t, n);
                            return pP(r) ? (o[e] = r.value, !0) : (console.warn(gP(`Invalid value passed for the ${e} option`, r)), !1)
                        }, a = e => ke(n, e);
                        return {
                            register: (e, a) => {
                                const s = (e => g(e.processor))(a) ? (e => {
                                    const t = (() => {
                                        switch (e) {
                                            case"array":
                                                return v;
                                            case"boolean":
                                                return y;
                                            case"function":
                                                return _;
                                            case"number":
                                                return S;
                                            case"object":
                                                return p;
                                            case"string":
                                                return g;
                                            case"string[]":
                                                return fP;
                                            case"object[]":
                                                return e => k(e, p);
                                            case"regexp":
                                                return e => f(e, RegExp);
                                            default:
                                                return F
                                        }
                                    })();
                                    return n => hP(n, t, `The value must be a ${e}.`)
                                })(a.processor) : a.processor, i = ((e, t, n) => {
                                    if (!C(t)) {
                                        const o = hP(t, n);
                                        if (pP(o)) return o.value;
                                        console.error(gP(`Invalid default value passed for the "${e}" option`, o))
                                    }
                                })(e, a.default, s);
                                n[e] = {...a, default: i, processor: s};
                                Se(o, e).orThunk((() => Se(t, e))).each((t => r(e, t, s)))
                            },
                            isRegistered: a,
                            get: e => Se(o, e).orThunk((() => Se(n, e).map((e => e.default)))).getOrUndefined(),
                            set: (e, t) => {
                                if (a(e)) {
                                    const o = n[e];
                                    return o.immutable ? (console.error(`"${e}" is an immutable option and cannot be updated`), !1) : r(e, t, o.processor)
                                }
                                return console.warn(`"${e}" is not a registered option. Ensure the option has been registered before setting a value.`), !1
                            },
                            unset: e => {
                                const t = a(e);
                                return t && delete o[e], t
                            },
                            isSet: e => ke(o, e)
                        }
                    }, bP = ["design", "readonly"], yP = (e, t, n, o) => {
                        const r = n[t.get()], a = n[o];
                        try {
                            a.activate()
                        } catch (e) {
                            return void console.error(`problem while activating editor mode ${o}:`, e)
                        }
                        r.deactivate(), r.editorReadOnly !== a.editorReadOnly && QB(e, a.editorReadOnly), t.set(o), ((e, t) => {
                            e.dispatch("SwitchMode", {mode: t})
                        })(e, o)
                    }, CP = e => {
                        const t = Zs("design"), n = Zs({
                            design: {activate: x, deactivate: x, editorReadOnly: !1},
                            readonly: {activate: x, deactivate: x, editorReadOnly: !0}
                        });
                        return (e => {
                            e.serializer ? eP(e) : e.on("PreInit", (() => {
                                eP(e)
                            }))
                        })(e), (e => {
                            e.on("ShowCaret", (t => {
                                ZB(e) && t.preventDefault()
                            })), e.on("ObjectSelected", (t => {
                                ZB(e) && t.preventDefault()
                            }))
                        })(e), {
                            isReadOnly: () => ZB(e), set: o => ((e, t, n, o) => {
                                if (o !== n.get()) {
                                    if (!ke(t, o)) throw new Error(`Editor mode '${o}' is invalid`);
                                    e.initialized ? yP(e, n, t, o) : e.on("init", (() => yP(e, n, t, o)))
                                }
                            })(e, n.get(), t, o), get: () => t.get(), register: (e, t) => {
                                n.set(((e, t, n) => {
                                    if ($(bP, t)) throw new Error(`Cannot override default mode ${t}`);
                                    return {
                                        ...e, [t]: {
                                            ...n, deactivate: () => {
                                                try {
                                                    n.deactivate()
                                                } catch (e) {
                                                    console.error(`problem while deactivating editor mode ${t}:`, e)
                                                }
                                            }
                                        }
                                    }
                                })(n.get(), e, t))
                            }
                        }
                    }, EP = Bt.each, wP = Bt.explode, _P = {
                        f1: 112,
                        f2: 113,
                        f3: 114,
                        f4: 115,
                        f5: 116,
                        f6: 117,
                        f7: 118,
                        f8: 119,
                        f9: 120,
                        f10: 121,
                        f11: 122,
                        f12: 123
                    }, SP = Bt.makeMap("alt,ctrl,shift,meta,access"), kP = e => {
                        const t = {}, n = Rt.os.isMacOS() || Rt.os.isiOS();
                        EP(wP(e.toLowerCase(), "+"), (e => {
                            (e => e in SP)(e) ? t[e] = !0 : /^[0-9]{2,}$/.test(e) ? t.keyCode = parseInt(e, 10) : (t.charCode = e.charCodeAt(0), t.keyCode = _P[e] || e.toUpperCase().charCodeAt(0))
                        }));
                        const o = [t.keyCode];
                        let r;
                        for (r in SP) t[r] ? o.push(r) : t[r] = !1;
                        return t.id = o.join(","), t.access && (t.alt = !0, n ? t.ctrl = !0 : t.shift = !0), t.meta && (n ? t.meta = !0 : (t.ctrl = !0, t.meta = !1)), t
                    };

                class xP {
                    constructor(e) {
                        this.shortcuts = {}, this.pendingPatterns = [], this.editor = e;
                        const t = this;
                        e.on("keyup keypress keydown", (e => {
                            !t.hasModifier(e) && !t.isFunctionKey(e) || e.isDefaultPrevented() || (EP(t.shortcuts, (n => {
                                t.matchShortcut(e, n) && (t.pendingPatterns = n.subpatterns.slice(0), "keydown" === e.type && t.executeShortcutAction(n))
                            })), t.matchShortcut(e, t.pendingPatterns[0]) && (1 === t.pendingPatterns.length && "keydown" === e.type && t.executeShortcutAction(t.pendingPatterns[0]), t.pendingPatterns.shift()))
                        }))
                    }

                    add(e, t, n, o) {
                        const r = this, a = r.normalizeCommandFunc(n);
                        return EP(wP(Bt.trim(e)), (e => {
                            const n = r.createShortcut(e, t, a, o);
                            r.shortcuts[n.id] = n
                        })), !0
                    }

                    remove(e) {
                        const t = this.createShortcut(e);
                        return !!this.shortcuts[t.id] && (delete this.shortcuts[t.id], !0)
                    }

                    normalizeCommandFunc(e) {
                        const t = this, n = e;
                        return "string" == typeof n ? () => {
                            t.editor.execCommand(n, !1, null)
                        } : Bt.isArray(n) ? () => {
                            t.editor.execCommand(n[0], n[1], n[2])
                        } : n
                    }

                    createShortcut(e, t, n, o) {
                        const r = Bt.map(wP(e, ">"), kP);
                        return r[r.length - 1] = Bt.extend(r[r.length - 1], {
                            func: n,
                            scope: o || this.editor
                        }), Bt.extend(r[0], {desc: this.editor.translate(t), subpatterns: r.slice(1)})
                    }

                    hasModifier(e) {
                        return e.altKey || e.ctrlKey || e.metaKey
                    }

                    isFunctionKey(e) {
                        return "keydown" === e.type && e.keyCode >= 112 && e.keyCode <= 123
                    }

                    matchShortcut(e, t) {
                        return !!t && (t.ctrl === e.ctrlKey && t.meta === e.metaKey && (t.alt === e.altKey && t.shift === e.shiftKey && (!!(e.keyCode === t.keyCode || e.charCode && e.charCode === t.charCode) && (e.preventDefault(), !0))))
                    }

                    executeShortcutAction(e) {
                        return e.func ? e.func.call(e.scope) : null
                    }
                }

                const AP = () => {
                    const e = (() => {
                        const e = {}, t = {}, n = {}, o = {}, r = {}, a = {}, s = {}, i = {}, l = (e, t) => (n, o) => {
                            e[n.toLowerCase()] = {...o, type: t}
                        };
                        return {
                            addButton: l(e, "button"),
                            addGroupToolbarButton: l(e, "grouptoolbarbutton"),
                            addToggleButton: l(e, "togglebutton"),
                            addMenuButton: l(e, "menubutton"),
                            addSplitButton: l(e, "splitbutton"),
                            addMenuItem: l(t, "menuitem"),
                            addNestedMenuItem: l(t, "nestedmenuitem"),
                            addToggleMenuItem: l(t, "togglemenuitem"),
                            addAutocompleter: l(n, "autocompleter"),
                            addContextMenu: l(r, "contextmenu"),
                            addContextToolbar: l(a, "contexttoolbar"),
                            addContextForm: l(a, "contextform"),
                            addSidebar: l(s, "sidebar"),
                            addView: l(i, "views"),
                            addIcon: (e, t) => o[e.toLowerCase()] = t,
                            getAll: () => ({
                                buttons: e,
                                menuItems: t,
                                icons: o,
                                popups: n,
                                contextMenus: r,
                                contextToolbars: a,
                                sidebars: s,
                                views: i
                            })
                        }
                    })();
                    return {
                        addAutocompleter: e.addAutocompleter,
                        addButton: e.addButton,
                        addContextForm: e.addContextForm,
                        addContextMenu: e.addContextMenu,
                        addContextToolbar: e.addContextToolbar,
                        addIcon: e.addIcon,
                        addMenuButton: e.addMenuButton,
                        addMenuItem: e.addMenuItem,
                        addNestedMenuItem: e.addNestedMenuItem,
                        addSidebar: e.addSidebar,
                        addSplitButton: e.addSplitButton,
                        addToggleButton: e.addToggleButton,
                        addGroupToolbarButton: e.addGroupToolbarButton,
                        addToggleMenuItem: e.addToggleMenuItem,
                        addView: e.addView,
                        getAll: e.getAll
                    }
                }, NP = Xs.DOM, TP = Bt.extend, RP = Bt.each;

                class DP {
                    constructor(e, t, n) {
                        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this._editableRoot = !0, this.editorManager = n, this.documentBaseUrl = n.documentBaseURL, TP(this, mP);
                        const o = this;
                        this.id = e, this.hidden = !1;
                        const r = ((e, t) => _B(pB || hB, pB, t, e, t))(n.defaultOptions, t);
                        this.options = vP(0, r), (e => {
                            const t = e.options.register;
                            t("id", {
                                processor: "string",
                                default: e.id
                            }), t("selector", {processor: "string"}), t("target", {processor: "object"}), t("suffix", {processor: "string"}), t("cache_suffix", {processor: "string"}), t("base_url", {processor: "string"}), t("referrer_policy", {
                                processor: "string",
                                default: ""
                            }), t("language_load", {
                                processor: "boolean",
                                default: !0
                            }), t("inline", {
                                processor: "boolean",
                                default: !1
                            }), t("iframe_attrs", {
                                processor: "object",
                                default: {}
                            }), t("doctype", {
                                processor: "string",
                                default: "<!DOCTYPE html>"
                            }), t("document_base_url", {
                                processor: "string",
                                default: e.documentBaseUrl
                            }), t("body_id", {
                                processor: zl(e, "tinymce"),
                                default: "tinymce"
                            }), t("body_class", {
                                processor: zl(e),
                                default: ""
                            }), t("content_security_policy", {
                                processor: "string",
                                default: ""
                            }), t("br_in_pre", {
                                processor: "boolean",
                                default: !0
                            }), t("forced_root_block", {
                                processor: e => {
                                    const t = g(e) && Xe(e);
                                    return t ? {value: e, valid: t} : {
                                        valid: !1,
                                        message: "Must be a non-empty string."
                                    }
                                }, default: "p"
                            }), t("forced_root_block_attrs", {
                                processor: "object",
                                default: {}
                            }), t("newline_behavior", {
                                processor: e => {
                                    const t = $(["block", "linebreak", "invert", "default"], e);
                                    return t ? {value: e, valid: t} : {
                                        valid: !1,
                                        message: "Must be one of: block, linebreak, invert or default."
                                    }
                                }, default: "default"
                            }), t("br_newline_selector", {
                                processor: "string",
                                default: ".mce-toc h2,figcaption,caption"
                            }), t("no_newline_selector", {
                                processor: "string",
                                default: ""
                            }), t("keep_styles", {
                                processor: "boolean",
                                default: !0
                            }), t("end_container_on_empty_block", {
                                processor: e => y(e) || g(e) ? {
                                    valid: !0,
                                    value: e
                                } : {valid: !1, message: "Must be boolean or a string"}, default: "blockquote"
                            }), t("font_size_style_values", {
                                processor: "string",
                                default: "xx-small,x-small,small,medium,large,x-large,xx-large"
                            }), t("font_size_legacy_values", {
                                processor: "string",
                                default: "xx-small,small,medium,large,x-large,xx-large,300%"
                            }), t("font_size_classes", {
                                processor: "string",
                                default: ""
                            }), t("automatic_uploads", {
                                processor: "boolean",
                                default: !0
                            }), t("images_reuse_filename", {
                                processor: "boolean",
                                default: !1
                            }), t("images_replace_blob_uris", {
                                processor: "boolean",
                                default: !0
                            }), t("icons", {processor: "string", default: ""}), t("icons_url", {
                                processor: "string",
                                default: ""
                            }), t("images_upload_url", {
                                processor: "string",
                                default: ""
                            }), t("images_upload_base_path", {
                                processor: "string",
                                default: ""
                            }), t("images_upload_credentials", {
                                processor: "boolean",
                                default: !1
                            }), t("images_upload_handler", {processor: "function"}), t("language", {
                                processor: "string",
                                default: "en"
                            }), t("language_url", {
                                processor: "string",
                                default: ""
                            }), t("entity_encoding", {
                                processor: "string",
                                default: "named"
                            }), t("indent", {
                                processor: "boolean",
                                default: !0
                            }), t("indent_before", {
                                processor: "string",
                                default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
                            }), t("indent_after", {
                                processor: "string",
                                default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
                            }), t("indent_use_margin", {
                                processor: "boolean",
                                default: !1
                            }), t("indentation", {
                                processor: "string",
                                default: "40px"
                            }), t("content_css", {
                                processor: e => {
                                    const t = !1 === e || g(e) || k(e, g);
                                    return t ? g(e) ? {value: W(e.split(","), Ke), valid: t} : v(e) ? {
                                        value: e,
                                        valid: t
                                    } : !1 === e ? {value: [], valid: t} : {value: e, valid: t} : {
                                        valid: !1,
                                        message: "Must be false, a string or an array of strings."
                                    }
                                }, default: Ud(e) ? [] : ["default"]
                            }), t("content_style", {processor: "string"}), t("content_css_cors", {
                                processor: "boolean",
                                default: !1
                            }), t("font_css", {
                                processor: e => {
                                    const t = g(e) || k(e, g);
                                    return t ? {value: v(e) ? e : W(e.split(","), Ke), valid: t} : {
                                        valid: !1,
                                        message: "Must be a string or an array of strings."
                                    }
                                }, default: []
                            }), t("inline_boundaries", {
                                processor: "boolean",
                                default: !0
                            }), t("inline_boundaries_selector", {
                                processor: "string",
                                default: "a[href],code,span.mce-annotation"
                            }), t("object_resizing", {
                                processor: e => {
                                    const t = y(e) || g(e);
                                    return t ? !1 === e || Ml.isiPhone() || Ml.isiPad() ? {
                                        value: "",
                                        valid: t
                                    } : {
                                        value: !0 === e ? "table,img,figure.image,div,video,iframe" : e,
                                        valid: t
                                    } : {valid: !1, message: "Must be boolean or a string"}
                                }, default: !Fl
                            }), t("resize_img_proportional", {
                                processor: "boolean",
                                default: !0
                            }), t("event_root", {processor: "object"}), t("service_message", {processor: "string"}), t("theme", {
                                processor: e => !1 === e || g(e) || _(e),
                                default: "silver"
                            }), t("theme_url", {processor: "string"}), t("formats", {processor: "object"}), t("format_empty_lines", {
                                processor: "boolean",
                                default: !1
                            }), t("format_noneditable_selector", {
                                processor: "string",
                                default: ""
                            }), t("preview_styles", {
                                processor: e => {
                                    const t = !1 === e || g(e);
                                    return t ? {value: !1 === e ? "" : e, valid: t} : {
                                        valid: !1,
                                        message: "Must be false or a string"
                                    }
                                },
                                default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
                            }), t("custom_ui_selector", {
                                processor: "string",
                                default: ""
                            }), t("hidden_input", {
                                processor: "boolean",
                                default: !0
                            }), t("submit_patch", {
                                processor: "boolean",
                                default: !0
                            }), t("encoding", {processor: "string"}), t("add_form_submit_trigger", {
                                processor: "boolean",
                                default: !0
                            }), t("add_unload_trigger", {
                                processor: "boolean",
                                default: !0
                            }), t("custom_undo_redo_levels", {
                                processor: "number",
                                default: 0
                            }), t("disable_nodechange", {
                                processor: "boolean",
                                default: !1
                            }), t("readonly", {
                                processor: "boolean",
                                default: !1
                            }), t("editable_root", {
                                processor: "boolean",
                                default: !0
                            }), t("plugins", {
                                processor: "string[]",
                                default: []
                            }), t("external_plugins", {processor: "object"}), t("forced_plugins", {processor: "string[]"}), t("model", {
                                processor: "string",
                                default: e.hasPlugin("rtc") ? "plugin" : "dom"
                            }), t("model_url", {processor: "string"}), t("block_unsupported_drop", {
                                processor: "boolean",
                                default: !0
                            }), t("visual", {
                                processor: "boolean",
                                default: !0
                            }), t("visual_table_class", {
                                processor: "string",
                                default: "mce-item-table"
                            }), t("visual_anchor_class", {
                                processor: "string",
                                default: "mce-item-anchor"
                            }), t("iframe_aria_text", {
                                processor: "string",
                                default: "Rich Text Area. Press ALT-0 for help."
                            }), t("setup", {processor: "function"}), t("init_instance_callback", {processor: "function"}), t("url_converter", {
                                processor: "function",
                                default: e.convertURL
                            }), t("url_converter_scope", {
                                processor: "object",
                                default: e
                            }), t("urlconverter_callback", {processor: "function"}), t("allow_conditional_comments", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_html_data_urls", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_svg_data_urls", {processor: "boolean"}), t("allow_html_in_named_anchor", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_script_urls", {
                                processor: "boolean",
                                default: !1
                            }), t("allow_unsafe_link_target", {
                                processor: "boolean",
                                default: !1
                            }), t("convert_fonts_to_spans", {
                                processor: "boolean",
                                default: !0,
                                deprecated: !0
                            }), t("fix_list_elements", {
                                processor: "boolean",
                                default: !1
                            }), t("preserve_cdata", {
                                processor: "boolean",
                                default: !1
                            }), t("remove_trailing_brs", {
                                processor: "boolean",
                                default: !0
                            }), t("pad_empty_with_br", {
                                processor: "boolean",
                                default: !1
                            }), t("inline_styles", {
                                processor: "boolean",
                                default: !0,
                                deprecated: !0
                            }), t("element_format", {
                                processor: "string",
                                default: "html"
                            }), t("entities", {processor: "string"}), t("schema", {
                                processor: "string",
                                default: "html5"
                            }), t("convert_urls", {
                                processor: "boolean",
                                default: !0
                            }), t("relative_urls", {
                                processor: "boolean",
                                default: !0
                            }),t("remove_script_host", {
                                processor: "boolean",
                                default: !0
                            }),t("custom_elements", {processor: "string"}),t("extended_valid_elements", {processor: "string"}),t("invalid_elements", {processor: "string"}),t("invalid_styles", {processor: Hl}),t("valid_children", {processor: "string"}),t("valid_classes", {processor: Hl}),t("valid_elements", {processor: "string"}),t("valid_styles", {processor: Hl}),t("verify_html", {
                                processor: "boolean",
                                default: !0
                            }),t("auto_focus", {processor: e => g(e) || !0 === e}),t("browser_spellcheck", {
                                processor: "boolean",
                                default: !1
                            }),t("protect", {processor: "array"}),t("images_file_types", {
                                processor: "string",
                                default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
                            }),t("deprecation_warnings", {
                                processor: "boolean",
                                default: !0
                            }),t("a11y_advanced_options", {
                                processor: "boolean",
                                default: !1
                            }),t("api_key", {processor: "string"}),t("paste_block_drop", {
                                processor: "boolean",
                                default: !1
                            }),t("paste_data_images", {
                                processor: "boolean",
                                default: !0
                            }),t("paste_preprocess", {processor: "function"}),t("paste_postprocess", {processor: "function"}),t("paste_webkit_styles", {
                                processor: "string",
                                default: "none"
                            }),t("paste_remove_styles_if_webkit", {
                                processor: "boolean",
                                default: !0
                            }),t("paste_merge_formats", {
                                processor: "boolean",
                                default: !0
                            }),t("smart_paste", {
                                processor: "boolean",
                                default: !0
                            }),t("paste_as_text", {
                                processor: "boolean",
                                default: !1
                            }),t("paste_tab_spaces", {
                                processor: "number",
                                default: 4
                            }),t("text_patterns", {
                                processor: e => k(e, p) || !1 === e ? {
                                    value: Il(!1 === e ? [] : e),
                                    valid: !0
                                } : {valid: !1, message: "Must be an array of objects or false."},
                                default: [{start: "*", end: "*", format: "italic"}, {
                                    start: "**",
                                    end: "**",
                                    format: "bold"
                                }, {start: "#", format: "h1"}, {start: "##", format: "h2"}, {
                                    start: "###",
                                    format: "h3"
                                }, {start: "####", format: "h4"}, {start: "#####", format: "h5"}, {
                                    start: "######",
                                    format: "h6"
                                }, {start: "1. ", cmd: "InsertOrderedList"}, {
                                    start: "* ",
                                    cmd: "InsertUnorderedList"
                                }, {start: "- ", cmd: "InsertUnorderedList"}]
                            }),t("text_patterns_lookup", {
                                processor: e => {
                                    return _(e) ? {
                                        value: (t = e, e => {
                                            const n = t(e);
                                            return Il(n)
                                        }), valid: !0
                                    } : {valid: !1, message: "Must be a single function"};
                                    var t
                                }, default: e => []
                            }),t("noneditable_class", {
                                processor: "string",
                                default: "mceNonEditable"
                            }),t("editable_class", {
                                processor: "string",
                                default: "mceEditable"
                            }),t("noneditable_regexp", {
                                processor: e => k(e, ql) ? {
                                    value: e,
                                    valid: !0
                                } : ql(e) ? {value: [e], valid: !0} : {
                                    valid: !1,
                                    message: "Must be a RegExp or an array of RegExp."
                                }, default: []
                            }),t("table_tab_navigation", {
                                processor: "boolean",
                                default: !0
                            }),t("highlight_on_focus", {
                                processor: "boolean",
                                default: !1
                            }),t("xss_sanitization", {
                                processor: "boolean",
                                default: !0
                            }),t("details_initial_state", {
                                processor: e => {
                                    const t = $(["inherited", "collapsed", "expanded"], e);
                                    return t ? {value: e, valid: t} : {
                                        valid: !1,
                                        message: "Must be one of: inherited, collapsed, or expanded."
                                    }
                                }, default: "inherited"
                            }),t("details_serialized_state", {
                                processor: e => {
                                    const t = $(["inherited", "collapsed", "expanded"], e);
                                    return t ? {value: e, valid: t} : {
                                        valid: !1,
                                        message: "Must be one of: inherited, collapsed, or expanded."
                                    }
                                }, default: "inherited"
                            }),t("init_content_sync", {
                                processor: "boolean",
                                default: !1
                            }),t("newdocument_content", {
                                processor: "string",
                                default: ""
                            }),t("force_hex_color", {
                                processor: e => {
                                    const t = ["always", "rgb_only", "off"], n = $(t, e);
                                    return n ? {value: e, valid: n} : {
                                        valid: !1,
                                        message: `Must be one of: ${t.join(", ")}.`
                                    }
                                }, default: "off"
                            }),t("sandbox_iframes", {
                                processor: "boolean",
                                default: !1
                            }),t("convert_unsafe_embeds", {
                                processor: "boolean",
                                default: !1
                            }),e.on("ScriptsLoaded", (() => {
                                t("directionality", {
                                    processor: "string",
                                    default: oi.isRtl() ? "rtl" : void 0
                                }), t("placeholder", {
                                    processor: "string",
                                    default: Ul.getAttrib(e.getElement(), "placeholder")
                                })
                            }))
                        })(o);
                        const a = this.options.get;
                        a("deprecation_warnings") && Kw(t, r);
                        const s = a("suffix");
                        s && (n.suffix = s), this.suffix = n.suffix;
                        const i = a("base_url");
                        i && n._setBaseUrl(i), this.baseUri = n.baseURI;
                        const l = gd(o);
                        l && (Qs.ScriptLoader._setReferrerPolicy(l), Xs.DOM.styleSheetLoader._setReferrerPolicy(l));
                        const d = Yd(o);
                        w(d) && Xs.DOM.styleSheetLoader._setContentCssCors(d), ri.languageLoad = a("language_load"), ri.baseURL = n.baseURL, this.setDirty(!1), this.documentBaseURI = new pE(Wl(o), {base_uri: this.baseUri}), this.baseURI = this.baseUri, this.inline = Ud(o), this.hasVisual = Qd(o), this.shortcuts = new xP(this), this.editorCommands = new YB(this), VB(this);
                        const c = a("cache_suffix");
                        c && (Rt.cacheSuffix = c.replace(/^[\?\&]+/, "")), this.ui = {
                            registry: AP(),
                            styleSheetLoader: void 0,
                            show: x,
                            hide: x,
                            setEnabled: x,
                            isEnabled: F
                        }, this.mode = CP(o), n.dispatch("SetupEditor", {editor: this});
                        const u = nc(o);
                        _(u) && u.call(o, o)
                    }

                    render() {
                        fB(this)
                    }

                    focus(e) {
                        this.execCommand("mceFocus", !1, e)
                    }

                    hasFocus() {
                        return ip(this)
                    }

                    translate(e) {
                        return oi.translate(e)
                    }

                    getParam(e, t, n) {
                        const o = this.options;
                        return o.isRegistered(e) || (w(n) ? o.register(e, {
                            processor: n,
                            default: t
                        }) : o.register(e, {processor: F, default: t})), o.isSet(e) || C(t) ? o.get(e) : t
                    }

                    hasPlugin(e, t) {
                        return !!$(Gd(this), e) && (!t || void 0 !== d_.get(e))
                    }

                    nodeChanged(e) {
                        this._nodeChangeDispatcher.nodeChanged(e)
                    }

                    addCommand(e, t, n) {
                        this.editorCommands.addCommand(e, t, n)
                    }

                    addQueryStateHandler(e, t, n) {
                        this.editorCommands.addQueryStateHandler(e, t, n)
                    }

                    addQueryValueHandler(e, t, n) {
                        this.editorCommands.addQueryValueHandler(e, t, n)
                    }

                    addShortcut(e, t, n, o) {
                        this.shortcuts.add(e, t, n, o)
                    }

                    execCommand(e, t, n, o) {
                        return this.editorCommands.execCommand(e, t, n, o)
                    }

                    queryCommandState(e) {
                        return this.editorCommands.queryCommandState(e)
                    }

                    queryCommandValue(e) {
                        return this.editorCommands.queryCommandValue(e)
                    }

                    queryCommandSupported(e) {
                        return this.editorCommands.queryCommandSupported(e)
                    }

                    show() {
                        const e = this;
                        e.hidden && (e.hidden = !1, e.inline ? e.getBody().contentEditable = "true" : (NP.show(e.getContainer()), NP.hide(e.id)), e.load(), e.dispatch("show"))
                    }

                    hide() {
                        const e = this;
                        e.hidden || (e.save(), e.inline ? (e.getBody().contentEditable = "false", e === e.editorManager.focusedEditor && (e.editorManager.focusedEditor = null)) : (NP.hide(e.getContainer()), NP.setStyle(e.id, "display", e.orgDisplay)), e.hidden = !0, e.dispatch("hide"))
                    }

                    isHidden() {
                        return this.hidden
                    }

                    setProgressState(e, t) {
                        this.dispatch("ProgressState", {state: e, time: t})
                    }

                    load(e = {}) {
                        const t = this, n = t.getElement();
                        if (t.removed) return "";
                        if (n) {
                            const o = {...e, load: !0}, r = er(n) ? n.value : n.innerHTML, a = t.setContent(r, o);
                            return o.no_events || t.dispatch("LoadContent", {...o, element: n}), a
                        }
                        return ""
                    }

                    save(e = {}) {
                        const t = this;
                        let n = t.getElement();
                        if (!n || !t.initialized || t.removed) return "";
                        const o = {...e, save: !0, element: n};
                        let r = t.getContent(o);
                        const a = {...o, content: r};
                        if (a.no_events || t.dispatch("SaveContent", a), "raw" === a.format && t.dispatch("RawSaveContent", a), r = a.content, er(n)) n.value = r; else {
                            !e.is_removing && t.inline || (n.innerHTML = r);
                            const o = NP.getParent(t.id, "form");
                            o && RP(o.elements, (e => e.name !== t.id || (e.value = r, !1)))
                        }
                        return a.element = o.element = n = null, !1 !== a.set_dirty && t.setDirty(!1), r
                    }

                    setContent(e, t) {
                        return Pw(this, e, t)
                    }

                    getContent(e) {
                        return Bw(this, e)
                    }

                    insertContent(e, t) {
                        t && (e = TP({content: e}, t)), this.execCommand("mceInsertContent", !1, e)
                    }

                    resetContent(e) {
                        void 0 === e ? Pw(this, this.startContent, {format: "raw"}) : Pw(this, e), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged()
                    }

                    isDirty() {
                        return !this.isNotDirty
                    }

                    setDirty(e) {
                        const t = !this.isNotDirty;
                        this.isNotDirty = !e, e && e !== t && this.dispatch("dirty")
                    }

                    getContainer() {
                        const e = this;
                        return e.container || (e.container = e.editorContainer || NP.get(e.id + "_parent")), e.container
                    }

                    getContentAreaContainer() {
                        return this.contentAreaContainer
                    }

                    getElement() {
                        return this.targetElm || (this.targetElm = NP.get(this.id)), this.targetElm
                    }

                    getWin() {
                        const e = this;
                        if (!e.contentWindow) {
                            const t = e.iframeElement;
                            t && (e.contentWindow = t.contentWindow)
                        }
                        return e.contentWindow
                    }

                    getDoc() {
                        const e = this;
                        if (!e.contentDocument) {
                            const t = e.getWin();
                            t && (e.contentDocument = t.document)
                        }
                        return e.contentDocument
                    }

                    getBody() {
                        var e, t;
                        const n = this.getDoc();
                        return null !== (t = null !== (e = this.bodyElement) && void 0 !== e ? e : null == n ? void 0 : n.body) && void 0 !== t ? t : null
                    }

                    convertURL(e, t, n) {
                        const o = this, r = o.options.get, a = rc(o);
                        if (_(a)) return a.call(o, e, n, !0, t);
                        if (!r("convert_urls") || "link" === n || p(n) && "LINK" === n.nodeName || 0 === e.indexOf("file:") || 0 === e.length) return e;
                        const s = new pE(e);
                        return "http" !== s.protocol && "https" !== s.protocol && "" !== s.protocol ? e : r("relative_urls") ? o.documentBaseURI.toRelative(e) : e = o.documentBaseURI.toAbsolute(e, r("remove_script_host"))
                    }

                    addVisual(e) {
                        SB(this, e)
                    }

                    setEditableRoot(e) {
                        ((e, t) => {
                            e._editableRoot !== t && (e._editableRoot = t, e.readonly || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), ((e, t) => {
                                e.dispatch("EditableRootStateChange", {state: t})
                            })(e, t))
                        })(this, e)
                    }

                    hasEditableRoot() {
                        return this._editableRoot
                    }

                    remove() {
                        Xw(this)
                    }

                    destroy(e) {
                        Jw(this, e)
                    }

                    uploadImages() {
                        return this.editorUpload.uploadImages()
                    }

                    _scanForImages() {
                        return this.editorUpload.scanForImages()
                    }
                }

                const LP = Xs.DOM, OP = Bt.each;
                let BP, PP = !1, IP = [];
                const MP = e => {
                    const t = e.type;
                    OP(jP.get(), (n => {
                        switch (t) {
                            case"scroll":
                                n.dispatch("ScrollWindow", e);
                                break;
                            case"resize":
                                n.dispatch("ResizeWindow", e)
                        }
                    }))
                }, FP = e => {
                    if (e !== PP) {
                        const t = Xs.DOM;
                        e ? (t.bind(window, "resize", MP), t.bind(window, "scroll", MP)) : (t.unbind(window, "resize", MP), t.unbind(window, "scroll", MP)), PP = e
                    }
                }, UP = e => {
                    const t = IP;
                    return IP = X(IP, (t => e !== t)), jP.activeEditor === e && (jP.activeEditor = IP.length > 0 ? IP[0] : null), jP.focusedEditor === e && (jP.focusedEditor = null), t.length !== IP.length
                }, qP = "CSS1Compat" !== document.compatMode, jP = {
                    ...sP,
                    baseURI: null,
                    baseURL: null,
                    defaultOptions: {},
                    documentBaseURL: null,
                    suffix: null,
                    majorVersion: "6",
                    minorVersion: "8.4",
                    releaseDate: "2024-06-19",
                    i18n: oi,
                    activeEditor: null,
                    focusedEditor: null,
                    setup() {
                        const e = this;
                        let t = "", n = "", o = pE.getDocumentBaseUrl(document.location);
                        /^[^:]+:\/\/\/?[^\/]+\//.test(o) && (o = o.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(o) || (o += "/"));
                        const r = window.tinymce || window.tinyMCEPreInit;
                        if (r) t = r.base || r.baseURL, n = r.suffix; else {
                            const e = document.getElementsByTagName("script");
                            for (let o = 0; o < e.length; o++) {
                                const r = e[o].src || "";
                                if ("" === r) continue;
                                const a = r.substring(r.lastIndexOf("/"));
                                if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(r)) {
                                    -1 !== a.indexOf(".min") && (n = ".min"), t = r.substring(0, r.lastIndexOf("/"));
                                    break
                                }
                            }
                            if (!t && document.currentScript) {
                                const e = document.currentScript.src;
                                -1 !== e.indexOf(".min") && (n = ".min"), t = e.substring(0, e.lastIndexOf("/"))
                            }
                        }
                        var a;
                        e.baseURL = new pE(o).toAbsolute(t), e.documentBaseURL = o, e.baseURI = new pE(e.baseURL), e.suffix = n, (a = e).on("AddEditor", L(tp, a)), a.on("RemoveEditor", L(np, a))
                    },
                    overrideDefaults(e) {
                        const t = e.base_url;
                        t && this._setBaseUrl(t);
                        const n = e.suffix;
                        n && (this.suffix = n), this.defaultOptions = e;
                        const o = e.plugin_base_urls;
                        void 0 !== o && he(o, ((e, t) => {
                            ri.PluginManager.urls[t] = e
                        }))
                    },
                    init(e) {
                        const t = this;
                        let n;
                        const o = Bt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
                        let r = e => {
                            n = e
                        };
                        const a = () => {
                            let n = 0;
                            const s = [];
                            let i;
                            LP.unbind(window, "ready", a), (n => {
                                const o = e[n];
                                if (o) o.apply(t, [])
                            })("onpageload"), i = ((e, t) => {
                                const n = [], o = _(t) ? e => V(n, (n => t(n, e))) : e => $(n, e);
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = e[t];
                                    o(r) || n.push(r)
                                }
                                return n
                            })((e => Rt.browser.isIE() || Rt.browser.isEdge() ? (h_("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : qP ? (h_("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : g(e.selector) ? LP.select(e.selector) : w(e.target) ? [e.target] : [])(e)), Bt.each(i, (e => {
                                var n;
                                (n = t.get(e.id)) && n.initialized && !(n.getContainer() || n.getBody()).parentNode && (UP(n), n.unbindAllNativeEvents(), n.destroy(!0), n.removed = !0)
                            })), i = Bt.grep(i, (e => !t.get(e.id))), 0 === i.length ? r([]) : OP(i, (a => {
                                ((e, t) => e.inline && t.tagName.toLowerCase() in o)(e, a) ? h_("Could not initialize inline editor on invalid inline target element", a) : ((e, o, a) => {
                                    const l = new DP(e, o, t);
                                    s.push(l), l.on("init", (() => {
                                        ++n === i.length && r(s)
                                    })), l.targetElm = l.targetElm || a, l.render()
                                })((e => {
                                    let t = e.id;
                                    return t || (t = Se(e, "name").filter((e => !LP.get(e))).getOrThunk(LP.uniqueId), e.setAttribute("id", t)), t
                                })(a), e, a)
                            }))
                        };
                        return LP.bind(window, "ready", a), new Promise((e => {
                            n ? e(n) : r = t => {
                                e(t)
                            }
                        }))
                    },
                    get(e) {
                        return 0 === arguments.length ? IP.slice(0) : g(e) ? ee(IP, (t => t.id === e)).getOr(null) : S(e) && IP[e] ? IP[e] : null
                    },
                    add(e) {
                        const t = this, n = t.get(e.id);
                        return n === e || (null === n && IP.push(e), FP(!0), t.activeEditor = e, t.dispatch("AddEditor", {editor: e}), BP || (BP = e => {
                            const n = t.dispatch("BeforeUnload");
                            if (n.returnValue) return e.preventDefault(), e.returnValue = n.returnValue, n.returnValue
                        }, window.addEventListener("beforeunload", BP))), e
                    },
                    createEditor(e, t) {
                        return this.add(new DP(e, t, this))
                    },
                    remove(e) {
                        const t = this;
                        let n;
                        if (e) {
                            if (!g(e)) return n = e, b(t.get(n.id)) ? null : (UP(n) && t.dispatch("RemoveEditor", {editor: n}), 0 === IP.length && window.removeEventListener("beforeunload", BP), n.remove(), FP(IP.length > 0), n);
                            OP(LP.select(e), (e => {
                                n = t.get(e.id), n && t.remove(n)
                            }))
                        } else for (let e = IP.length - 1; e >= 0; e--) t.remove(IP[e])
                    },
                    execCommand(e, t, n) {
                        var o;
                        const r = this, a = p(n) ? null !== (o = n.id) && void 0 !== o ? o : n.index : n;
                        switch (e) {
                            case"mceAddEditor":
                                if (!r.get(a)) {
                                    const e = n.options;
                                    new DP(a, e, r).render()
                                }
                                return !0;
                            case"mceRemoveEditor": {
                                const e = r.get(a);
                                return e && e.remove(), !0
                            }
                            case"mceToggleEditor": {
                                const e = r.get(a);
                                return e ? (e.isHidden() ? e.show() : e.hide(), !0) : (r.execCommand("mceAddEditor", !1, n), !0)
                            }
                        }
                        return !!r.activeEditor && r.activeEditor.execCommand(e, t, n)
                    },
                    triggerSave: () => {
                        OP(IP, (e => {
                            e.save()
                        }))
                    },
                    addI18n: (e, t) => {
                        oi.add(e, t)
                    },
                    translate: e => oi.translate(e),
                    setActive(e) {
                        const t = this.activeEditor;
                        this.activeEditor !== e && (t && t.dispatch("deactivate", {relatedTarget: e}), e.dispatch("activate", {relatedTarget: t})), this.activeEditor = e
                    },
                    _setBaseUrl(e) {
                        this.baseURL = new pE(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new pE(this.baseURL)
                    }
                };
                jP.setup();
                const HP = (() => {
                    const e = si();
                    return {
                        FakeClipboardItem: e => ({items: e, types: ge(e), getType: t => Se(e, t).getOrUndefined()}),
                        write: t => {
                            e.set(t)
                        },
                        read: () => e.get().getOrUndefined(),
                        clear: e.clear
                    }
                })(), zP = Math.min, $P = Math.max, VP = Math.round, WP = (e, t, n) => {
                    let o = t.x, r = t.y;
                    const a = e.w, s = e.h, i = t.w, l = t.h, d = (n || "").split("");
                    return "b" === d[0] && (r += l), "r" === d[1] && (o += i), "c" === d[0] && (r += VP(l / 2)), "c" === d[1] && (o += VP(i / 2)), "b" === d[3] && (r -= s), "r" === d[4] && (o -= a), "c" === d[3] && (r -= VP(s / 2)), "c" === d[4] && (o -= VP(a / 2)), KP(o, r, a, s)
                }, KP = (e, t, n, o) => ({x: e, y: t, w: n, h: o}), YP = {
                    inflate: (e, t, n) => KP(e.x - t, e.y - n, e.w + 2 * t, e.h + 2 * n),
                    relativePosition: WP,
                    findBestRelativePosition: (e, t, n, o) => {
                        for (let r = 0; r < o.length; r++) {
                            const a = WP(e, t, o[r]);
                            if (a.x >= n.x && a.x + a.w <= n.w + n.x && a.y >= n.y && a.y + a.h <= n.h + n.y) return o[r]
                        }
                        return null
                    },
                    intersect: (e, t) => {
                        const n = $P(e.x, t.x), o = $P(e.y, t.y), r = zP(e.x + e.w, t.x + t.w),
                            a = zP(e.y + e.h, t.y + t.h);
                        return r - n < 0 || a - o < 0 ? null : KP(n, o, r - n, a - o)
                    },
                    clamp: (e, t, n) => {
                        let o = e.x, r = e.y, a = e.x + e.w, s = e.y + e.h;
                        const i = t.x + t.w, l = t.y + t.h, d = $P(0, t.x - o), c = $P(0, t.y - r), u = $P(0, a - i),
                            m = $P(0, s - l);
                        return o += d, r += c, n && (a += d, s += c, o -= u, r -= m), a -= u, s -= m, KP(o, r, a - o, s - r)
                    },
                    create: KP,
                    fromClientRect: e => KP(e.left, e.top, e.width, e.height)
                }, GP = (() => {
                    const e = {}, t = {}, n = {};
                    return {
                        load: (n, o) => {
                            const r = `Script at URL "${o}" failed to load`,
                                a = `Script at URL "${o}" did not call \`tinymce.Resource.add('${n}', data)\` within 1 second`;
                            if (void 0 !== e[n]) return e[n];
                            {
                                const s = new Promise(((e, s) => {
                                    const i = ((e, t, n = 1e3) => {
                                        let o = !1, r = null;
                                        const a = e => (...t) => {
                                            o || (o = !0, null !== r && (clearTimeout(r), r = null), e.apply(null, t))
                                        }, s = a(e), i = a(t);
                                        return {
                                            start: (...e) => {
                                                o || null !== r || (r = setTimeout((() => i.apply(null, e)), n))
                                            }, resolve: s, reject: i
                                        }
                                    })(e, s);
                                    t[n] = i.resolve, Qs.ScriptLoader.loadScript(o).then((() => i.start(a)), (() => i.reject(r)))
                                }));
                                return e[n] = s, s
                            }
                        }, add: (o, r) => {
                            void 0 !== t[o] && (t[o](r), delete t[o]), e[o] = Promise.resolve(r), n[o] = r
                        }, has: e => e in n, get: e => n[e], unload: t => {
                            delete e[t]
                        }
                    }
                })();
                let XP;
                try {
                    const e = "__storage_test__";
                    XP = window.localStorage, XP.setItem(e, e), XP.removeItem(e)
                } catch (e) {
                    XP = (() => {
                        let e = {}, t = [];
                        const n = {
                            getItem: t => e[t] || null, setItem: (n, o) => {
                                t.push(n), e[n] = String(o)
                            }, key: e => t[e], removeItem: n => {
                                t = t.filter((e => e === n)), delete e[n]
                            }, clear: () => {
                                t = [], e = {}
                            }, length: 0
                        };
                        return Object.defineProperty(n, "length", {
                            get: () => t.length,
                            configurable: !1,
                            enumerable: !1
                        }), n
                    })()
                }
                const JP = {
                    geom: {Rect: YP},
                    util: {
                        Delay: Yg,
                        Tools: Bt,
                        VK: Rf,
                        URI: pE,
                        EventDispatcher: rP,
                        Observable: sP,
                        I18n: oi,
                        LocalStorage: XP,
                        ImageUploader: e => {
                            const t = E_(), n = x_(e, t);
                            return {upload: (t, o = !0) => n.upload(t, o ? k_(e) : void 0)}
                        }
                    },
                    dom: {
                        EventUtils: qs,
                        TreeWalker: Ho,
                        TextSeeker: Ni,
                        DOMUtils: Xs,
                        ScriptLoader: Qs,
                        RangeUtils: mg,
                        Serializer: Ow,
                        StyleSheetLoader: Ha,
                        ControlSelection: Pf,
                        BookmarkManager: wf,
                        Selection: Nw,
                        Event: qs.Event
                    },
                    html: {Styles: Rs, Entities: is, Node: Ap, Schema: ys, DomParser: DE, Writer: Wp, Serializer: Kp},
                    Env: Rt,
                    AddOnManager: ri,
                    Annotator: Ef,
                    Formatter: q_,
                    UndoManager: H_,
                    EditorCommands: YB,
                    WindowManager: u_,
                    NotificationManager: l_,
                    EditorObservable: mP,
                    Shortcuts: xP,
                    Editor: DP,
                    FocusManager: Kg,
                    EditorManager: jP,
                    DOM: Xs.DOM,
                    ScriptLoader: Qs.ScriptLoader,
                    PluginManager: d_,
                    ThemeManager: c_,
                    ModelManager: Zw,
                    IconManager: Qw,
                    Resource: GP,
                    FakeClipboard: HP,
                    trim: Bt.trim,
                    isArray: Bt.isArray,
                    is: Bt.is,
                    toArray: Bt.toArray,
                    makeMap: Bt.makeMap,
                    each: Bt.each,
                    map: Bt.map,
                    grep: Bt.grep,
                    inArray: Bt.inArray,
                    extend: Bt.extend,
                    walk: Bt.walk,
                    resolve: Bt.resolve,
                    explode: Bt.explode,
                    _addCacheSuffix: Bt._addCacheSuffix
                }, QP = Bt.extend(jP, JP);
                (e => {
                    window.tinymce = e, window.tinyMCE = e
                })(QP), (t => {
                    try {
                        e.exports = t
                    } catch (e) {
                    }
                })(QP)
            }()
        }, 806: (e, t, n) => {
            var o = n(730), r = "ąàáäâãåæăćčĉęèéëêĝĥìíïîĵłľńňòóöőôõðøśșşšŝťțţŭùúüűûñÿýçżźž",
                a = "aaaaaaaaaccceeeeeghiiiijllnnoooooooossssstttuuuuuunyyczzz";
            r += r.toUpperCase(), a = (a += a.toUpperCase()).split(""), r += "ß", a.push("ss"), e.exports = function (e) {
                return o(e).replace(/.{1}/g, (function (e) {
                    var t = r.indexOf(e);
                    return -1 === t ? e : a[t]
                }))
            }
        }, 43: (e, t, n) => {
            var o = n(710);
            e.exports = function (e) {
                return o(e).replace(/([A-Z])/g, "-$1").replace(/[-_\s]+/g, "-").toLowerCase()
            }
        }, 520: (e, t, n) => {
            var o = n(871);
            e.exports = function (e) {
                return null == e ? "\\s" : e.source ? e.source : "[" + o(e) + "]"
            }
        }, 871: (e, t, n) => {
            var o = n(730);
            e.exports = function (e) {
                return o(e).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
            }
        }, 730: e => {
            e.exports = function (e) {
                return null == e ? "" : "" + e
            }
        }, 323: (e, t, n) => {
            var o = n(710), r = n(43), a = n(806);
            e.exports = function (e) {
                return o(r(a(e).replace(/[^\w\s-]/g, "-").toLowerCase()), "-")
            }
        }, 710: (e, t, n) => {
            var o = n(730), r = n(520), a = String.prototype.trim;
            e.exports = function (e, t) {
                return e = o(e), !t && a ? a.call(e) : (t = r(t), e.replace(new RegExp("^" + t + "+|" + t + "+$", "g"), ""))
            }
        }, 380: (e, t, n) => {
            var o = n(710);
            e.exports = function (e) {
                return o(e).replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase()
            }
        }
    }, t = {};

    function n(o) {
        var r = t[o];
        if (void 0 !== r) return r.exports;
        var a = t[o] = {exports: {}};
        return e[o](a, a.exports, n), a.exports
    }

    (() => {
        "use strict";

        function e(e, t) {
            window["__sfs_cms_".concat(e, "_registered")] || window.addEventListener("load", t), window["__sfs_cms_".concat(e, "_registered")] = !0
        }

        function t(e, t, n) {
            var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            document.addEventListener(t, (function (t) {
                if (e && t.target) {
                    if (t.target.matches(e)) return n(t.target, t);
                    for (var r = t.target; o > 0;) {
                        if (r.parentNode.matches(e)) return n(r.parentNode, t);
                        r = r.parentNode, o--
                    }
                }
            }))
        }

        function o(e, t) {
            document.querySelectorAll(e).forEach((function (e) {
                t(e)
            }))
        }

        HTMLElement.prototype.showElement = function () {
            return this.classList.remove("d-none", "hidden"), this
        }, HTMLElement.prototype.hideElement = function () {
            return this.classList.add("d-none", "hidden"), this
        };
        const r = bootstrap;

        function a(e) {
            return function (e) {
                if (Array.isArray(e)) return s(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return s(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function s(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function i(e) {
            return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            }, i(e)
        }

        function l(e) {
            return function (e) {
                if (Array.isArray(e)) return d(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return d(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? d(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function d(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function c(e, t) {
            for (var n = 0; n < t.length; n++) {
                var o = t[n];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, u(o.key), o)
            }
        }

        function u(e) {
            var t = function (e, t) {
                if ("object" != i(e) || !e) return e;
                var n = e[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var o = n.call(e, t || "default");
                    if ("object" != i(o)) return o;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === t ? String : Number)(e)
            }(e, "string");
            return "symbol" == i(t) ? t : t + ""
        }

        function m(e, t, n) {
            return t = h(t), function (e, t) {
                if (t && ("object" == i(t) || "function" == typeof t)) return t;
                if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                return function (e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(e)
            }(e, g() ? Reflect.construct(t, n || [], h(e).constructor) : t.apply(e, n))
        }

        function f(e) {
            var t = "function" == typeof Map ? new Map : void 0;
            return f = function (e) {
                if (null === e || !function (e) {
                    try {
                        return -1 !== Function.toString.call(e).indexOf("[native code]")
                    } catch (t) {
                        return "function" == typeof e
                    }
                }(e)) return e;
                if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== t) {
                    if (t.has(e)) return t.get(e);
                    t.set(e, n)
                }

                function n() {
                    return function (e, t, n) {
                        if (g()) return Reflect.construct.apply(null, arguments);
                        var o = [null];
                        o.push.apply(o, t);
                        var r = new (e.bind.apply(e, o));
                        return n && p(r, n.prototype), r
                    }(e, arguments, h(this).constructor)
                }

                return n.prototype = Object.create(e.prototype, {
                    constructor: {
                        value: n,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), p(n, e)
            }, f(e)
        }

        function g() {
            try {
                var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
                })))
            } catch (e) {
            }
            return (g = function () {
                return !!e
            })()
        }

        function p(e, t) {
            return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                return e.__proto__ = t, e
            }, p(e, t)
        }

        function h(e) {
            return h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
                return e.__proto__ || Object.getPrototypeOf(e)
            }, h(e)
        }

        window.addEventListener("load", (function (e) {
            var t = document.getElementById("mediaTypeModal");
            if (t) {
                var n = "";
                t.addEventListener("show.bs.modal", (function (e) {
                    t.clickedButton = e.relatedTarget;
                    var r = document.getElementById(t.clickedButton.dataset.mediaTypeField),
                        a = t.querySelector(".modal-body"), s = t.querySelector(".modal-footer");
                    t.querySelector("[data-media-type-select]").classList.add("disabled"), s.style.setProperty("display", "none"), a.innerHTML = '<div class="p-5 text-center"><div class="spinner-border text-secondary" role="status">\n  <span class="visually-hidden">Loading...</span>\n</div></div>';
                    r.getAttribute("data-media-type-types");
                    o(n = t.clickedButton.dataset.searchUrl)
                })), document.addEventListener("click", (function (e) {
                    e.target.matches("[data-media-modal-create-href]") && function (e) {
                        var n = t.querySelector(".modal-body"), o = t.querySelector(".modal-footer"),
                            r = new XMLHttpRequest;
                        r.onreadystatechange = function () {
                            4 === r.readyState && (n.innerHTML = r.response, o.style.setProperty("display", ""), s(e))
                        }, r.open("GET", e, !0), r.send()
                    }(e.target.dataset.mediaModalCreateHref)
                })), document.addEventListener("click", (function (e) {
                    if (e.target.matches(".modal-media .page-link")) return o(e.target.dataset.pageHref), e.preventDefault(), !1
                })), document.addEventListener("click", (function (e) {
                    var n = null;
                    if (e.target && e.target.hasAttribute("data-media-type")) n = e.target; else {
                        for (var o = 0; o < e.composedPath().length; o++) if (e.composedPath()[o] instanceof Element && e.composedPath()[o].matches("[data-media-type]")) {
                            n = e.composedPath()[o];
                            break
                        }
                        if (!n) return
                    }
                    t.querySelectorAll(".sfs-media-selected").forEach((function (e) {
                        e.classList.remove("sfs-media-selected")
                    })), n.classList.add("sfs-media-selected"), t.querySelector("[data-media-type-select]").classList.remove("disabled")
                })), document.addEventListener("dblclick", (function (e) {
                    var t = null;
                    if (e.target && e.target.hasAttribute("data-media-type")) t = e.target; else {
                        for (var n = 0; n < e.composedPath().length; n++) if (e.composedPath()[n] instanceof Element && e.composedPath()[n].matches("[data-media-type]")) {
                            t = e.composedPath()[n];
                            break
                        }
                        if (!t) return
                    }
                    i(t)
                })), document.addEventListener("click", (function (e) {
                    if (e.target && e.target.hasAttribute("data-media-type-select")) {
                        var n = t.querySelector(".sfs-media-selected");
                        n && i(n)
                    }
                })), document.addEventListener("click", (function (e) {
                    if (e.target && (e.target.hasAttribute("data-media-type-clean") || e.target.parentElement.hasAttribute("data-media-type-clean"))) {
                        var t;
                        t = e.target.hasAttribute("data-media-type-clean") ? e.target : e.target.parentElement;
                        var n = document.getElementById(t.dataset.mediaTypeField),
                            o = document.getElementById(t.dataset.mediaTypeField + "_widget"),
                            r = document.querySelector("[data-media-type-select-version][data-media-type-field=" + n.id + "]");
                        if (n.value = "", document.getElementById(t.dataset.mediaTypeField + "_text").innerHTML = "", r) {
                            r.innerHTML = "", r.nextElementSibling.innerHTML = "";
                            var a = document.getElementById(r.dataset.mediaVersionTypeField);
                            a.setAttribute("value", ""), a.value = ""
                        }
                        var s = document.getElementById(t.dataset.mediaTypeWidget).querySelector("[data-media-type-thumbnail]");
                        for (var i in s && (s.innerHTML = ""), n.dataset) i.match(/^(mediaImage|mediaVideo|mediaPicture|mediaVideoSet)/i) && delete n.dataset[i];
                        o.querySelector("[data-media-type-clean]").classList.add("disabled");
                        var l = o.querySelector("[data-media-type-select-version]");
                        l && l.classList.add("disabled"), n.dispatchEvent(new Event("sfs_media.unselected", {bubbles: !0}))
                    }
                })), document.addEventListener("click", (function (e) {
                    if (e.target && e.target.hasAttribute("data-media-version-value")) {
                        var t = e.target, n = t.closest("ul").previousElementSibling;
                        n.innerText = t.innerText;
                        var o = document.getElementById(n.dataset.mediaVersionTypeField);
                        o.setAttribute("value", t.mediaVersionValue), o.value = t.dataset.mediaVersionValue, o.dispatchEvent(new Event("sfs_media.select_version", {bubbles: !0}))
                    }
                })), document.addEventListener("change", (function (e) {
                    if (e.target.matches("#media_create_form__original_upload")) {
                        document.getElementById("media_create_form_name").value = e.target.files[0].name;
                        var t = document.getElementById("media_create_form__original_preview");
                        if (t && e.target.files.length > 0) {
                            var n = URL.createObjectURL(e.target.files[0]), o = document.createElement("img");
                            if (e.target.files[0].type.includes("video")) {
                                o = document.createElement("video");
                                var r = document.createElement("source");
                                r.src = n, r.type = e.target.files[0].type, o.append(r)
                            } else o.src = n;
                            o.classList.add("img-fluid"), t.innerHTML = "", t.appendChild(o)
                        }
                    }
                })), document.addEventListener("submit", (function (e) {
                    if (e.target && e.target.hasAttribute("data-spinner-onsubmit")) {
                        var t = e.target.querySelector('button[type="submit"]'), n = document.createElement("span");
                        n.classList.add("spinner-border", "spinner-border-sm"), n.setAttribute("role", "status"), n.setAttribute("aria-hidden", "true"), t.disabled = !0, t.prepend(n)
                    }
                })), document.addEventListener("click", (function (e) {
                    e.target && e.target.hasAttribute("data-cancel-create-media") && o(n)
                }))
            }

            function o(e) {
                var n = t.querySelector(".modal-body"), r = t.querySelector(".modal-footer"), s = new XMLHttpRequest;
                s.onreadystatechange = function () {
                    if (4 === s.readyState) {
                        n.innerHTML = s.response, r.style.setProperty("display", ""), t.querySelector("[data-media-type-select]").classList.add("disabled");
                        var e = n.querySelector("form");
                        e.onsubmit = function (t) {
                            t.preventDefault();
                            var n = a(new FormData(t.target).entries()).map((function (e) {
                                return "".concat(encodeURIComponent(e[0]), "=").concat(encodeURIComponent(e[1]))
                            })).join("&");
                            o(e.action + "?" + n)
                        }, document.querySelectorAll(".modal-media .page-link").forEach((function (e) {
                            e.dataset.pageHref = e.href, e.setAttribute("href", "#")
                        }))
                    }
                }, s.open("GET", e, !0), s.send()
            }

            function s(e) {
                var r = t.querySelector(".modal-body"), i = (t.querySelector(".modal-footer"), r.querySelector("form"));
                i.onsubmit = function (t) {
                    t.preventDefault();
                    var l = new FormData(i);
                    a(i.querySelectorAll("input[type=file]")).forEach((function (e) {
                        return l.append(e.attributes.name, e.files[0])
                    }));
                    var d = new XMLHttpRequest;
                    d.onreadystatechange = function () {
                        4 === d.readyState && (201 === d.status ? o(n) : (r.innerHTML = d.response, s(e)))
                    }, d.open("POST", e), d.send(l)
                }
            }

            function i(e) {
                var n, o = document.getElementById(t.clickedButton.dataset.mediaTypeField),
                    a = document.getElementById(t.clickedButton.dataset.mediaTypeField + "_widget"),
                    s = document.querySelector("[data-media-type-select-version][data-media-type-field=" + o.id + "]");
                for (var i in s && ((n = s.nextElementSibling).innerHTML = ""), o.dataset) i.match(/^(mediaImage|mediaVideo|mediaPicture|mediaVideoSet)/i) && delete o.dataset[i];
                for (var l in o.value = e.dataset.mediaId, o.dataset.mediaType = e.dataset.mediaType, e.dataset) if (l.match(/^(mediaImage|mediaVideo|mediaPicture|mediaVideoSet)/i) && (o.dataset[l] = e.dataset[l], s)) if (l.match(/^mediaImage/i)) {
                    var d = l.replace(/^mediaImage\-?/i, "");
                    d = d.charAt(0).toLowerCase() + d.slice(1), n.insertAdjacentHTML("beforeend", '<li><a class="dropdown-item" data-media-version-value="image#' + d + '" href="#">' + d + "</a></li>")
                } else if (l.match(/^mediaVideoSet/i)) {
                    var c = l.replace(/^mediaVideoSet\-?/i, "");
                    c = c.charAt(0).toLowerCase() + c.slice(1), n.insertAdjacentHTML("beforeend", '<li><a class="dropdown-item" data-media-version-value="videoSet#' + c + '" href="#">' + c + "</a></li>")
                } else if (l.match(/^mediaVideo/i)) {
                    var u = l.replace(/^mediaVideo\-?/i, "");
                    u = u.charAt(0).toLowerCase() + u.slice(1), n.insertAdjacentHTML("beforeend", '<li><a class="dropdown-item" data-media-version-value="video#' + u + '" href="#">' + u + "</a></li>")
                } else if (l.match(/^mediaPicture/i)) {
                    var m = l.replace(/^mediaPicture\-?/i, "");
                    m = m.charAt(0).toLowerCase() + m.slice(1), n.insertAdjacentHTML("beforeend", '<li><a class="dropdown-item" data-media-version-value="picture#' + m + '" href="#">' + m + "</a></li>")
                }
                s && n.children[0].children[0].click();
                document.getElementById(t.clickedButton.dataset.mediaTypeField + "_text").innerHTML = e.dataset.mediaName;
                var f = document.getElementById(t.clickedButton.dataset.mediaTypeWidget).querySelector("[data-media-type-thumbnail]");
                f && (o.dataset["mediaImage-_thumbnail"] ? f.innerHTML = o.dataset["mediaImage-_thumbnail"] : f.innerHTML = ""), r.Modal.getInstance(t).hide(), a.querySelector("[data-media-type-clean]").classList.remove("disabled");
                var g = a.querySelector("[data-media-type-select-version]");
                g && g.classList.remove("disabled"), o.dispatchEvent(new Event("sfs_media.selected", {bubbles: !0}))
            }
        }));
        var v, b = function (e) {
            function t(e, n) {
                var o;
                return function (e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (o = m(this, t, [e, {
                    bubbles: !0,
                    cancelable: !0
                }]))._originEvent = n, o._collection = void 0, o._position = void 0, o._node = void 0, o._prototypeName = void 0, o._prototype = void 0, o
            }

            return function (e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(e, "prototype", {writable: !1}), t && p(e, t)
            }(t, e), n = t, r = [{
                key: "create", value: function (e, n) {
                    var o = new t(e, n);
                    return void 0 !== n._collection && o.collection(n._collection), void 0 !== n._node && o.node(n._node), void 0 !== n._position && o.position(n._position), void 0 !== n._prototype && o.prototype(n._prototype), void 0 !== n._prototypeName && o.prototypeName(n._prototypeName), o
                }
            }], (o = [{
                key: "originEvent", value: function () {
                    return this._originEvent
                }
            }, {
                key: "collection", value: function (e) {
                    if (void 0 !== e && (this._collection = e), this._collection) return this._collection;
                    if (this.target) {
                        if (void 0 !== this.target.dataset.collectionTarget) return document.getElementById(this.target.dataset.collectionTarget);
                        if ("collection" === this.target.dataset.collection) return this.target;
                        var t = this.target.closest("[data-collection=collection]");
                        if (!t) throw new Error("Collection not found");
                        return t
                    }
                    throw new Error("This event does not have a target, and collection is not set")
                }
            }, {
                key: "position", value: function (e) {
                    if (void 0 !== e && (this._position = parseInt(e)), void 0 !== this._position) return this._position;
                    if (void 0 !== this.target.dataset.collectionInsertPosition) return parseInt(this.target.dataset.collectionInsertPosition);
                    var t = this.node();
                    return t && void 0 !== t.dataset.collectionIndex ? parseInt(t.dataset.collectionIndex) : null
                }
            }, {
                key: "node", value: function (e) {
                    return void 0 !== e && (this._node = e), void 0 !== this._node ? this._node : void 0 !== event.target.dataset.collectionNode ? document.getElementById(event.target.dataset.collectionNode) : event.target.closest("[data-collection=node]")
                }
            }, {
                key: "prototypeName", value: function (e) {
                    var t, n;
                    if (void 0 !== e && (this._prototypeName = e), this._prototypeName) return this._prototypeName;
                    if (void 0 !== this.target.dataset.prototypeName) return this.target.dataset.prototypeName;
                    if (void 0 !== this.target.dataset.collectionPrototypeName) return this.target.dataset.collectionPrototypeName;
                    if (void 0 !== (null === (t = this.collection()) || void 0 === t ? void 0 : t.dataset.prototypeName)) return this.collection().dataset.prototypeName;
                    if (void 0 !== (null === (n = this.collection()) || void 0 === n ? void 0 : n.dataset.collectionPrototypeName)) return this.collection().dataset.collectionPrototypeName;
                    throw new Error("This target does not contains data-collection-prototype-name or data-prototype-name attribute, neither was set")
                }
            }, {
                key: "prototype", value: function (e) {
                    var t, n;
                    if (void 0 !== e && (this._prototype = e), this._prototype) return this._prototype;
                    if (void 0 !== this.target.dataset.prototype) return this.target.dataset.prototype;
                    if (void 0 !== this.target.dataset.collectionPrototype) return this.target.dataset.collectionPrototype;
                    if (void 0 !== (null === (t = this.collection()) || void 0 === t ? void 0 : t.dataset.prototype)) return this.collection().dataset.prototype;
                    if (void 0 !== (null === (n = this.collection()) || void 0 === n ? void 0 : n.dataset.collectionPrototype)) return this.collection().dataset.collectionPrototype;
                    throw new Error("This target does not contains data-collection-prototype or data-prototype attribute, neither was set")
                }
            }]) && c(n.prototype, o), r && c(n, r), Object.defineProperty(n, "prototype", {writable: !1}), n;
            var n, o, r
        }(f(Event));

        function y(e) {
            if (e.target && e.target.matches("[data-collection=node]")) if (e.target.matches("[data-collection=node] input[type=radio]")) e.target.setAttribute("checked", e.target.checked ? "checked" : ""); else {
                if (!e.target.matches("[data-collection=node] input[type=checkbox]")) return e.target.matches("[data-collection=node] select") ? (l(e.target.options).forEach((function (e) {
                    return e.removeAttribute("selected")
                })), void e.target.options[e.target.selectedIndex].setAttribute("selected", "selected")) : void (e.target.matches("[data-collection=node] input") && e.target.setAttribute("value", e.target.value));
                e.target.setAttribute("checked", e.target.checked ? "checked" : "")
            }
        }

        function C(e) {
            var t = e.target;
            e.target && (e.target.hasAttribute("data-collection-action") || (t = e.target.closest("[data-collection-action]"))) && ("add" !== t.dataset.collectionAction ? "insert" !== t.dataset.collectionAction ? "delete" !== t.dataset.collectionAction ? "up" !== t.dataset.collectionAction ? "down" !== t.dataset.collectionAction ? "duplicate" !== t.dataset.collectionAction ? console.error("Invalid collection action: " + t.dataset.collectionAction + ". Valid options are: add, insert, delete, up, down, duplicate") : t.dispatchEvent(new b("collection.node.duplicate", e)) : t.dispatchEvent(new b("collection.node.down", e)) : t.dispatchEvent(new b("collection.node.up", e)) : t.dispatchEvent(new b("collection.node.delete", e)) : t.dispatchEvent(new b("collection.node.insert", e)) : t.dispatchEvent(new b("collection.node.add", e)))
        }

        function E(e) {
            e.preventDefault();
            var t = b.create("collection.node.add.before", e);
            t.node(null), e.target.dispatchEvent(t);
            var n = function (e, t, n) {
                var o = T(e), r = isNaN(o) ? 0 : o + 1, a = document.createElement("div");
                return a = e.appendChild(a), a.outerHTML = n.replace(new RegExp(t, "g"), r), e.querySelector([':scope > [data-collection-index="' + r + '"]'])
            }(t.collection(), t.prototypeName(), t.prototype()), o = b.create("collection.node.add.after", t);
            o.node(n), t.collection().dispatchEvent(o)
        }

        function w(e) {
            e.preventDefault();
            var t = b.create("collection.node.insert.before", e);
            e.target.dispatchEvent(t);
            var n = function (e, t, n, o) {
                var r = document.createElement("div"),
                    a = e.querySelector(':scope > [data-collection=node][data-collection-index="' + o + '"]');
                r = a ? e.insertBefore(r, a) : e.children.length > 0 ? e.insertBefore(r, e.children[e.children.length - 1]) : e.appendChild(r);
                return r.outerHTML = n.replace(new RegExp(t, "g"), o), e.querySelector([':scope > [data-collection-index="' + o + '"]'])
            }(t.collection(), t.prototypeName(), t.prototype(), t.position());
            if (n.nextElementSibling) for (var o = l(t.collection().querySelectorAll(":scope > [data-collection=node]")), r = o.indexOf(n) + 1; r < o.length; r++) R(o[r], 1);
            var a = b.create("collection.node.insert.after", t);
            a.node(n), t.collection().dispatchEvent(a)
        }

        function _(e) {
            e.preventDefault();
            var t = b.create("collection.node.delete.before", e);
            e.target.dispatchEvent(t), t.collection(t.collection()), function (e, t) {
                var n = t;
                for (; n = n.nextElementSibling;) n.matches("[data-collection=node]") && R(n, -1);
                t.remove()
            }(t.collection(), t.node());
            var n = b.create("collection.node.delete.after", t);
            n.collection().dispatchEvent(n)
        }

        function S(e) {
            e.preventDefault();
            var t = b.create("collection.node.up.before", e);
            e.target.dispatchEvent(t), t.collection(t.collection()), t.node(t.node()), function (e, t) {
                var n = l(e.querySelectorAll(":scope > [data-collection=node]")), o = n.indexOf(t);
                if (void 0 !== n[o - 1]) {
                    var r = n[o - 1];
                    r.parentNode.insertBefore(t, r), R(t, -1), R(r, 1)
                }
            }(t.collection(), t.node());
            var n = b.create("collection.node.up.after", t);
            t.collection().dispatchEvent(n)
        }

        function k(e) {
            e.preventDefault();
            var t = b.create("collection.node.down.before", e);
            e.target.dispatchEvent(t), t.collection(t.collection()), t.node(t.node()), function (e, t) {
                var n = l(e.querySelectorAll(":scope > [data-collection=node]")), o = n.indexOf(t);
                if (void 0 !== n[o + 1]) {
                    var r = n[o + 1];
                    t.parentNode.insertBefore(r, t), R(t, 1), R(r, -1)
                }
            }(t.collection(), t.node());
            var n = b.create("collection.node.down.after", t);
            t.collection().dispatchEvent(n)
        }

        function x(e) {
            e.preventDefault();
            var t = b.create("collection.node.duplicate.before", e);
            e.target.dispatchEvent(t), t.collection(t.collection()), t.node(t.node());
            var n = function (e, t) {
                var n = t.cloneNode(!0), o = t.nextElementSibling;
                o ? o.parentNode.insertBefore(n, o) : e.appendChild(n);
                return R(n, 1), n
            }(t.collection(), t.node());
            if (n.nextElementSibling) for (var o = l(t.collection().querySelectorAll(":scope > [data-collection=node]")), r = o.indexOf(n) + 1; r < o.length; r++) R(o[r], 1);
            var a = b.create("collection.node.duplicate.after", t);
            a.node(n), t.collection().dispatchEvent(a)
        }

        function A(e) {
            L(e.collection())
        }

        function N(e) {
            e.node().scrollIntoView({behavior: "smooth", block: "nearest", inline: "nearest"})
        }

        function T(e) {
            var t = e.querySelectorAll("[data-collection=node]");
            return t.length ? parseInt(t.item(t.length - 1).dataset.collectionIndex) : -1
        }

        function R(e, t) {
            var n = parseInt(e.dataset.collectionIndex), o = n + t;
            e.dataset.collectionIndex = o, e.setAttribute("data-collection-index", o), e.querySelectorAll("[data-collection=node-index]").forEach((function (e) {
                return e.innerHTML = o
            }));
            var r = e.getAttribute("id");
            e.setAttribute("id", D(e.getAttribute("id"), "_" + n, "_" + o));
            var a = e.getAttribute("id"), s = e.getAttribute("data-full-name");
            e.setAttribute("data-full-name", D(e.getAttribute("data-full-name"), "[" + n + "]", "[" + o + "]"));
            var i = e.getAttribute("data-full-name");
            e.innerHTML = e.innerHTML.replaceAll(r, a).replaceAll(s, i)
        }

        function D(e, t, n) {
            if (!e) return e;
            var o = e.lastIndexOf(t);
            return e.substr(0, o) + e.substr(o).replace(t, n)
        }

        function L(e) {
            var t = l(e.querySelectorAll(":scope > [data-collection=node] [data-collection=node] [data-collection-action=up]")),
                n = l(e.querySelectorAll(":scope > [data-collection=node] [data-collection-action=up]")).filter((function (e) {
                    return !t.includes(e)
                }));
            n.forEach((function (e) {
                return e.classList.remove("d-none")
            })), n.length > 0 && n[0].classList.add("d-none");
            var o = l(e.querySelectorAll(":scope > [data-collection=node] [data-collection=node] [data-collection-action=down]")),
                r = l(e.querySelectorAll(":scope > [data-collection=node] [data-collection-action=down]")).filter((function (e) {
                    return !o.includes(e)
                }));
            r.forEach((function (e) {
                return e.classList.remove("d-none")
            })), r.length > 0 && r[r.length - 1].classList.add("d-none")
        }

        function O() {
            document.querySelectorAll("[data-edit-config-error]").forEach((function (e) {
                return console.error(e.dataset.editConfigError)
            }))
        }

        function B(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            document.addEventListener(e, (function (e) {
                if (e.target && (!o || e.target.matches(o))) {
                    var r = e.target.closest(".cms-module");
                    if (r) {
                        var a = r.closest("[data-collection=node]");
                        if (a && (!n || n === a.dataset.moduleId)) {
                            var s = e.target.closest(".cms-module-edit").querySelector(".module-preview"),
                                i = e.target.closest(".cms-module-edit").querySelector(".cms-module-form");
                            return t(e.target, r, s, i, e)
                        }
                    }
                }
            }))
        }

        function P(e, t, n) {
            B(t, n, null, e)
        }

        function I(e, t, n, o, r) {
            if ("Enter" === r.key) if (r.ctrlKey) e.innerHTML += "<br/>"; else {
                t = e.closest("[data-collection=node]");
                var a = e.closest("[data-collection=collection]"),
                    s = document.getElementById("module_prototypes_collection_modal").querySelector("[data-collection-action=insert][data-module-id=" + e.dataset.editContentEnterInsertsModule + "]");
                if (s) return s.dataset.collectionTarget = a.id, s.dataset.collectionInsertPosition = "" + (parseInt(t.dataset.collectionIndex) + 1), s.click(), r.preventDefault(), !1;
                console.error("Module " + e.dataset.editContentEnterInsertsModule + " not found. Check data-edit-content-enter-inserts-module attribute")
            }
        }

        function M(e, t, n, o, r) {
            var a, s, i;
            if ("Tab" === r.key) return r.preventDefault(), a = e.ownerDocument.defaultView.getSelection(), s = a.getRangeAt(0), i = document.createTextNode("    "), s.insertNode(i), s.setStartAfter(i), s.setEndAfter(i), a.removeAllRanges(), a.addRange(s), !0
        }

        function F(e, t, n, o, r) {
            var a, s, i;
            if ("Tab" === r.key) return r.preventDefault(), s = (a = e).selectionStart, i = a.selectionEnd, a.value = a.value.substring(0, s) + "\t" + a.value.substring(i), a.selectionStart = a.selectionEnd = s + 1, !0
        }

        function U(e) {
            document.querySelectorAll("[data-cms-module-site-filter][value=" + e + "]").forEach((function (e) {
                var t = e.checked, n = e.closest(".cms-module-edit").querySelector(".module-preview");
                t ? n.classList.remove("cms-module-site-hidden") : n.classList.add("cms-module-site-hidden")
            }))
        }

        function q() {
            var e = document.getElementById("contentEditionLanguageSelection");
            return null != e && e.length ? e.value : null
        }

        function j() {
            var e, t, n = document.getElementById("contentEditionLanguageSelection"),
                o = document.getElementById("contentEditionSiteSelection");
            (n || o) && (e = q(), t = function () {
                var e = document.getElementById("contentEditionSiteSelection");
                return null != e && e.length ? e.value : null
            }(), e && t ? (document.querySelectorAll("[data-lang][data-site]").forEach((function (e) {
                return e.style.setProperty("display", "none")
            })), document.querySelectorAll("[data-lang=" + e + "][data-site=" + t + "]").forEach((function (e) {
                return e.style.setProperty("display", "")
            })), document.querySelectorAll("[data-site]:not([data-lang])").forEach((function (e) {
                return e.style.setProperty("display", "none")
            })), document.querySelectorAll("[data-site=" + t + "]:not([data-lang])").forEach((function (e) {
                return e.style.setProperty("display", "")
            })), document.querySelectorAll("[data-lang]:not([data-site])").forEach((function (e) {
                return e.style.setProperty("display", "none")
            })), document.querySelectorAll("[data-lang=" + e + "]:not([data-site])").forEach((function (e) {
                return e.style.setProperty("display", "")
            }))) : e ? (document.querySelectorAll("[data-lang]").forEach((function (e) {
                return e.style.setProperty("display", "none")
            })), document.querySelectorAll("[data-lang=" + e + "]").forEach((function (e) {
                return e.style.setProperty("display", "")
            }))) : t && (document.querySelectorAll("[data-site]").forEach((function (e) {
                return e.style.setProperty("display", "none")
            })), document.querySelectorAll("[data-site=" + t + "]").forEach((function (e) {
                return e.style.setProperty("display", "")
            }))), document.querySelectorAll("[data-edit-content-hide-if-empty]:empty").forEach((function (e) {
                return e.style.setProperty("display", "none")
            })))
        }

        function H(e) {
            document.getElementById("contentEditionLanguageSelection").value = e.getAttribute("data-input-lang"), j()
        }

        function z(e) {
            var t = $();
            if (t) {
                var n = e;
                if (n.value === t.value) {
                    var o = n.checked, r = n.closest(".cms-module-edit").querySelector(".module-preview");
                    o ? r.classList.remove("cms-module-locale-hidden") : r.classList.add("cms-module-locale-hidden")
                }
            }
        }

        function $() {
            return document.getElementById("contentEditionLanguageSelection")
        }

        function V(e) {
            o("[data-cms-module-locale-filter][value=" + e + "]", W)
        }

        function W(e) {
            var t = e.checked, n = e.closest(".cms-module-edit").querySelector(".module-preview");
            t ? n.classList.remove("cms-module-locale-hidden") : n.classList.add("cms-module-locale-hidden")
        }

        function K(e) {
            return function (e) {
                if (Array.isArray(e)) return Y(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return Y(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Y(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Y(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function G(e) {
            X(), e.classList.add("active"), document.getElementById("content-form").classList.remove("d-none"), e.closest("div").querySelector(".active >.cms-module-body > .cms-module-edit > .cms-module-form") && document.querySelectorAll("[data-collection=collection]").forEach((function (e) {
                return e.classList.add("has-form")
            }))
        }

        function X() {
            document.getElementById("content-form").classList.add("d-none"), document.querySelectorAll(".cms-module").forEach((function (e) {
                return e.classList.remove("active")
            })), document.querySelectorAll("[data-collection=collection]").forEach((function (e) {
                return e.classList.remove("has-form")
            }))
        }

        function J() {
            var e = document.querySelectorAll("input, textarea, select").length,
                t = document.querySelectorAll("#submitBtnGroupDrop1,#defaultSubmitBtn"),
                n = document.getElementById("maxInputVarsMessage");
            n && (e > n.dataset.maxInputVars ? (K(t).forEach((function (e) {
                return e.classList.add("disabled")
            })), n.classList.remove("d-none")) : (K(t).forEach((function (e) {
                return e.classList.remove("disabled")
            })), n.classList.add("d-none")))
        }

        function Q(e, t, n) {
            var o = n.querySelectorAll("[data-edit-bgcolor-target='" + e.dataset.editBgcolorInput + "']");
            o.length && o.forEach((function (t) {
                return t.style.backgroundColor = e.value
            }))
        }

        function Z(e) {
            return function (e) {
                if (Array.isArray(e)) return ee(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return ee(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ee(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function ee(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function te(e, t, n) {
            var o = n.querySelectorAll("[data-block-preview-target='" + e.dataset.blockPreviewInput + "']"),
                r = e.options[e.selectedIndex].dataset.blockPreview;
            Z(o).forEach((function (e) {
                return e.innerHTML = void 0 === r ? "" : r
            }))
        }

        function ne(e) {
            return function (e) {
                if (Array.isArray(e)) return oe(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return oe(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? oe(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function oe(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function re(e, t, n, o) {
            var r = n.querySelectorAll("[data-edit-class-target='" + e.dataset.editClassInput + "']"),
                a = o.querySelectorAll("[data-edit-class-input='" + e.dataset.editClassInput + "']"), s = "";
            ne(a).forEach((function (e) {
                s = e.value + " " + s
            })), ne(r).forEach((function (e) {
                e.className = e.dataset.editClassDefault + " " + s
            }))
        }

        function ae(e) {
            return function (e) {
                if (Array.isArray(e)) return se(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return se(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? se(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function se(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function ie(e) {
            var t = e.closest(".cms-module-edit").querySelector(".module-preview").nextElementSibling.querySelector("input[type=text][data-edit-collection-node-class='" + e.dataset.editCollectionNodeClass + "']"),
                n = t.parentElement.parentElement;
            e.value ? n.classList.add("d-none") : (n.classList.remove("d-none"), t.value || (t.value = "col", t.setAttribute("value", "col")))
        }

        function le(e) {
            return function (e) {
                if (Array.isArray(e)) return de(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return de(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? de(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function de(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function ce(e) {
            return le(e.closest(".cms-module-edit").querySelector(".cms-module-form").querySelectorAll("[data-edit-content-input='" + e.dataset.editContentTarget + "']"))
        }

        function ue(e) {
            return le(e.closest(".cms-module-edit").querySelector(".module-preview").querySelectorAll("[data-edit-content-target='" + e.dataset.editContentInput + "']"))
        }

        function me(e) {
            ce(e).forEach((function (t) {
                e.dataset.editContentEscape && "false" !== e.dataset.editContentEscape ? t.value = e.innerText : t.value = e.innerHTML, t.setAttribute("value", e.innerHTML)
            })), e.dataset.editContentHideIfEmpty && ("" === e.innerHTML ? e.style.setProperty("display", "none") : e.matches("[data-lang=" + q() + "]") && e.style.setProperty("display", ""))
        }

        function fe(e, t, n) {
            var o = n.querySelectorAll("[data-edit-id-target='" + e.dataset.editIdInput + "']");
            o.length && o.forEach((function (t) {
                return t.id = e.value
            }))
        }

        function ge(e, t) {
            return function (e) {
                if (Array.isArray(e)) return e
            }(e) || function (e, t) {
                var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                if (null != n) {
                    var o, r, a, s, i = [], l = !0, d = !1;
                    try {
                        if (a = (n = n.call(e)).next, 0 === t) {
                            if (Object(n) !== n) return;
                            l = !1
                        } else for (; !(l = (o = a.call(n)).done) && (i.push(o.value), i.length !== t); l = !0) ;
                    } catch (e) {
                        d = !0, r = e
                    } finally {
                        try {
                            if (!l && null != n.return && (s = n.return(), Object(s) !== s)) return
                        } finally {
                            if (d) throw r
                        }
                    }
                    return i
                }
            }(e, t) || he(e, t) || function () {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function pe(e) {
            return function (e) {
                if (Array.isArray(e)) return ve(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || he(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function he(e, t) {
            if (e) {
                if ("string" == typeof e) return ve(e, t);
                var n = {}.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ve(e, t) : void 0
            }
        }

        function ve(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function be(e) {
            e.matches("[data-media-preview-placeholder]") && "" === e.innerHTML.trim() && (e.innerHTML = '<img class="img-fluid" data-media-placeholder src="' + e.dataset.mediaPreviewPlaceholder + '">')
        }

        window.__sfs_collection_form_type_registered || window.addEventListener("load", (document.addEventListener("change", y), document.addEventListener("click", C), document.addEventListener("collection.node.add", E), document.addEventListener("collection.node.insert", w), document.addEventListener("collection.node.delete", _), document.addEventListener("collection.node.up", S), document.addEventListener("collection.node.down", k), document.addEventListener("collection.node.duplicate", x), document.addEventListener("collection.node.add.after", A), document.addEventListener("collection.node.insert.after", A), document.addEventListener("collection.node.delete.after", A), document.addEventListener("collection.node.up.after", A), document.addEventListener("collection.node.down.after", A), document.addEventListener("collection.node.duplicate.after", A), document.addEventListener("collection.node.add.after", N), document.addEventListener("collection.node.insert.after", N), document.addEventListener("collection.node.duplicate.after", N), void document.querySelectorAll("[data-collection=collection]").forEach((function (e) {
            return L(e)
        })))), window.__sfs_collection_form_type_registered = !0, e("admin_content_edit_config_errors", (function () {
            document.addEventListener("collection.node.add.after", O), document.addEventListener("collection.node.insert.after", O), O()
        })), e("admin_content_edit_content_enter_inserts_module", (function () {
            P("[data-edit-content-enter-inserts-module]", "keydown", I)
        })), e("admin_content_edit_content_tab_contenteditable", (function () {
            P("[contenteditable=true]", "keydown", M), P("input[data-allow-tabs],textarea[data-allow-tabs]", "keydown", F)
        })), e("admin_content_edit_site_filter_modules", (function () {
            var e = document.getElementById("contentEditionSiteSelection");
            document.addEventListener("click", (function (t) {
                if (t.target && t.target.hasAttribute("data-cms-module-site-filter")) {
                    var n = t.target;
                    if (n.value === e.value) {
                        var o = n.checked, r = n.closest(".cms-module-edit").querySelector(".module-preview");
                        o ? r.classList.remove("cms-module-site-hidden") : r.classList.add("cms-module-site-hidden")
                    }
                }
            })), e && (e.addEventListener("change", (function (e) {
                U(e.target.value)
            })), U(e.value))
        })), e("admin_content_edit_filter_preview", (function () {
            var e = document.getElementById("contentEditionLanguageSelection"),
                t = document.getElementById("contentEditionSiteSelection");
            e && e.addEventListener("change", j), t && t.addEventListener("change", j), j()
        })), e("admin_content_edit_locale_filter_modules", (function () {
            P("[data-cms-module-locale-filter]", "click", z);
            var e = $();
            e && (e.addEventListener("change", (function (e) {
                V(e.target.value)
            })), V(e.value));
            P("[data-input-lang]", "focusin", H)
        })), e("admin_content_edit_modules", (function () {
            document.addEventListener("click", (function (e) {
                e.target && e.target.hasAttribute("data-cms-module-form-close") && (e.preventDefault(), e.stopPropagation(), X())
            })), document.addEventListener("click", (function (e) {
                if (e.target && (e.target.hasAttribute("data-cms-module-form-close") || e.target.matches("[data-collection-action=delete]"))) e.target.matches("[data-collection-action=delete]") && X(); else for (var t = 0; t < e.composedPath().length; t++) if (e.composedPath()[t] instanceof Element && e.composedPath()[t].matches(".cms-module")) return void G(e.composedPath()[t])
            })), document.addEventListener("collection.node.insert.after", (function (e) {
                var t = e.target.querySelector(".cms-module");
                t && G(t), j()
            })), document.addEventListener("collection.node.add.after", (function (e) {
                var t = e.target.querySelector(".cms-module");
                t && G(t), j()
            })), document.addEventListener("collection.node.duplicate.after", (function (e) {
                var t = e.target.querySelector(".cms-module");
                t && G(t), j()
            }));
            var e, t, n, o = document.getElementById("module_prototypes_collection_modal");
            o && o.addEventListener("show.bs.modal", (function (r) {
                (n = r.relatedTarget).classList.add("selected"), e = void 0 !== n.dataset.collectionTarget ? document.getElementById(n.dataset.collectionTarget) : n.closest("[data-collection=collection]");
                var a = n.closest("[data-collection=node]"), s = e.dataset.modulesAllowed.split(",");
                t = null, (n.matches("[data-collection-position=after]") || n.matches("[data-collection-position=before]")) && (t = a ? a.dataset.collectionIndex : null), o.querySelectorAll("[data-module-id]").forEach((function (e) {
                    return s.includes(e.dataset.moduleId) ? e.parentElement.classList.remove("d-none") : e.parentElement.classList.add("d-none")
                })), o.querySelectorAll(".modal-modules-group").forEach((function (e) {
                    e.querySelectorAll(".modal-module:not(.d-none)").length ? e.classList.remove("d-none") : e.classList.add("d-none")
                }))
            })), o && o.addEventListener("hide.bs.modal", (function () {
                K(document.getElementsByClassName("insert-module")).forEach((function (e) {
                    return e.classList.remove("selected")
                }))
            })), document.addEventListener("collection.node.insert.before", (function (n) {
                var a;
                if (e) n.collection(e), n.position(null !== t ? t : T(e) + 1); else {
                    if (!n.target || void 0 === n.target.dataset.collectionTarget) throw new Error("No collection target found for module");
                    e = document.getElementById(n.target.dataset.collectionTarget)
                }
                var s = n._originEvent.target,
                    i = null !== (a = s.dataset.prototype) && void 0 !== a ? a : s.dataset.collectionPrototype;
                i = (i = i.replace(new RegExp("version_create_form_module_prototypes_collection", "g"), e.id)).replace(new RegExp("version_create_form\\[module_prototypes_collection\\]", "g"), e.dataset.fullName), n.prototype(i), e = null, t = null;
                var l = r.Modal.getInstance(o);
                l && l.hide()
            })), document.addEventListener("collection.node.insert.after", (function (e) {
                var t;
                if (e.collection() && e.node() && void 0 !== e.collection().dataset.moduleRowClass) {
                    if ((t = e.node().classList).remove.apply(t, K(e.node().classList)), e.node().classList.add(e.collection().dataset.moduleRowClass), "col" == e.collection().dataset.moduleRowClass) {
                        var n = e.node().querySelector(":scope > .cms-module > .cms-module-header > .cms-module-buttons > [data-collection-action=down] .bi-chevron-down");
                        n.classList.remove("bi-chevron-down"), n.classList.add("bi-chevron-right");
                        var a = e.node().querySelector(":scope > .cms-module > .cms-module-header > .cms-module-buttons > [data-collection-action=up] .bi-chevron-up");
                        a.classList.remove("bi-chevron-up"), a.classList.add("bi-chevron-left")
                    }
                    var s = r.Modal.getInstance(o);
                    s && s.hide(), G(e.node().querySelector(".cms-module"));
                    var i = e.node().querySelector("[contenteditable]");
                    i && i.focus()
                }
            })), document.addEventListener("collection.node.delete.after", J), document.addEventListener("collection.node.insert.after", J), document.addEventListener("collection.node.add.after", J), document.addEventListener("collection.node.duplicate.after", J)
        })), e("admin_content_edit_preview_background_color", (function () {
            P("[data-edit-bgcolor-input]", "input", Q)
        })), e("admin_content_edit_preview_block", (function () {
            P("[data-block-preview-input]", "change", te)
        })), e("admin_content_edit_preview_class", (function () {
            P("[data-edit-class-input]", "input", re)
        })), e("admin_content_edit_preview_collection_node_class", (function () {
            document.addEventListener("input", (function (e) {
                if (e.target && e.target.hasAttribute("data-edit-collection-node-class")) {
                    var t = e.target.value, n = e.target.closest(".cms-module-edit").querySelector(".module-preview"),
                        o = n.nextElementSibling.querySelector("input[type=text][data-edit-collection-node-class='" + e.target.dataset.editCollectionNodeClass + "']");
                    "SELECT" == e.target.nodeName && e.target.value && o.value && (o.value = "", o.setAttribute("value", "")), t || (o.value || (o.value = "col", o.setAttribute("value", "col")), t = o.value);
                    var r = n.querySelectorAll("[data-edit-collection-node-class-target='" + e.target.dataset.editCollectionNodeClass + "'] > [data-collection=collection]");
                    r.length && r.forEach((function (e) {
                        e.setAttribute("data-module-row-class", t), ae(e.querySelectorAll(":scope > [data-collection=node]")).forEach((function (e) {
                            return e.setAttribute("class", t)
                        })), ae(e.querySelectorAll(":scope > .insert-module-at-the-end")).forEach((function (e) {
                            return e.setAttribute("class", "insert-module-at-the-end " + t)
                        }))
                    }))
                }
            })), document.addEventListener("change", (function (e) {
                e.target && e.target.hasAttribute("data-edit-collection-node-class") && "SELECT" == e.target.nodeName && ie(e.target)
            })), ae(document.querySelectorAll("select[data-edit-collection-node-class]")).forEach((function (e) {
                return ie(e)
            }))
        })), e("admin_content_edit_contenteditable", (function () {
            v = !1, document.addEventListener("input", (function (e) {
                e.target && e.target.hasAttribute("data-edit-content-input") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.content_editable.input.change", {bubbles: !0}))), e.target && e.target.hasAttribute("data-edit-content-target") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.content_editable.target.change", {bubbles: !0})))
            })), document.addEventListener("sfs_cms.content_edit.content_editable.input.change", (function (e) {
                var t;
                e.preventDefault(), ue(t = e.target).forEach((function (e) {
                    var n = t.value;
                    if (e.dataset.editContentValidate) switch (e.dataset.editContentValidate) {
                        case"html":
                            n = function (e, t) {
                                var n = e.value, o = "<body>" + n + "</body>";
                                o = o.replace(new RegExp(/\n/, "g"), "");
                                var r = (new DOMParser).parseFromString(o, "application/xml").querySelector("parsererror");
                                return r ? (n = r.innerText, t.classList.add("text-error"), t.classList.add("border"), t.classList.add("border-danger")) : (t.classList.remove("text-error"), t.classList.remove("border"), t.classList.remove("border-danger")), n
                            }(t, e);
                            break;
                        case"css":
                            v || (console.warn("Sorry, css code is not yet validated"), v = !0)
                    }
                    e.dataset.editContentEscape ? e.innerText = n : (n = n.replace(new RegExp("href", "g"), "href-invalidate"), e.innerHTML = n), e.dataset.editContentHideIfEmpty && ("" === e.innerHTML ? e.style.setProperty("display", "none") : e.matches("[data-lang=" + q() + "]") && e.style.setProperty("display", ""))
                }))
            })), document.addEventListener("sfs_cms.content_edit.content_editable.target.change", (function (e) {
                e.preventDefault(), me(e.target)
            })), o("[data-edit-content-hide-if-empty]:empty", (function (e) {
                return e.style.setProperty("display", "none")
            }))
        })), e("admin_content_edit_contenteditable_focus", (function () {
            document.addEventListener("focusin", (function (e) {
                e.target && e.target.hasAttribute("data-edit-content-input") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.content_editable.input.focus", {bubbles: !0}))), e.target && e.target.hasAttribute("data-edit-content-target") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.content_editable.target.focus", {bubbles: !0})))
            })), document.addEventListener("focusout", (function (e) {
                e.target && e.target.hasAttribute("data-edit-content-input") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.content_editable.input.blur", {bubbles: !0}))), e.target && e.target.hasAttribute("data-edit-content-target") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.content_editable.target.blur", {bubbles: !0})))
            })), document.addEventListener("sfs_cms.content_edit.content_editable.target.focus", (function (e) {
                e.preventDefault(), function (e) {
                    var t = ce(e);
                    if (!t.length) return;
                    t[0].classList.add("border", "border-success");
                    var n = t[0].closest(".accordion-item").querySelector(".accordion-button.collapsed");
                    n && n.click(), t[0].closest(".accordion-item").scrollIntoView({behavior: "smooth", block: "end"})
                }(e.target)
            })), document.addEventListener("sfs_cms.content_edit.content_editable.target.blur", (function (e) {
                e.preventDefault(), function (e) {
                    var t = ce(e);
                    if (!t.length) return;
                    t[0].classList.remove("border", "border-success")
                }(e.target)
            })), document.addEventListener("sfs_cms.content_edit.content_editable.input.focus", (function (e) {
                e.preventDefault(), function (e) {
                    var t = ue(e);
                    if (!t.length) return;
                    t.map((function (e) {
                        return e.classList.add("border", "border-success")
                    }))
                }(e.target)
            })), document.addEventListener("sfs_cms.content_edit.content_editable.input.blur", (function (e) {
                e.preventDefault(), function (e) {
                    var t = ue(e);
                    if (!t.length) return;
                    t.map((function (e) {
                        return e.classList.remove("border", "border-success")
                    }))
                }(e.target)
            })), [].slice.call(document.querySelectorAll(".collapse")).map((function (e) {
                e.addEventListener("shown.bs.collapse", (function () {
                    this.scrollIntoView({behavior: "smooth", block: "end"})
                }))
            }))
        })), e("admin_content_edit_preview_fill", (function () {
            var e = function (e) {
                return e.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (function (e, t) {
                    return (t ? "-" : "") + e.toLowerCase()
                }))
            };
            document.addEventListener("change", (function (t) {
                if (t.target) {
                    var n = t.target.closest(".cms-module-edit");
                    if (n) Object.keys(t.target.dataset).forEach((function (o) {
                        if (o.startsWith("editFillInput")) {
                            var r = o.replace("editFillInput", ""), a = e(r), s = t.target.dataset[o], i = e(s),
                                l = null == t.target.options ? t.target : t.target.options[t.target.selectedIndex],
                                d = n.querySelectorAll("[data-edit-fill-target-" + a + "]");
                            d.length && d.forEach((function (e) {
                                var t = l.getAttribute("data-" + i);
                                e.hasAttribute("data-lang") && l.hasAttribute("data-" + i + "-" + e.dataset.lang) && (t = l.getAttribute("data-" + i + "-" + e.dataset.lang)), e.hasAttribute("data-input-lang") && l.hasAttribute("data-" + i + "-" + e.dataset.inputLang) && (t = l.getAttribute("data-" + i + "-" + e.dataset.inputLang)), "INPUT" === e.tagName ? (e.value = t, e.dispatchEvent(new Event("change", {bubbles: !0}))) : e.innerHTML = t
                            }))
                        }
                    }))
                }
            }))
        })), e("admin_content_edit_preview_id", (function () {
            P("[data-edit-id-input]", "input", fe)
        })), e("admin_content_edit_preview_media_choice", (function () {
            document.addEventListener("change", (function (e) {
                var t, n;
                e.target && e.target.hasAttribute("data-media-preview-input") && (t = e.target, (n = t.closest(".cms-module-edit").querySelector(".module-preview").querySelectorAll("[data-media-preview-target='" + t.dataset.mediaPreviewInput + "']")).length && (t.options[t.selectedIndex].dataset.mediaPreviewPicture ? n.forEach((function (e) {
                    return e.innerHTML = t.options[t.selectedIndex].dataset.mediaPreviewPicture
                })) : t.options[t.selectedIndex].dataset.mediaPreviewImage ? n.forEach((function (e) {
                    return e.innerHTML = t.options[t.selectedIndex].dataset.mediaPreviewImage
                })) : t.options[t.selectedIndex].dataset.mediaPreviewVideo ? n.forEach((function (e) {
                    return e.innerHTML = t.options[t.selectedIndex].dataset.mediaPreviewVideo
                })) : n.forEach((function (e) {
                    return e.innerHTML = ""
                }))))
            }))
        })), e("admin_content_edit_preview_media_modal", (function () {
            document.addEventListener("sfs_media.selected", (function (e) {
                e.target && e.target.hasAttribute("data-media-preview-input") && function (e) {
                    var t = e.closest(".cms-module-edit").querySelector(".module-preview"),
                        n = JSON.parse(e.dataset.mediaTypeConfig), o = null;
                    if (void 0 === e.dataset.mediaVersionTypeField) {
                        var r = null;
                        n[e.dataset.mediaType].image ? (r = n[e.dataset.mediaType].image[0], o = "_original" === r ? e.dataset["mediaImage-_original"] : e.dataset["mediaImage-" + r.charAt(0).toUpperCase() + r.slice(1)]) : n[e.dataset.mediaType].video ? r = n[e.dataset.mediaType].video[0] : n[e.dataset.mediaType].picture ? r = n[e.dataset.mediaType].picture[0] : n[e.dataset.mediaType].videoSet && (r = n[e.dataset.mediaType].videoSet[0]), pe(t.querySelectorAll("[data-media-preview-target='" + e.dataset.mediaPreviewInput + "']")).forEach((function (e) {
                            return e.innerHTML = o || ""
                        }))
                    }
                }(e.target)
            })), document.addEventListener("sfs_media.select_version", (function (e) {
                e.target && function (e) {
                    var t = e.closest(".cms-module-edit").querySelector(".module-preview"),
                        n = document.getElementById(e.dataset.mediaTypeField), o = null, r = ge(e.value.split("#"), 2),
                        a = r[0], s = r[1];
                    switch (s = "_" === s.charAt(0) ? "-" + s : s.charAt(0).toUpperCase() + s.slice(1), a) {
                        case"image":
                            o = n.dataset["mediaImage" + s];
                            break;
                        case"video":
                            o = n.dataset["mediaVideo" + s];
                            break;
                        case"picture":
                            o = n.dataset["mediaPicture" + s];
                            break;
                        case"videoSet":
                            o = n.dataset["mediaVideoSet" + s]
                    }
                    pe(t.querySelectorAll("[data-media-preview-target='" + n.dataset.mediaPreviewInput + "']")).forEach((function (e) {
                        return e.innerHTML = o || ""
                    }))
                }(e.target)
            })), document.addEventListener("sfs_media.unselected", (function (e) {
                var t;
                e.target && e.target.hasAttribute("data-media-preview-input") && pe((t = e.target).closest(".cms-module-edit").querySelector(".module-preview").querySelectorAll("[data-media-preview-target='" + t.dataset.mediaPreviewInput + "']")).forEach((function (e) {
                    return be(e)
                }))
            })), document.querySelectorAll("[data-media-preview-target]").forEach((function (e) {
                be(e)
            })), document.addEventListener("click", (function (e) {
                e.target && e.target.hasAttribute("data-media-placeholder") && document.querySelector('[data-media-preview-input="' + e.target.closest("[data-media-preview-target]").dataset.mediaPreviewTarget + '"]').closest(".media-widget").querySelector('[data-bs-toggle="modal"]').click()
            }))
        })), e("admin_content_edit_preview_tag_type", (function () {
            document.addEventListener("change", (function (e) {
                if (e.target && e.target.hasAttribute("data-edit-tag-type-input")) {
                    e.preventDefault();
                    var t = e.target.closest(".cms-module-edit").querySelector(".module-preview").querySelectorAll("[data-edit-tag-type-target='" + e.target.dataset.editTagTypeInput + "']");
                    t.length && t.forEach((function (t) {
                        t.outerHTML = t.outerHTML.trim().replace("<" + t.nodeName.toLowerCase() + " ", "<" + e.target.value + " ").replace("</" + t.nodeName.toLowerCase() + ">", "</" + e.target.value + ">")
                    }))
                }
            }))
        })), e("admin_content_edit_preview_toggle", (function () {
            document.addEventListener("input", (function (e) {
                if (e.target && e.target.hasAttribute("data-edit-content-toggle-input")) {
                    var t = e.target.closest(".cms-module-edit").querySelector(".module-preview"),
                        n = "checkbox" == e.target.type ? e.target.checked : e.target.value,
                        o = t.querySelectorAll("[data-edit-content-toggle-target='" + e.target.dataset.editContentToggleInput + "']");
                    o.length && o.forEach((function (e) {
                        n ? e.classList.remove("d-none") : e.classList.add("d-none")
                    }))
                }
            }))
        }));
        var ye = n(199);

        function Ce(e, t) {
            t.preventDefault();
            var n, o = t.target.dataset.confirmModalTitle || "",
                a = (n = t.target.dataset.confirmModal || "", decodeURIComponent(atob(n).split("").map((function (e) {
                    return "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)
                })).join(""))), s = t.target.dataset.confirmModalConfirmButton || "Continue",
                i = t.target.dataset.confirmModalConfirmButtonType || "primary",
                l = t.target.dataset.confirmModalCancelButton || "Cancel";
            if (t.target.href) return function (e, t, n, o, a, s) {
                var i = function (e, t, n, o, r) {
                    var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                        s = Math.random().toString(36).substring(7), i = "";
                    e && (i = '<div class="modal-header">\n        <h5 class="modal-title">'.concat(e, '</h5>\n        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>\n      </div>'));
                    var l = "";
                    l = a ? '<a href="'.concat(a, '" class="btn btn-').concat(o, '">').concat(n, "</a>") : '<button type="button" class="btn btn-'.concat(o, '">').concat(n, "</button>");
                    var d = '\n    <div class="modal" tabindex="-1" id="'.concat(s, '">\n  <div class="modal-dialog modal-dialog-centered">\n    <div class="modal-content">\n      ').concat(i, '  \n      <div class="modal-body">').concat(t, '</div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">').concat(r, "</button>\n        ").concat(l, "\n      </div>\n    </div>\n  </div>\n</div>"),
                        c = document.createElement("div");
                    return document.body.appendChild(c), c.outerHTML = d, s
                }(e, t, n, o, a, s), l = document.getElementById(i);
                new r.Modal(l, {keyboard: !1}).show()
            }(o, a, s, i, l, t.target.href), !1;
            console.error("Only links are supported for confirm modal")
        }

        e("admin_content_edit_wysiwyg", (function () {
            document.addEventListener("focusin", (function (e) {
                e.target && e.target.hasAttribute("data-edit-content-wysiwyg") && (e.preventDefault(), e.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.wysiwyg.focusin", {bubbles: !0})))
            })), document.addEventListener("focusout", (function () {
                event.target && event.target.hasAttribute("data-edit-content-wysiwyg") && (event.preventDefault(), event.target.dispatchEvent(new CustomEvent("sfs_cms.content_edit.wysiwyg.focusout", {bubbles: !0})))
            })), document.addEventListener("sfs_cms.content_edit.wysiwyg.focusin", (function (e) {
                e.preventDefault(), function (e) {
                    e.id || (e.id = "wswg" + Math.random().toString(36).substr(2, 9));
                    if ("tinymce" === e.dataset.editContentWysiwyg) !function (e) {
                        var t = ["bold italic underline strikethrough | alignleft aligncenter alignright alignjustify | link anchor code |  numlist bullist | codesample", "outdent indent | forecolor removeformat | ltr rtl | fontsize blocks | charmap emoticons"],
                            n = void 0 !== window.sfs_cms_tinymce_default_toolbar ? window.sfs_cms_tinymce_default_toolbar : t,
                            o = e.dataset.editContentWysiwygToolbar ? e.dataset.editContentWysiwygToolbar : n,
                            r = "strong,em,span[style],a[href],p[style],ul,ol,li,br,hr,h1,h2,h3,h4,h5,h6",
                            a = void 0 !== window.sfs_cms_tinymce_default_valid_elements ? window.sfs_cms_tinymce_default_valid_elements : r,
                            s = e.dataset.editContentWysiwygValidElements ? e.dataset.editContentWysiwygValidElements : a,
                            i = "image link media lists autolink anchor pagebreak charmap emoticons",
                            l = void 0 !== window.sfs_cms_tinymce_default_plugins ? window.sfs_cms_tinymce_default_plugins : i,
                            d = e.dataset.editContentWysiwygPlugins ? e.dataset.editContentWysiwygPlugins : l,
                            c = '{ "*": "font-size,font-family,color,text-decoration,text-align" }',
                            u = void 0 !== window.sfs_cms_tinymce_default_valid_styles ? window.sfs_cms_tinymce_default_valid_styles : c,
                            m = JSON.parse(e.dataset.editContentWysiwygValidStyles ? e.dataset.editContentWysiwygValidStyles : u);
                        ye.init({
                            selector: "#" + e.id,
                            base_url: void 0 !== window.sfs_cms_tinymce_base_url ? window.sfs_cms_tinymce_base_url : "/build/tinymce",
                            highlight_on_focus: !0,
                            menubar: !1,
                            inline: !0,
                            hidden_input: !1,
                            plugins: d,
                            toolbar: o,
                            valid_elements: s,
                            valid_styles: m,
                            setup: function (t) {
                                t.on("change", (function () {
                                    me(e)
                                }))
                            },
                            min_height: 30
                        })
                    }(e); else console.error("Wysiwyg " + e.dataset.editContentWysiwyg + " not implemented")
                }(e.target)
            })), document.addEventListener("sfs_cms.content_edit.wysiwyg.focusout", (function (e) {
                e.preventDefault()
            }))
        })), e("admin_confirm_modal", (function () {
            t("[data-confirm-modal]", "click", Ce)
        }));
        var Ee = n(380), we = n(323);

        function _e(e) {
            e.split(",").forEach((function (e) {
                var t = document.querySelector('[data-field-container="' + e + '"]');
                t && t.showElement()
            }))
        }

        function Se(e) {
            e.split(",").forEach((function (e) {
                var t = document.querySelector('[data-field-container="' + e + '"]');
                t && t.hideElement()
            }))
        }

        function ke(e) {
            e.split(",").forEach((function (e) {
                var t = document.querySelector('[data-field-container="' + e + '"]');
                t && t.querySelectorAll("input, select, textarea").forEach((function (e) {
                    e.value = ""
                }))
            }))
        }

        function xe(e) {
            e.querySelectorAll("input[type=radio]").forEach((function (e) {
                e.checked && (void 0 !== e.dataset.showFields && _e(e.dataset.showFields), void 0 !== e.dataset.hideFields && Se(e.dataset.hideFields), void 0 !== e.dataset.emptyFields && ke(e.dataset.emptyFields))
            })), e.querySelectorAll("input[type=checkbox]").forEach((function (e) {
                e.checked ? (void 0 !== e.dataset.showFieldsIfChecked && _e(e.dataset.showFieldsIfChecked), void 0 !== e.dataset.hideFieldsIfChecked && Se(e.dataset.hideFieldsIfChecked), void 0 !== e.dataset.emptyFieldsIfChecked && ke(e.dataset.emptyFieldsIfChecked)) : (void 0 !== e.dataset.showFieldsIfUnchecked && _e(e.dataset.showFieldsIfUnchecked), void 0 !== e.dataset.hideFieldsIfUnchecked && Se(e.dataset.hideFieldsIfUnchecked), void 0 !== e.dataset.emptyFieldsIfUnchecked && ke(e.dataset.emptyFieldsIfUnchecked))
            })), e.querySelectorAll("select").forEach((function (e) {
                var t = e.options[e.selectedIndex];
                t && (void 0 !== t.dataset.showFields && _e(t.dataset.showFields), void 0 !== t.dataset.hideFields && Se(t.dataset.hideFields), void 0 !== t.dataset.emptyFields && ke(t.dataset.emptyFields))
            }))
        }

        function Ae(e) {
            var t = e.options[e.selectedIndex], n = document.getElementById(e.dataset.localeDisablesChoice);
            o('input[type="checkbox"]', (function (e) {
                return e.removeAttribute("disabled")
            }));
            var r = n.querySelector('input[type="checkbox"][value="' + t.value + '"]');
            r.checked = !0, r.setAttribute("checked", "checked"), r.setAttribute("disabled", "disabled")
        }

        function Ne(e) {
            return function (e) {
                if (Array.isArray(e)) return Te(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return Te(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Te(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Te(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function Re(e) {
            var t = e.options[e.selectedIndex];
            Ne(e.parentElement.querySelectorAll("[data-block-message-when]")).forEach((function (e) {
                var n = "" !== t.value;
                void 0 !== e.dataset.blockWhenNotEsi && void 0 !== t.dataset.blockEsi && (n &= !1), void 0 !== e.dataset.blockWhenEsi && null == t.dataset.blockEsi && (n &= !1), void 0 !== e.dataset.blockWhenNotSchedulable && void 0 !== t.dataset.blockSchedulable && (n &= !1), void 0 !== e.dataset.blockWhenSchedulable && void 0 === t.dataset.blockSchedulable && (n &= !1), n ? e.classList.remove("d-none") : e.classList.add("d-none")
            }))
        }

        function De(e) {
            var t = e.closest(".input-group").querySelector("[data-color-type=widget]");
            if (t && (t.disabled = !e.checked, t.disabled ? t.classList.add("disabled") : t.classList.remove("disabled"), t.hasAttribute("data-edit-bgcolor-input"))) {
                var n = t.closest(".cms-module-edit").querySelector(".module-preview").querySelectorAll("[data-edit-bgcolor-target='" + t.dataset.editBgcolorInput + "']");
                n.length && (t.disabled ? n.forEach((function (e) {
                    return e.style.backgroundColor = null
                })) : n.forEach((function (e) {
                    return e.style.backgroundColor = t.value
                })))
            }
        }

        function Le(e) {
            return function (e) {
                if (Array.isArray(e)) return Oe(e)
            }(e) || function (e) {
                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
            }(e) || function (e, t) {
                if (e) {
                    if ("string" == typeof e) return Oe(e, t);
                    var n = {}.toString.call(e).slice(8, -1);
                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Oe(e, t) : void 0
                }
            }(e) || function () {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }

        function Oe(e, t) {
            (null == t || t > e.length) && (t = e.length);
            for (var n = 0, o = Array(t); n < t; n++) o[n] = e[n];
            return o
        }

        function Be(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = e.options[e.selectedIndex], o = document.getElementById(e.dataset.routeParams),
                r = document.querySelector("label[for=" + o.id + "]"),
                a = document.querySelector("[data-route-show-params=" + o.id + "]"),
                s = document.querySelector("[data-route-hide-params=" + o.id + "]"), i = void 0 === n.dataset.init;
            n.dataset.init = !0;
            var l = function (e) {
                var t = {};
                for (var n in e.attributes) {
                    var o = e.attributes[n];
                    if (o.nodeName && o.nodeName.startsWith("data-route-parameter-")) {
                        var r = o.nodeName.substring(21), a = o.nodeValue;
                        t[r] = a
                    }
                }
                return t
            }(n), d = Object.keys(l).length, c = l;
            if (i && o.value && "change" !== t) {
                var u = JSON.parse(o.value);
                u && Le(Object.keys(u)).forEach((function (e) {
                    c[e] = u[e]
                }))
            }
            Object.keys(c).length ? (o.closest("div").showElement(), r && r.closest("div").showElement(), o.value = JSON.stringify(c)) : (o.closest("div").hideElement(), r && r.closest("div").hideElement(), o.value = "{}"), null !== a && null !== s && (d ? (a.hideElement(), s.hideElement()) : Object.keys(c).length ? (a.hideElement(), s.showElement()) : (a.showElement(), s.hideElement()))
        }

        e("admin_routes_forms", (function () {
            document.addEventListener("keyup", (function (e) {
                if (e.target.matches("[data-generate-underscore]") || e.target.matches("[data-generate-slug]")) {
                    var t = document.querySelector("[" + e.target.dataset.generateUnderscore + "]");
                    t && t.value === Ee(e.target.lastValue || "") && (t.value = Ee(e.target.value).removeAccents()), (t = document.querySelector("[" + e.target.dataset.generateSlug + "]")) && t.value.replace(/^\/+/, "").replace(/\/+$/, "") === we(e.target.lastValue || "") && (t.value = we(e.target.value).removeAccents()), e.target.lastValue = e.target.value.removeAccents()
                }
            })), document.addEventListener("keyup", (function (e) {
                e.target.matches(".snake-case") && (e.target.value = Ee(e.target.value))
            })), document.addEventListener("keyup", (function (e) {
                e.target.matches(".sluggize") && (e.target.value = we(e.target.value))
            }))
        })), String.prototype.removeAccents = function () {
            return this.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        }, e("admin_fields_visibility", (function () {
            xe(document), document.addEventListener("collection.node.insert.after", (function (e) {
                xe(e.target)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "radio" === e.target.getAttribute("type") && e.target.matches("[data-show-fields]") && _e(e.target.dataset.showFields)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "radio" === e.target.getAttribute("type") && e.target.matches("[data-hide-fields]") && Se(e.target.dataset.hideFields)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "radio" === e.target.getAttribute("type") && e.target.matches("[data-empty-fields]") && ke(e.target.dataset.emptyFields)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "checkbox" === e.target.getAttribute("type") && e.target.matches("[data-show-fields-if-checked]") && e.target.checked && _e(e.target.dataset.showFieldsIfChecked)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "checkbox" === e.target.getAttribute("type") && e.target.matches("[data-show-fields-if-unchecked]") && !e.target.checked && _e(e.target.dataset.showFieldsIfUnchecked)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "checkbox" === e.target.getAttribute("type") && e.target.matches("[data-hide-fields-if-checked]") && e.target.checked && Se(e.target.dataset.hideFieldsIfChecked)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "checkbox" === e.target.getAttribute("type") && e.target.matches("[data-hide-fields-if-unchecked]") && !e.target.checked && Se(e.target.dataset.hideFieldsIfUnchecked)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "checkbox" === e.target.getAttribute("type") && e.target.matches("[data-empty-fields-if-checked]") && e.target.checked && ke(e.target.dataset.emptyFieldsIfChecked)
            })), document.addEventListener("change", (function (e) {
                "INPUT" === e.target.tagName && "checkbox" === e.target.getAttribute("type") && e.target.matches("[data-empty-fields-if-unchecked]") && !e.target.checked && ke(e.target.dataset.emptyFieldsIfUnchecked)
            })), document.addEventListener("change", (function (e) {
                if ("SELECT" === e.target.tagName) {
                    var t = e.target.options[e.target.selectedIndex];
                    t && t.matches("[data-show-fields]") && _e(t.dataset.showFields)
                }
            })), document.addEventListener("change", (function (e) {
                if ("SELECT" === e.target.tagName) {
                    var t = e.target.options[e.target.selectedIndex];
                    t && t.matches("[data-hide-fields]") && Se(t.dataset.hideFields)
                }
            })), document.addEventListener("change", (function (e) {
                if ("SELECT" === e.target.tagName) {
                    var t = e.target.options[e.target.selectedIndex];
                    t && t.matches("[data-empty-fields]") && ke(t.dataset.emptyFields)
                }
            }))
        })), e("admin_locales_widgets", (function () {
            t("select[data-locale-disables-choice]", "change", Ae), o("select[data-locale-disables-choice]", Ae)
        })), e("types_block_type", (function () {
            document.addEventListener("change", (function (e) {
                e.target && e.target.matches("[data-block-message-select]") && Re(e.target)
            })), Ne(document.querySelectorAll("[data-block-message-select]")).forEach((function (e) {
                return Re(e)
            })), document.addEventListener("collection.node.add.after", (function (e) {
                Ne(e.node().querySelectorAll("[data-block-message-select]")).forEach((function (e) {
                    return Re(e)
                }))
            })), document.addEventListener("collection.node.insert.after", (function (e) {
                Ne(e.node().querySelectorAll("[data-block-message-select]")).forEach((function (e) {
                    return Re(e)
                }))
            }))
        })), e("types_color_type", (function () {
            document.querySelectorAll("[data-color-type=toggler]").forEach((function (e) {
                De(e)
            })), document.addEventListener("change", (function (e) {
                e.target && e.target.matches("[data-color-type=toggler]") && De(e.target)
            })), document.addEventListener("change", (function (e) {
                if (e.target && e.target.matches("[data-color-type=widget]")) {
                    var t = e.target, n = t.closest(".input-group").querySelector("[data-color-type=toggler]");
                    n && (t.value && !n.checked && (n.checked = !0), De(n))
                }
            }))
        })), e("types_symfony_route_type", (function () {
            document.addEventListener("click", (function (e) {
                if (e.target.matches("[data-route-show-params]") || e.target.matches("[data-route-hide-params]")) if (e.target.hideElement(), e.target.matches("[data-route-show-params]")) {
                    var t = e.target.dataset.routeShowParams, n = document.getElementById(t),
                        o = document.querySelector("label[for=" + t + "]");
                    document.querySelector("[data-route-hide-params=" + t + "]").showElement(), n.closest("div").showElement(), o.closest("div").showElement()
                } else {
                    var r = e.target.dataset.routeHideParams, a = document.getElementById(r),
                        s = document.querySelector("label[for=" + r + "]");
                    document.querySelector("[data-route-show-params=" + r + "]").showElement(), a.value = "{}", a.closest("div").hideElement(), s.closest("div").hideElement()
                }
            })), document.addEventListener("change", (function (e) {
                e.target.matches("[data-route-params]") && Be(e.target, "change")
            })), Le(document.querySelectorAll("[data-route-params]")).forEach((function (e) {
                Be(e, "init")
            })), document.addEventListener("collection.node.insert.after", (function (e) {
                Le(e.node().querySelectorAll("[data-route-params]")).forEach((function (e) {
                    Be(e)
                }))
            })), Le(document.querySelectorAll("[data-route-params]")).forEach((function (e) {
                e.value || document.getElementById(e.dataset.routeParams).closest("div").hideElement()
            }))
        }))
    })()
})();